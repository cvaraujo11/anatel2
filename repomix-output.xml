This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.idx/
  dev.nix
  integrations.json
app/
  alimentacao/
    page.tsx
  autoconhecimento/
    page.tsx
  components/
    alimentacao/
      LembreteHidratacao.tsx
      PlanejadorRefeicoes.tsx
      RegistroRefeicoes.tsx
    autoconhecimento/
      EditorNotas.tsx
      ListaNotas.tsx
      ModoRefugio.tsx
    concursos/
      ConcursoForm.tsx
      GeradorContextoLLM.tsx
      GeradorQuestoesLLM.tsx
      ImportarConcursoJsonModal.tsx
      QuestaoCard.tsx
      QuestaoForm.tsx
      QuestaoList.tsx
    estudos/
      simulado/
        HistoricoModal.tsx
        SimuladoLoader.tsx
        SimuladoResults.tsx
        SimuladoReview.tsx
      RegistroEstudos.tsx
      TemporizadorPomodoro.tsx
      VisualizadorChecklist.tsx
      VisualizadorMarkdown.tsx
    financas/
      AdicionarDespesa.tsx
      CalendarioPagamentos.tsx
      EnvelopesVirtuais.tsx
      RastreadorGastos.tsx
    hiperfocos/
      ConversorInteresses.tsx
      SistemaAlternancia.tsx
      TemporizadorFoco.tsx
      VisualizadorProjetos.tsx
    inicio/
      ChecklistMedicamentos.tsx
      LembretePausas.tsx
      ListaPrioridades.tsx
      PainelDia.tsx
      ProximaProvaCard.tsx
    layout/
      Footer.tsx
      Header.tsx
      Sidebar.tsx
    lazer/
      AtividadesLazer.tsx
      SugestoesDescanso.tsx
      TemporizadorLazer.tsx
    perfil/
      InformacoesPessoais.tsx
      MetasDiarias.tsx
      PreferenciasVisuais.tsx
    receitas/
      AdicionarReceitaForm.tsx
      DetalhesReceita.tsx
      FiltroCategorias.tsx
      ImportadorReceitas.tsx
      ListaCompras.tsx
      ListaReceitas.tsx
    saude/
      FatoresHumor.tsx
      HumorCalendar.tsx
      MedicamentosList.tsx
      MonitoramentoHumor.tsx
      RegistroMedicamentos.tsx
      StatCard.tsx
    sono/
      ConfiguracaoLembretes.tsx
      RegistroSono.tsx
      VisualizadorSemanal.tsx
    ui/
      Alert.tsx
      Badge.tsx
      Button.tsx
      Card.tsx
      Checkbox.tsx
      Container.tsx
      DashboardCard.tsx
      DashboardHeader.tsx
      DashboardSection.tsx
      DashboardSummary.tsx
      Input.tsx
      Modal.tsx
      Pesquisa.tsx
      PreferencesButton.tsx
      Section.tsx
      Select.tsx
      Slider.tsx
      StatCard.tsx
      SuspenseWrapper.tsx
      Tag.tsx
      TagInput.tsx
      Textarea.tsx
      Tooltip.tsx
    ExportarImportarDados.tsx
    ThemeProvider.tsx
  concursos/
    [id]/
      page.tsx
    page.tsx
  estudos/
    materiais/
      page.tsx
    simulado/
      page.tsx
    simulado-personalizado/
      page.tsx
    page.tsx
  financas/
    page.tsx
  hiperfocos/
    page.tsx
  hooks/
    useDashboard.ts
  lazer/
    page.tsx
  lib/
    dataService.ts
    googleDriveClient.ts
    session.ts
    utils.ts
  perfil/
    ajuda/
      page.tsx
    page.tsx
  receitas/
    [id]/
      page.tsx
    adicionar/
      page.tsx
    editar/
      [id]/
        page.tsx
    lista-compras/
      page.tsx
    page.tsx
  roadmap/
    page.tsx
  saude/
    page.tsx
  sono/
    page.tsx
  store/
    index.ts
  stores/
    alimentacaoStore.ts
    atividadesStore.ts
    autoconhecimentoStore.ts
    concursosStore.ts
    dataTransferStore.ts
    financasStore.ts
    hiperfocosStore.ts
    historicoSimuladosStore.ts
    painelDiaStore.ts
    perfilStore.ts
    pomodoroStore.ts
    prioridadesStore.ts
    questoesStore.ts
    receitasStore.ts
    registroEstudosStore.ts
    simuladoStore.ts
    sonoStore.ts
    sugestoesStore.ts
  types/
    index.ts
  globals.css
  layout.tsx
  page.tsx
  providers.tsx
docs/
  technical/
    03-pages/
      alimentacao.md
      autoconhecimento.md
      concursos-id.md
      concursos.md
      estudos-materiais.md
      estudos-simulado-personalizado.md
      estudos-simulado.md
      estudos.md
      financas.md
      hiperfocos.md
      inicio.md
      lazer.md
      perfil-ajuda.md
      perfil.md
      README.md
      receitas-adicionar.md
      receitas-editar-id.md
      receitas-id.md
      receitas-lista-compras.md
      receitas.md
      roadmap.md
      saude.md
      sono.md
    01-project-overview.md
    02-routing.md
    04-ui-components.md
    05-state-management.md
    06-libraries-services.md
    README.md
  exemplo-receita-unica.json
  exemplo-receitas-multiplas.json
  guia-receitas.md
  receita-plan.md
pages/
  api/
    auth/
      google/
        callback.ts
        connect.ts
        disconnect.ts
    drive/
      carregar-material.ts
      checkAuth.ts
      list.ts
      listar-materiais.ts
      load.ts
      save.ts
    materiais/
      ler.ts
      listar.ts
    gerar-questao.ts
perplexity-mcp-server/
  .git/
    logs/
      refs/
        heads/
          main
        remotes/
          origin/
            HEAD
      HEAD
    refs/
      heads/
        main
      remotes/
        origin/
          HEAD
    config
    FETCH_HEAD
    HEAD
    packed-refs
  .github/
    workflows/
      node.js.yml
  src/
    index.ts
  .gitignore
  LICENSE
  package.json
  README.md
  tsconfig.json
public/
  images/
    cat-icon.svg
    logo.svg
  sounds/
    alarm.mp3
    alarm.ogg
  favicon.svg
  simulado-exemplo.json
.cursorrules
.gitignore
app.json
dash.md
deploy.sh
next.config.js
package.json
postcss.config.js
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="perplexity-mcp-server/.git/logs/refs/heads/main">
0000000000000000000000000000000000000000 ff99fd1d14a81d7686a6a2dd44f9dbdd5d9bd60f claudiovinicius.unilab <claudiovinicius.unilab@gmail.com> 1747493811 +0000	clone: from https://github.com/pashpashpash/perplexity-mcp.git
</file>

<file path="perplexity-mcp-server/.git/logs/refs/remotes/origin/HEAD">
0000000000000000000000000000000000000000 ff99fd1d14a81d7686a6a2dd44f9dbdd5d9bd60f claudiovinicius.unilab <claudiovinicius.unilab@gmail.com> 1747493811 +0000	clone: from https://github.com/pashpashpash/perplexity-mcp.git
</file>

<file path="perplexity-mcp-server/.git/logs/HEAD">
0000000000000000000000000000000000000000 ff99fd1d14a81d7686a6a2dd44f9dbdd5d9bd60f claudiovinicius.unilab <claudiovinicius.unilab@gmail.com> 1747493811 +0000	clone: from https://github.com/pashpashpash/perplexity-mcp.git
</file>

<file path="perplexity-mcp-server/.git/refs/heads/main">
ff99fd1d14a81d7686a6a2dd44f9dbdd5d9bd60f
</file>

<file path="perplexity-mcp-server/.git/refs/remotes/origin/HEAD">
ref: refs/remotes/origin/main
</file>

<file path="perplexity-mcp-server/.git/config">
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = https://github.com/pashpashpash/perplexity-mcp.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main
	vscode-merge-base = origin/main
</file>

<file path="perplexity-mcp-server/.git/FETCH_HEAD">
ff99fd1d14a81d7686a6a2dd44f9dbdd5d9bd60f		branch 'main' of https://github.com/pashpashpash/perplexity-mcp
</file>

<file path="perplexity-mcp-server/.git/HEAD">
ref: refs/heads/main
</file>

<file path="perplexity-mcp-server/.git/packed-refs">
# pack-refs with: peeled fully-peeled sorted 
ff99fd1d14a81d7686a6a2dd44f9dbdd5d9bd60f refs/remotes/origin/main
</file>

<file path="perplexity-mcp-server/.github/workflows/node.js.yml">
# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs

name: Node.js CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:

    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x, 22.x]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/

    steps:
    - uses: actions/checkout@v4
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    - run: npm ci
    - run: npm run build --if-present
    - run: npm test
</file>

<file path="perplexity-mcp-server/src/index.ts">
#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  McpError,
  ErrorCode,
} from "@modelcontextprotocol/sdk/types.js";
import axios from "axios";
import Database from "better-sqlite3";
import { existsSync, mkdirSync } from "fs";
import { dirname, join } from "path";
import { homedir } from "os";

const PERPLEXITY_API_KEY = process.env.PERPLEXITY_API_KEY;
if (!PERPLEXITY_API_KEY) {
  throw new Error("PERPLEXITY_API_KEY environment variable is required");
}

interface ChatMessage {
  role: "user" | "assistant";
  content: string;
}

class PerplexityServer {
  private server: Server;
  private axiosInstance;
  private db: Database.Database;

  constructor() {
    this.server = new Server(
      {
        name: "perplexity-server",
        version: "0.1.0",
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.axiosInstance = axios.create({
      baseURL: "https://api.perplexity.ai",
      headers: {
        "Authorization": `Bearer ${PERPLEXITY_API_KEY}`,
        "Content-Type": "application/json",
      },
    });

    // Initialize SQLite database
    const dbPath = join(homedir(), ".perplexity-mcp", "chat_history.db");

    // Ensure the directory exists
    const dbDir = dirname(dbPath);
    if (!existsSync(dbDir)) {
      mkdirSync(dbDir);
    }

    this.db = new Database(dbPath, { fileMustExist: false });
    this.initializeDatabase();

    this.setupToolHandlers();
    
    // Error handling
    this.server.onerror = (error) => console.error("[MCP Error]", error);
    process.on("SIGINT", async () => {
      this.db.close();
      await this.server.close();
      process.exit(0);
    });
  }

  private initializeDatabase() {
    // Create chats table
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS chats (
        id TEXT PRIMARY KEY,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create messages table
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        chat_id TEXT NOT NULL,
        role TEXT NOT NULL,
        content TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (chat_id) REFERENCES chats(id)
      )
    `);
  }

  private getChatHistory(chatId: string): ChatMessage[] {
    const messages = this.db.prepare(
      "SELECT role, content FROM messages WHERE chat_id = ? ORDER BY created_at ASC"
    ).all(chatId);
    return messages as ChatMessage[];
  }

  private saveChatMessage(chatId: string, message: ChatMessage) {
    // Ensure chat exists
    this.db.prepare(
      "INSERT OR IGNORE INTO chats (id) VALUES (?)"
    ).run(chatId);

    // Save message
    this.db.prepare(
      "INSERT INTO messages (chat_id, role, content) VALUES (?, ?, ?)"
    ).run(chatId, message.role, message.content);
  }

  private setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: "chat_perplexity",
          description: "Maintains ongoing conversations with Perplexity AI. Creates new chats or continues existing ones with full history context.",
          inputSchema: {
            type: "object",
            properties: {
              message: {
                type: "string",
                description: "The message to send to Perplexity AI"
              },
              chat_id: {
                type: "string",
                description: "Optional: ID of an existing chat to continue. If not provided, a new chat will be created."
              }
            },
            required: ["message"]
          }
        },
        {
          name: "search",
          description: "Perform a general search query to get comprehensive information on any topic",
          inputSchema: {
            type: "object",
            properties: {
              query: {
                type: "string",
                description: "The search query or question"
              },
              detail_level: {
                type: "string",
                description: "Optional: Desired level of detail (brief, normal, detailed)",
                enum: ["brief", "normal", "detailed"]
              }
            },
            required: ["query"]
          }
        },
        {
          name: "get_documentation",
          description: "Get documentation and usage examples for a specific technology, library, or API",
          inputSchema: {
            type: "object",
            properties: {
              query: {
                type: "string",
                description: "The technology, library, or API to get documentation for"
              },
              context: {
                type: "string",
                description: "Additional context or specific aspects to focus on"
              }
            },
            required: ["query"]
          }
        },
        {
          name: "find_apis",
          description: "Find and evaluate APIs that could be integrated into a project",
          inputSchema: {
            type: "object",
            properties: {
              requirement: {
                type: "string",
                description: "The functionality or requirement you're looking to fulfill"
              },
              context: {
                type: "string",
                description: "Additional context about the project or specific needs"
              }
            },
            required: ["requirement"]
          }
        },
        {
          name: "check_deprecated_code",
          description: "Check if code or dependencies might be using deprecated features",
          inputSchema: {
            type: "object",
            properties: {
              code: {
                type: "string",
                description: "The code snippet or dependency to check"
              },
              technology: {
                type: "string",
                description: "The technology or framework context (e.g., 'React', 'Node.js')"
              }
            },
            required: ["code"]
          }
        }
      ]
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      try {
        switch (request.params.name) {
          case "chat_perplexity": {
            const { message, chat_id = crypto.randomUUID() } = request.params.arguments as { 
              message: string; 
              chat_id?: string;
            };

            // Get chat history
            const history = this.getChatHistory(chat_id);
            
            // Add new user message
            const userMessage: ChatMessage = { role: "user", content: message };
            this.saveChatMessage(chat_id, userMessage);

            // Prepare messages array with history
            const messages = [...history, userMessage];

            // Call Perplexity API
            const response = await this.axiosInstance.post("/chat/completions", {
              model: "sonar-reasoning-pro",
              messages,
            });

            // Save assistant's response
            const assistantMessage: ChatMessage = {
              role: "assistant",
              content: response.data.choices[0].message.content,
            };
            this.saveChatMessage(chat_id, assistantMessage);

            return {
              content: [{
                type: "text",
                text: JSON.stringify({
                  chat_id,
                  response: assistantMessage.content
                }, null, 2)
              }]
            };
          }

          case "get_documentation": {
            const { query, context = "" } = request.params.arguments as { query: string; context?: string };
            const prompt = `Provide comprehensive documentation and usage examples for ${query}. ${context ? `Focus on: ${context}` : ""} Include:
            1. Basic overview and purpose
            2. Key features and capabilities
            3. Installation/setup if applicable
            4. Common usage examples
            5. Best practices
            6. Common pitfalls to avoid
            7. Links to official documentation if available`;

            const response = await this.axiosInstance.post("/chat/completions", {
              model: "sonar-reasoning-pro",
              messages: [{ role: "user", content: prompt }],
            });

            return {
              content: [{
                type: "text",
                text: response.data.choices[0].message.content
              }]
            };
          }

          case "find_apis": {
            const { requirement, context = "" } = request.params.arguments as { requirement: string; context?: string };
            const prompt = `Find and evaluate APIs that could be used for: ${requirement}. ${context ? `Context: ${context}` : ""} For each API, provide:
            1. Name and brief description
            2. Key features and capabilities
            3. Pricing model (if available)
            4. Integration complexity
            5. Documentation quality
            6. Community support and popularity
            7. Any potential limitations or concerns
            8. Code example of basic usage`;

            const response = await this.axiosInstance.post("/chat/completions", {
              model: "sonar-reasoning-pro",
              messages: [{ role: "user", content: prompt }],
            });

            return {
              content: [{
                type: "text",
                text: response.data.choices[0].message.content
              }]
            };
          }

          case "check_deprecated_code": {
            const { code, technology = "" } = request.params.arguments as { code: string; technology?: string };
            const prompt = `Analyze this code for deprecated features or patterns${technology ? ` in ${technology}` : ""}:

            ${code}

            Please provide:
            1. Identification of any deprecated features, methods, or patterns
            2. Current recommended alternatives
            3. Migration steps if applicable
            4. Impact of the deprecation
            5. Timeline of deprecation if known
            6. Code examples showing how to update to current best practices`;

            const response = await this.axiosInstance.post("/chat/completions", {
              model: "sonar-reasoning-pro",
              messages: [{ role: "user", content: prompt }],
            });

            return {
              content: [{
                type: "text",
                text: response.data.choices[0].message.content
              }]
            };
          }

          case "search": {
            const { query, detail_level = "normal" } = request.params.arguments as { query: string; detail_level?: "brief" | "normal" | "detailed" };
            
            let prompt = query;
            switch (detail_level) {
              case "brief":
                prompt = `Provide a brief, concise answer to: ${query}`;
                break;
              case "detailed":
                prompt = `Provide a comprehensive, detailed analysis of: ${query}. Include relevant examples, context, and supporting information where applicable.`;
                break;
              default:
                prompt = `Provide a clear, balanced answer to: ${query}. Include key points and relevant context.`;
            }

            const response = await this.axiosInstance.post("/chat/completions", {
              model: "sonar-reasoning-pro",
              messages: [{ role: "user", content: prompt }],
            });

            return {
              content: [{
                type: "text",
                text: response.data.choices[0].message.content
              }]
            };
          }

          default:
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${request.params.name}`
            );
        }
      } catch (error) {
        if (axios.isAxiosError(error)) {
          throw new McpError(
            ErrorCode.InternalError,
            `Perplexity API error: ${error.response?.data?.error?.message || error.message}`
          );
        }
        throw error;
      }
    });
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error("Perplexity MCP server running on stdio");
  }
}

const server = new PerplexityServer();
server.run().catch(console.error);
</file>

<file path="perplexity-mcp-server/.gitignore">
node_modules/
build/
*.log
.env*
</file>

<file path="perplexity-mcp-server/LICENSE">
MIT License

Copyright (c) 2025 DaInfernalCoder/Sumit Datta

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="perplexity-mcp-server/package.json">
{
  "name": "perplexity-server",
  "version": "0.1.0",
  "description": "alls upon perplexity api while i code to get docs, find apis to integrate, and to check deprecated code to make sure everything works properl",
  "private": true,
  "type": "module",
  "bin": {
    "perplexity-server": "./build/index.js"
  },
  "files": [
    "build"
  ],
  "scripts": {
    "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
    "prepare": "npm run build",
    "watch": "tsc --watch",
    "inspector": "npx @modelcontextprotocol/inspector build/index.js",
    "test": "tsc --noEmit"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "0.6.0",
    "axios": "^1.7.9",
    "better-sqlite3": "^11.8.1"
  },
  "devDependencies": {
    "@types/better-sqlite3": "^7.6.12",
    "@types/node": "^20.11.24",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="perplexity-mcp-server/README.md">
# MCP-researcher Server

Your own research assistant inside of Claude! Utilizes Perplexity's Sonar Pro API to get documentation, create up-to-date API routes, and check deprecated code. Includes Chain of Thought Reasoning and local chat history through SQLite.

<a href="https://glama.ai/mcp/servers/g1i6ilg8sl"><img width="380" height="200" src="https://glama.ai/mcp/servers/g1i6ilg8sl/badge" alt="MCP-researcher Server MCP server" /></a>

## Features

### 1. Search
Performs general search queries to get comprehensive information on any topic. Supports different detail levels (brief, normal, detailed) to get tailored responses.

### 2. Get Documentation
Retrieves documentation and usage examples for specific technologies, libraries, or APIs. Get comprehensive documentation including best practices and common pitfalls.

### 3. Find APIs
Discovers and evaluates APIs that could be integrated into a project. Get detailed analysis of features, pricing, and integration complexity.

### 4. Check Deprecated Code
Analyzes code for deprecated features or patterns, providing migration guidance. Helps modernize code by suggesting current best practices.

## Prerequisites

1. **System Requirements**:
   - Node.js (install from [nodejs.org](https://nodejs.org))
   - Python with distutils (required for some npm dependencies)
     ```bash
     # On macOS with Homebrew:
     brew install python-setuptools
     ```

2. **API Key**:
   - Get your Perplexity API key from [perplexity.ai/settings/api](https://www.perplexity.ai/settings/api)

## Installation

1. **Create Project Directory**:
   ```bash
   mkdir -p ~/Documents/Claude/MCP
   cd ~/Documents/Claude/MCP
   ```

2. **Clone the Repository**:
   ```bash
   git clone https://github.com/pashpashpash/perplexity-mcp.git
   cd perplexity-mcp
   ```

3. **Install Dependencies**:
   ```bash
   npm install
   ```
   Note: If you see Python distutils errors, make sure you've installed python-setuptools as mentioned in prerequisites.

4. **Build the Project**:
   ```bash
   npm run build
   ```
   This will create the build directory with the compiled server code.

## Configuration

1. **Configure Claude Desktop**:

Add this to your claude_desktop_config.json:
- macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
- Windows: `%APPDATA%/Claude/claude_desktop_config.json`

```json
{
  "mcpServers": {
    "perplexity-server": {
      "command": "node",
      "args": ["path/to/perplexity-mcp/build/index.js"],
      "env": {
        "PERPLEXITY_API_KEY": "your-api-key-here"
      },
      "autoApprove": [
        "search",
        "get_documentation",
        "find_apis",
        "check_deprecated_code"
      ]
    }
  }
}
```
Note: 
- Replace "path/to/perplexity-mcp" with the absolute path to your cloned repository
- Replace "your-api-key-here" with your Perplexity API key
- Make sure to use "/build/index.js" (not "/dist/index.js")

## Starting the Server

1. **Manual Start**:
   ```bash
   cd path/to/perplexity-mcp
   PERPLEXITY_API_KEY="your-api-key-here" node build/index.js
   ```

2. **Verify Server**:
   The server should start without any errors. Keep this terminal window open while using the server.

## Example Usage

### Search
```json
{
  "query": "What are the best practices for React hooks?",
  "detail_level": "detailed"
}
```

### Get Documentation
```json
{
  "technology": "React",
  "topic": "useEffect hook",
  "include_examples": true
}
```

### Find APIs
```json
{
  "category": "payment processing",
  "requirements": ["recurring billing", "international support"]
}
```

### Check Deprecated Code
```json
{
  "code": "class MyComponent extends React.Component {...}",
  "framework": "React",
  "version": "18"
}
```

## Troubleshooting

1. **Build Directory Issues**:
   - Make sure you're using the correct path in Claude Desktop config
   - Verify the build directory exists after running `npm run build`
   - Check that the path is using `/build/index.js`, not `/dist/index.js`

2. **Server Connection Issues**:
   - Ensure the server is running in a separate terminal
   - Verify the API key is properly set in the environment
   - Check Claude Desktop's MCP logs:
     ```bash
     tail -n 20 -f ~/Library/Logs/Claude/mcp*.log
     ```

3. **Python Dependencies**:
   - If you see Python distutils errors during npm install:
     ```bash
     brew install python-setuptools
     ```
   - Then retry `npm install`

## Development

```bash
# Install dependencies
npm install

# Build the project
npm run build

# Development with auto-rebuild
npm run watch

# Start server with debug output
DEBUG=* node build/index.js
```

## Documentation

For detailed examples and usage guides, see:
- [Search Examples](https://github.com/DaInfernalCoder/perplexity-mcp/blob/main/examples/search.md)
- [API Documentation Examples](https://github.com/DaInfernalCoder/perplexity-mcp/blob/main/examples/find-apis.md)
- [Deprecated Code Examples](https://github.com/DaInfernalCoder/perplexity-mcp/blob/main/examples/check-deprecated-code.md)

## License

MIT

---
Note: This is a fork of the [original perplexity-mcp repository](https://github.com/DaInfernalCoder/perplexity-mcp).
</file>

<file path="perplexity-mcp-server/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
</file>

<file path=".idx/dev.nix">
{pkgs}: {
  channel = "stable-24.05";
  packages = [
    pkgs.nodejs_20
  ];
  idx.extensions = [
    
  ];
  idx.previews = {
    previews = {
      web = {
        command = [
          "npm"
          "run"
          "dev"
          "--"
          "--port"
          "$PORT"
          "--hostname"
          "0.0.0.0"
        ];
        manager = "web";
      };
    };
  };
}
</file>

<file path=".idx/integrations.json">
{
  "cloud_run_deploy": {}
}
</file>

<file path="app/alimentacao/page.tsx">
import { Card } from '@/app/components/ui/Card'
import { PlanejadorRefeicoes } from '@/app/components/alimentacao/PlanejadorRefeicoes'
// Removed duplicate Card import
// Removed duplicate PlanejadorRefeicoes import
import { RegistroRefeicoes } from '@/app/components/alimentacao/RegistroRefeicoes'
import { LembreteHidratacao } from '@/app/components/alimentacao/LembreteHidratacao'
import Link from 'next/link'; // Import Link
import { Button } from '@/app/components/ui/Button'; // Import Button

export default function AlimentacaoPage() {
  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Alimentação</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Planejador de Refeições */}
        <Card title="Planejador de Refeições">
          <PlanejadorRefeicoes />
        </Card>
        
        {/* Registro Visual de Refeições */}
        <Card title="Registro de Refeições">
          <RegistroRefeicoes />
        </Card>
      </div>
      
      {/* Lembretes de Hidratação */}
      <Card title="Hidratação">
        <LembreteHidratacao />
      </Card>

      {/* Card para a Seção de Receitas */}
      <Card title="Minhas Receitas">
        <p className="mb-4 text-gray-600 dark:text-gray-400">
          Organize e acesse suas receitas favoritas aqui. Crie listas de compras e planeje suas refeições.
        </p>
        <Link href="/receitas" passHref>
          <Button color="primary">
            Acessar Minhas Receitas
          </Button>
        </Link>
      </Card>
    </div>
  )
}
</file>

<file path="app/autoconhecimento/page.tsx">
'use client'

import { useState } from 'react'
import { Anchor, PenSquare, X } from 'lucide-react'
import { EditorNotas } from '../components/autoconhecimento/EditorNotas'
import { ListaNotas } from '../components/autoconhecimento/ListaNotas'
import { ModoRefugio } from '../components/autoconhecimento/ModoRefugio'
import { Button } from '../components/ui/Button'
import { Container } from '../components/ui/Container'
import { Section } from '../components/ui/Section'
import { useAutoconhecimentoStore } from '../stores/autoconhecimentoStore'

export default function AutoconhecimentoPage() {
  const [abaSelecionada, setAbaSelecionada] = useState<'quem-sou' | 'meus-porques' | 'meus-padroes'>('quem-sou')
  const [notaSelecionada, setNotaSelecionada] = useState<string | null>(null)
  const [criandoNota, setCriandoNota] = useState(false)
  
  const { modoRefugio } = useAutoconhecimentoStore()
  
  // Mapeamento de títulos para exibição
  const tituloAbas = {
    'quem-sou': 'Quem sou',
    'meus-porques': 'Meus porquês',
    'meus-padroes': 'Meus padrões'
  }
  
  // Mapeamento de descrições para cada seção
  const descricaoAbas = {
    'quem-sou': 'Registre suas preferências, aversões e características pessoais estáveis',
    'meus-porques': 'Documente motivações e valores fundamentais que guiam suas decisões',
    'meus-padroes': 'Anote reações emocionais típicas e estratégias eficazes em momentos de crise'
  }
  
  // Função para selecionar uma nota
  const handleSelecionarNota = (id: string) => {
    setNotaSelecionada(id)
    setCriandoNota(false)
  }
  
  // Função para iniciar criação de nova nota
  const handleCriarNota = () => {
    setNotaSelecionada(null)
    setCriandoNota(true)
  }
  
  // Função para cancelar edição/criação
  const handleCancelar = () => {
    setNotaSelecionada(null)
    setCriandoNota(false)
  }
  
  // Função após salvar uma nota
  const handleSalvarNota = () => {
    setNotaSelecionada(null)
    setCriandoNota(false)
  }
  
  // Verifica se estamos no modo refúgio para simplificar a interface
  const interfaceSimplificada = modoRefugio
  
  return (
    <Container>
      {/* Cabeçalho com título */}
      <div className="flex items-center mb-6">
        <Anchor className="h-7 w-7 text-autoconhecimento-primary mr-3" aria-hidden="true" />
        <h1 className="text-2xl font-bold text-gray-800 dark:text-white">Notas de Autoconhecimento</h1>
      </div>
      
      {/* Navegação entre abas */}
      <div className="flex border-b border-gray-200 dark:border-gray-700 mb-6 overflow-x-auto">
        {(Object.keys(tituloAbas) as Array<keyof typeof tituloAbas>).map((aba) => (
          <button
            key={aba}
            className={`px-4 py-2 font-medium text-sm whitespace-nowrap rounded-t-lg transition-colors ${
              abaSelecionada === aba
                ? 'bg-autoconhecimento-light text-autoconhecimento-primary border-b-2 border-autoconhecimento-primary'
                : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
            }`}
            onClick={() => {
              setAbaSelecionada(aba)
              setNotaSelecionada(null)
              setCriandoNota(false)
            }}
            aria-current={abaSelecionada === aba ? 'page' : undefined}
          >
            {tituloAbas[aba]}
          </button>
        ))}
      </div>
      
      {/* Descrição da seção atual */}
      {!interfaceSimplificada && !notaSelecionada && !criandoNota && (
        <div className="mb-6 bg-autoconhecimento-light bg-opacity-60 dark:bg-gray-700 p-4 rounded-lg">
          <h2 className="text-lg font-medium text-autoconhecimento-primary mb-2">{tituloAbas[abaSelecionada]}</h2>
          <p className="text-gray-700 dark:text-gray-300">{descricaoAbas[abaSelecionada]}</p>
        </div>
      )}
      
      {/* Conteúdo principal */}
      <Section 
        title={tituloAbas[abaSelecionada]} 
        className={`${interfaceSimplificada ? 'bg-opacity-90' : ''} transition-opacity duration-300`}
      >
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Área de lista de notas */}
          <div className={notaSelecionada || criandoNota ? 'hidden lg:block' : 'block'}>
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium text-gray-800 dark:text-white">
                Suas notas em {tituloAbas[abaSelecionada]}
              </h3>
              
              {!interfaceSimplificada && (
                <Button
                  onClick={handleCriarNota}
                  className="flex items-center text-sm bg-autoconhecimento-primary text-white hover:bg-autoconhecimento-hover transition-colors"
                  aria-label="Criar nova nota"
                >
                  <PenSquare size={16} className="mr-1" />
                  <span>Nova nota</span>
                </Button>
              )}
            </div>
            
            <ListaNotas 
              secaoAtual={abaSelecionada}
              onSelectNota={handleSelecionarNota}
            />
          </div>
          
          {/* Área de edição/visualização */}
          {(notaSelecionada || criandoNota) && (
            <div className="lg:col-span-1">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-medium text-gray-800 dark:text-white">
                  {criandoNota ? 'Nova nota' : 'Editar nota'}
                </h3>
                
                <Button
                  onClick={handleCancelar}
                  className="flex items-center text-sm bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
                  aria-label="Cancelar edição"
                >
                  <X size={16} className="mr-1" />
                  <span>Cancelar</span>
                </Button>
              </div>
              
              <EditorNotas
                id={notaSelecionada || undefined}
                secaoAtual={abaSelecionada}
                onSave={handleSalvarNota}
              />
            </div>
          )}
        </div>
      </Section>
      
      {/* Botão flutuante para Modo Refúgio */}
      <ModoRefugio />
    </Container>
  )
}
</file>

<file path="app/components/alimentacao/LembreteHidratacao.tsx">
'use client'

import { Droplet, PlusCircle, MinusCircle } from 'lucide-react'
import { useAlimentacaoStore } from '@/app/stores/alimentacaoStore'

export function LembreteHidratacao() {
  const { 
    coposBebidos, 
    metaDiaria, 
    ultimoRegistro, 
    adicionarCopo, 
    removerCopo, 
    ajustarMeta 
  } = useAlimentacaoStore()

  // Calcular a porcentagem de progresso
  const progresso = Math.min((coposBebidos / metaDiaria) * 100, 100)

  return (
    <div className="space-y-4">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between">
        <div className="mb-4 md:mb-0">
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-1">
            Acompanhamento de Hidratação
          </h3>
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Registre os copos de água que você bebe durante o dia
          </p>
        </div>
        
        <div className="flex items-center space-x-2">
          <button
            onClick={() => ajustarMeta(-1)}
            className="p-1 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700"
            aria-label="Diminuir meta diária"
            disabled={metaDiaria <= 1}
          >
            <MinusCircle className="h-6 w-6" />
          </button>
          
          <div className="px-3 py-1 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
            <span className="text-sm font-medium text-blue-700 dark:text-blue-300">
              Meta: {metaDiaria} copos
            </span>
          </div>
          
          <button
            onClick={() => ajustarMeta(1)}
            className="p-1 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700"
            aria-label="Aumentar meta diária"
            disabled={metaDiaria >= 15}
          >
            <PlusCircle className="h-6 w-6" />
          </button>
        </div>
      </div>

      {/* Barra de progresso */}
      <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4 overflow-hidden">
        <div
          className="bg-blue-500 h-full transition-all duration-500 ease-out"
          style={{ width: `${progresso}%` }}
          role="progressbar"
          aria-valuenow={coposBebidos}
          aria-valuemin={0}
          aria-valuemax={metaDiaria}
        ></div>
      </div>

      <div className="flex items-center justify-between">
        <div className="text-sm text-gray-600 dark:text-gray-400">
          {coposBebidos} de {metaDiaria} copos
          {ultimoRegistro && (
            <span className="ml-2">
              (Último: {ultimoRegistro})
            </span>
          )}
        </div>
        
        <div className="text-blue-600 dark:text-blue-400">
          {progresso.toFixed(0)}%
        </div>
      </div>

      {/* Visualização dos copos */}
      <div className="flex flex-wrap gap-2 my-4 justify-center">
        {Array.from({ length: metaDiaria }).map((_, index) => (
          <div
            key={index}
            className={`w-12 h-16 flex items-center justify-center rounded-b-lg border border-t-0 ${
              index < coposBebidos
                ? 'bg-blue-100 border-blue-300 dark:bg-blue-900/30 dark:border-blue-700'
                : 'bg-gray-100 border-gray-300 dark:bg-gray-800 dark:border-gray-700'
            }`}
            aria-label={index < coposBebidos ? 'Copo bebido' : 'Copo não bebido'}
          >
            <Droplet
              className={`h-8 w-8 ${
                index < coposBebidos
                  ? 'text-blue-500 dark:text-blue-400'
                  : 'text-gray-400 dark:text-gray-600'
              }`}
            />
          </div>
        ))}
      </div>

      {/* Botões de ação */}
      <div className="flex justify-center space-x-4">
        <button
          onClick={adicionarCopo}
          disabled={coposBebidos >= metaDiaria}
          className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
          aria-label="Registrar um copo de água"
        >
          Registrar Copo
        </button>
        
        <button
          onClick={removerCopo}
          disabled={coposBebidos <= 0}
          className="px-4 py-2 bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 disabled:opacity-50 disabled:cursor-not-allowed"
          aria-label="Remover um copo de água"
        >
          Remover Copo
        </button>
      </div>

      {/* Dicas */}
      <div className="mt-6 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg text-sm text-blue-800 dark:text-blue-300">
        <h4 className="font-medium mb-1">Dicas de Hidratação:</h4>
        <ul className="list-disc pl-5 space-y-1">
          <li>Mantenha uma garrafa de água sempre visível</li>
          <li>Beba um copo ao acordar e antes de cada refeição</li>
          <li>Configure lembretes no celular a cada 1-2 horas</li>
        </ul>
      </div>
    </div>
  )
}
</file>

<file path="app/components/alimentacao/PlanejadorRefeicoes.tsx">
'use client'

import { useState } from 'react'
import { Clock, Plus, Save, Trash2 } from 'lucide-react'
import { useAlimentacaoStore } from '@/app/stores/alimentacaoStore'

type Refeicao = {
  id: string
  horario: string
  descricao: string
}

export function PlanejadorRefeicoes() {
  const { refeicoes, adicionarRefeicao, atualizarRefeicao, removerRefeicao } = useAlimentacaoStore()
  const [novaRefeicao, setNovaRefeicao] = useState({ horario: '', descricao: '' })
  const [editando, setEditando] = useState<string | null>(null)

  const handleAdicionarRefeicao = () => {
    if (!novaRefeicao.horario || !novaRefeicao.descricao) return

    adicionarRefeicao(novaRefeicao.horario, novaRefeicao.descricao)
    setNovaRefeicao({ horario: '', descricao: '' })
  }

  const iniciarEdicao = (id: string, horario: string, descricao: string) => {
    setEditando(id)
    setNovaRefeicao({ horario, descricao })
  }

  const salvarEdicao = () => {
    if (!editando || !novaRefeicao.horario || !novaRefeicao.descricao) return

    atualizarRefeicao(editando, novaRefeicao.horario, novaRefeicao.descricao)
    setEditando(null)
    setNovaRefeicao({ horario: '', descricao: '' })
  }

  const cancelarEdicao = () => {
    setEditando(null)
    setNovaRefeicao({ horario: '', descricao: '' })
  }

  return (
    <div className="space-y-4">
      <div className="space-y-2">
        {refeicoes.map((refeicao) => (
          <div
            key={refeicao.id}
            className="flex items-center p-3 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
          >
            <div className="flex items-center text-alimentacao-primary mr-3">
              <Clock className="h-5 w-5" />
            </div>
            
            {editando === refeicao.id ? (
              <>
                <input
                  type="time"
                  value={novaRefeicao.horario}
                  onChange={(e) => setNovaRefeicao({ ...novaRefeicao, horario: e.target.value })}
                  className="w-24 px-2 py-1 mr-2 border border-gray-300 dark:border-gray-600 rounded dark:bg-gray-700 dark:text-white"
                />
                <input
                  type="text"
                  value={novaRefeicao.descricao}
                  onChange={(e) => setNovaRefeicao({ ...novaRefeicao, descricao: e.target.value })}
                  className="flex-1 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded dark:bg-gray-700 dark:text-white"
                  placeholder="Descrição da refeição"
                />
                <button
                  onClick={salvarEdicao}
                  className="ml-2 p-1 text-green-600 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300"
                  aria-label="Salvar edição"
                >
                  <Save className="h-5 w-5" />
                </button>
                <button
                  onClick={cancelarEdicao}
                  className="ml-1 p-1 text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                  aria-label="Cancelar edição"
                >
                  <Trash2 className="h-5 w-5" />
                </button>
              </>
            ) : (
              <>
                <span className="font-medium text-gray-700 dark:text-gray-300 w-16">
                  {refeicao.horario}
                </span>
                <span className="flex-1 text-gray-900 dark:text-white">
                  {refeicao.descricao}
                </span>
                <button
                  onClick={() => iniciarEdicao(refeicao.id, refeicao.horario, refeicao.descricao)}
                  className="ml-2 p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                  aria-label="Editar refeição"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                  </svg>
                </button>
                <button
                  onClick={() => removerRefeicao(refeicao.id)}
                  className="ml-1 p-1 text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                  aria-label="Remover refeição"
                >
                  <Trash2 className="h-5 w-5" />
                </button>
              </>
            )}
          </div>
        ))}
      </div>

      <div className="mt-4 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
        <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
          Adicionar Nova Refeição
        </h3>
        <div className="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
          <input
            type="time"
            value={novaRefeicao.horario}
            onChange={(e) => setNovaRefeicao({ ...novaRefeicao, horario: e.target.value })}
            className="w-full sm:w-24 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
          />
          <input
            type="text"
            value={novaRefeicao.descricao}
            onChange={(e) => setNovaRefeicao({ ...novaRefeicao, descricao: e.target.value })}
            className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
            placeholder="Descrição da refeição"
          />
          <button
            onClick={handleAdicionarRefeicao}
            disabled={!novaRefeicao.horario || !novaRefeicao.descricao}
            className="w-full sm:w-auto px-4 py-2 bg-alimentacao-primary text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <Plus className="h-5 w-5 inline mr-1" />
            Adicionar
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/alimentacao/RegistroRefeicoes.tsx">
'use client'

import { useState } from 'react'
import { Camera, Plus, X } from 'lucide-react'
import { useAlimentacaoStore } from '@/app/stores/alimentacaoStore'

// Ícones simples para tipos de refeição
const tiposRefeicao = [
  { id: 'cafe', emoji: '☕', nome: 'Café' },
  { id: 'fruta', emoji: '🍎', nome: 'Fruta' },
  { id: 'salada', emoji: '🥗', nome: 'Salada' },
  { id: 'proteina', emoji: '🍗', nome: 'Proteína' },
  { id: 'carboidrato', emoji: '🍚', nome: 'Carboidrato' },
  { id: 'sobremesa', emoji: '🍰', nome: 'Sobremesa' },
  { id: 'agua', emoji: '💧', nome: 'Água' },
]

export function RegistroRefeicoes() {
  const { registros, adicionarRegistro, removerRegistro } = useAlimentacaoStore()
  const [novoRegistro, setNovoRegistro] = useState({
    horario: '',
    descricao: '',
    tipoIcone: null as string | null,
    foto: null as string | null,
  })
  const [mostrarForm, setMostrarForm] = useState(false)

  const handleAdicionarRegistro = () => {
    if (!novoRegistro.horario || !novoRegistro.descricao) return
    
    adicionarRegistro(
      novoRegistro.horario,
      novoRegistro.descricao,
      novoRegistro.tipoIcone,
      novoRegistro.foto
    )
    
    setNovoRegistro({
      horario: '',
      descricao: '',
      tipoIcone: null,
      foto: null,
    })
    
    setMostrarForm(false)
  }

  const selecionarTipoIcone = (tipo: string) => {
    setNovoRegistro({
      ...novoRegistro,
      tipoIcone: novoRegistro.tipoIcone === tipo ? null : tipo,
    })
  }

  // Função simplificada para simular upload de foto
  const simularUploadFoto = () => {
    // Em um app real, aqui seria integrado com a câmera ou upload
    const fotoSimulada = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2YzZjRmNiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMjAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIiBmaWxsPSIjOTQ5NDk0Ij5Gb3RvIGRhIHJlZmVpw6fDo288L3RleHQ+PC9zdmc+'
    setNovoRegistro({
      ...novoRegistro,
      foto: fotoSimulada,
    })
  }

  return (
    <div className="space-y-4">
      <div className="space-y-3">
        {registros.map((registro) => (
          <div
            key={registro.id}
            className="p-3 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
          >
            <div className="flex justify-between items-start">
              <div>
                <div className="flex items-center mb-2">
                  <span className="font-medium text-gray-700 dark:text-gray-300 mr-2">
                    {registro.horario}
                  </span>
                  <span className="text-gray-900 dark:text-white font-medium">
                    {registro.descricao}
                  </span>
                </div>
                
                {registro.tipoIcone && (
                  <div className="mb-2">
                    <span className="text-2xl" aria-label={`Tipo: ${tiposRefeicao.find(t => t.id === registro.tipoIcone)?.nome || ''}`}>
                      {tiposRefeicao.find(t => t.id === registro.tipoIcone)?.emoji}
                    </span>
                  </div>
                )}
              </div>
              
              <button
                onClick={() => removerRegistro(registro.id)}
                className="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                aria-label="Remover registro"
              >
                <X className="h-5 w-5" />
              </button>
            </div>
            
            {registro.foto && (
              <div className="mt-2">
                <img
                  src={registro.foto}
                  alt="Foto da refeição"
                  className="w-full h-32 object-cover rounded-md"
                />
              </div>
            )}
          </div>
        ))}
      </div>

      {mostrarForm ? (
        <div className="mt-4 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex justify-between items-center mb-3">
            <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Novo Registro
            </h3>
            <button
              onClick={() => setMostrarForm(false)}
              className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
              aria-label="Fechar formulário"
            >
              <X className="h-5 w-5" />
            </button>
          </div>
          
          <div className="space-y-3">
            <div className="flex flex-col sm:flex-row sm:space-x-2 space-y-2 sm:space-y-0">
              <input
                type="time"
                value={novoRegistro.horario}
                onChange={(e) => setNovoRegistro({ ...novoRegistro, horario: e.target.value })}
                className="w-full sm:w-32 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                aria-label="Horário da refeição"
              />
              <input
                type="text"
                value={novoRegistro.descricao}
                onChange={(e) => setNovoRegistro({ ...novoRegistro, descricao: e.target.value })}
                className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                placeholder="Descrição da refeição"
                aria-label="Descrição da refeição"
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Tipo de Refeição
              </label>
              <div className="flex flex-wrap gap-2">
                {tiposRefeicao.map((tipo) => (
                  <button
                    key={tipo.id}
                    onClick={() => selecionarTipoIcone(tipo.id)}
                    className={`w-10 h-10 flex items-center justify-center text-xl rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 ${
                      novoRegistro.tipoIcone === tipo.id
                        ? 'bg-alimentacao-light border-2 border-alimentacao-primary'
                        : 'bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600'
                    }`}
                    aria-label={tipo.nome}
                    aria-pressed={novoRegistro.tipoIcone === tipo.id}
                  >
                    {tipo.emoji}
                  </button>
                ))}
              </div>
            </div>
            
            <div>
              <button
                onClick={simularUploadFoto}
                className="flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                aria-label="Adicionar foto da refeição"
              >
                <Camera className="h-5 w-5 mr-2" />
                <span>Adicionar Foto</span>
              </button>
              
              {novoRegistro.foto && (
                <div className="mt-2 relative">
                  <img
                    src={novoRegistro.foto}
                    alt="Prévia da foto"
                    className="w-full h-32 object-cover rounded-md"
                  />
                  <button
                    onClick={() => setNovoRegistro({ ...novoRegistro, foto: null })}
                    className="absolute top-2 right-2 bg-red-600 text-white rounded-full p-1 hover:bg-red-700"
                    aria-label="Remover foto"
                  >
                    <X className="h-4 w-4" />
                  </button>
                </div>
              )}
            </div>
            
            <div className="flex justify-end">
              <button
                onClick={handleAdicionarRegistro}
                disabled={!novoRegistro.horario || !novoRegistro.descricao}
                className="px-4 py-2 bg-alimentacao-primary text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed"
                aria-label="Salvar registro"
              >
                Salvar Registro
              </button>
            </div>
          </div>
        </div>
      ) : (
        <button
          onClick={() => setMostrarForm(true)}
          className="w-full py-2 flex items-center justify-center bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg border border-dashed border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300"
          aria-label="Adicionar novo registro de refeição"
        >
          <Plus className="h-5 w-5 mr-1" />
          <span>Adicionar Registro</span>
        </button>
      )}
    </div>
  )
}
</file>

<file path="app/components/autoconhecimento/EditorNotas.tsx">
'use client'

import { useState, useRef, useEffect } from 'react'
import { useAutoconhecimentoStore } from '@/app/stores/autoconhecimentoStore'
import { Button } from '@/app/components/ui/Button'
import { Textarea } from '@/app/components/ui/Textarea'
import { Input } from '@/app/components/ui/Input'
import { Badge } from '@/app/components/ui/Badge'
import { X, Image as ImageIcon, Save } from 'lucide-react'

type EditorNotasProps = {
  id?: string
  secaoAtual: 'quem-sou' | 'meus-porques' | 'meus-padroes'
  onSave?: () => void
}

export function EditorNotas({ id, secaoAtual, onSave }: EditorNotasProps) {
  const { 
    notas, 
    adicionarNota, 
    atualizarNota, 
    adicionarTag, 
    removerTag,
    adicionarImagem,
    removerImagem,
    modoRefugio
  } = useAutoconhecimentoStore()
  
  const nota = id ? notas.find(n => n.id === id) : undefined
  
  const [titulo, setTitulo] = useState(nota?.titulo || '')
  const [conteudo, setConteudo] = useState(nota?.conteudo || '')
  const [tagInput, setTagInput] = useState('')
  const [tags, setTags] = useState<string[]>(nota?.tags || [])
  const [imagemUrl, setImagemUrl] = useState<string | undefined>(nota?.imagemUrl)
  const [mostrarOpcaoImagem, setMostrarOpcaoImagem] = useState(false)
  
  const tagInputRef = useRef<HTMLInputElement>(null)
  
  // Mapeia os títulos das seções para exibição
  const titulosSecoes = {
    'quem-sou': 'Quem sou',
    'meus-porques': 'Meus porquês',
    'meus-padroes': 'Meus padrões'
  }
  
  // Atualiza os estados quando a nota selecionada mudar
  useEffect(() => {
    if (nota) {
      setTitulo(nota.titulo)
      setConteudo(nota.conteudo)
      setTags(nota.tags)
      setImagemUrl(nota.imagemUrl)
    } else {
      setTitulo('')
      setConteudo('')
      setTags([])
      setImagemUrl(undefined)
    }
  }, [nota])
  
  // Função para adicionar uma tag
  const handleAdicionarTag = () => {
    if (tagInput.trim() && !tags.includes(tagInput.trim())) {
      const novaTag = tagInput.trim()
      setTags([...tags, novaTag])
      
      if (id) {
        adicionarTag(id, novaTag)
      }
      
      setTagInput('')
      tagInputRef.current?.focus()
    }
  }
  
  // Função para remover uma tag
  const handleRemoverTag = (tag: string) => {
    setTags(tags.filter(t => t !== tag))
    
    if (id) {
      removerTag(id, tag)
    }
  }
  
  // Função para adicionar/atualizar uma imagem
  const handleAdicionarImagem = () => {
    if (imagemUrl && id) {
      adicionarImagem(id, imagemUrl)
    }
    setMostrarOpcaoImagem(false)
  }
  
  // Função para remover uma imagem
  const handleRemoverImagem = () => {
    setImagemUrl(undefined)
    
    if (id) {
      removerImagem(id)
    }
    
    setMostrarOpcaoImagem(false)
  }
  
  // Função para salvar a nota
  const handleSalvar = () => {
    if (titulo.trim() && conteudo.trim()) {
      if (id) {
        // Atualizar nota existente
        atualizarNota(id, {
          titulo,
          conteudo,
          tags,
          imagemUrl
        })
      } else {
        // Criar nova nota
        adicionarNota(
          titulo,
          conteudo,
          secaoAtual,
          tags,
          imagemUrl
        )
      }
      
      if (onSave) {
        onSave()
      }
    }
  }
  
  // Verifica se estamos no modo refúgio para simplificar a interface
  const interfaceSimplificada = modoRefugio
  
  return (
    <div className={`space-y-4 transition-all duration-300 ${interfaceSimplificada ? 'opacity-90' : ''}`}>
      <div className="mb-4">
        <h3 className="text-lg font-medium text-gray-700 dark:text-gray-300 mb-1">
          {id ? `Editando nota em ${titulosSecoes[secaoAtual]}` : `Nova nota em ${titulosSecoes[secaoAtual]}`}
        </h3>
        <p className="text-sm text-gray-500 dark:text-gray-400">
          {interfaceSimplificada 
            ? 'Modo refúgio ativado - interface simplificada' 
            : 'Registre seus pensamentos, organize com tags e adicione âncoras visuais'}
        </p>
      </div>
      
      <Input
        type="text"
        value={titulo}
        onChange={(e) => setTitulo(e.target.value)}
        placeholder="Título da nota"
        className={`text-lg font-medium ${interfaceSimplificada ? 'border-autoconhecimento-primary' : ''}`}
        aria-label="Título da nota"
      />
      
      <Textarea
        value={conteudo}
        onChange={(e) => setConteudo(e.target.value)}
        placeholder="O que você quer registrar?"
        className={`min-h-[200px] ${interfaceSimplificada ? 'border-autoconhecimento-primary' : ''}`}
        aria-label="Conteúdo da nota"
      />
      
      {!interfaceSimplificada && (
        <>
          {/* Área de tags */}
          <div className="flex flex-wrap items-center gap-2">
            {tags.map((tag) => (
              <Badge 
                key={tag} 
                className="bg-autoconhecimento-light text-autoconhecimento-primary px-3 py-1 flex items-center space-x-1 hover:bg-autoconhecimento-primary hover:text-white transition-colors"
              >
                <span>{tag}</span>
                <button 
                  onClick={() => handleRemoverTag(tag)}
                  className="ml-1 rounded-full p-0.5"
                  aria-label={`Remover tag ${tag}`}
                >
                  <X size={14} />
                </button>
              </Badge>
            ))}
            
            <div className="flex">
              <Input
                ref={tagInputRef}
                type="text"
                value={tagInput}
                onChange={(e) => setTagInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault()
                    handleAdicionarTag()
                  }
                }}
                placeholder="Adicionar tag"
                className="text-sm w-32"
                aria-label="Adicionar nova tag"
              />
              <Button 
                onClick={handleAdicionarTag}
                className="ml-2 px-3 py-1 bg-autoconhecimento-light text-autoconhecimento-primary hover:bg-autoconhecimento-primary hover:text-white transition-colors"
                aria-label="Adicionar tag"
              >
                Adicionar
              </Button>
            </div>
          </div>
          
          {/* Área de imagem âncora */}
          <div className="mt-4">
            {imagemUrl ? (
              <div className="relative">
                <img 
                  src={imagemUrl} 
                  alt="Imagem âncora" 
                  className="max-h-60 object-contain rounded-md border border-autoconhecimento-light"
                />
                <button
                  onClick={handleRemoverImagem}
                  className="absolute top-2 right-2 bg-white dark:bg-gray-800 rounded-full p-1 shadow-md"
                  aria-label="Remover imagem"
                >
                  <X size={18} className="text-red-500" />
                </button>
              </div>
            ) : (
              <>
                {mostrarOpcaoImagem ? (
                  <div className="flex items-center space-x-2">
                    <Input
                      type="text"
                      value={imagemUrl || ''}
                      onChange={(e) => setImagemUrl(e.target.value)}
                      placeholder="URL da imagem âncora"
                      className="text-sm flex-1"
                      aria-label="URL da imagem âncora"
                    />
                    <Button 
                      onClick={handleAdicionarImagem}
                      className="px-3 py-1 bg-autoconhecimento-primary text-white"
                      aria-label="Adicionar imagem"
                    >
                      Adicionar
                    </Button>
                    <Button 
                      onClick={() => setMostrarOpcaoImagem(false)}
                      className="px-3 py-1 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300"
                      aria-label="Cancelar"
                    >
                      Cancelar
                    </Button>
                  </div>
                ) : (
                  <Button 
                    onClick={() => setMostrarOpcaoImagem(true)}
                    className="flex items-center px-3 py-1 bg-autoconhecimento-light text-autoconhecimento-primary hover:bg-autoconhecimento-primary hover:text-white transition-colors"
                    aria-label="Adicionar imagem âncora"
                  >
                    <ImageIcon size={16} className="mr-1" />
                    <span>Adicionar Âncora Visual</span>
                  </Button>
                )}
              </>
            )}
          </div>
        </>
      )}
      
      <div className="flex justify-end">
        <Button 
          onClick={handleSalvar}
          className={`flex items-center px-4 py-2 ${
            interfaceSimplificada 
              ? 'bg-autoconhecimento-primary text-white' 
              : 'bg-autoconhecimento-primary text-white hover:bg-autoconhecimento-hover'
          }`}
          disabled={!titulo.trim() || !conteudo.trim()}
          aria-label="Salvar nota"
        >
          <Save size={16} className="mr-1" />
          <span>Salvar</span>
        </Button>
      </div>
    </div>
  )
}
</file>

<file path="app/components/autoconhecimento/ListaNotas.tsx">
'use client'

import { useState, useMemo } from 'react'
import { useAutoconhecimentoStore } from '@/app/stores/autoconhecimentoStore'
import { Card } from '@/app/components/ui/Card'
import { Badge } from '@/app/components/ui/Badge'
import { Input } from '@/app/components/ui/Input'
import { Search, Edit, Trash2, Image as ImageIcon } from 'lucide-react'

type ListaNotasProps = {
  secaoAtual: 'quem-sou' | 'meus-porques' | 'meus-padroes'
  onSelectNota: (id: string) => void
}

export function ListaNotas({ secaoAtual, onSelectNota }: ListaNotasProps) {
  const { notas, removerNota, buscarNotas, modoRefugio } = useAutoconhecimentoStore()
  const [termoBusca, setTermoBusca] = useState('')
  
  // Filtrar notas da seção atual
  const notasSecao = useMemo(() => {
    const notasFiltradas = termoBusca 
      ? buscarNotas(termoBusca) 
      : notas
    
    return notasFiltradas
      .filter(nota => nota.secao === secaoAtual)
      .sort((a, b) => new Date(b.dataAtualizacao).getTime() - new Date(a.dataAtualizacao).getTime())
  }, [notas, secaoAtual, termoBusca, buscarNotas])
  
  // Função para lidar com a exclusão
  const handleRemoverNota = (id: string, e: React.MouseEvent) => {
    e.stopPropagation()
    
    if (window.confirm('Tem certeza que deseja excluir esta nota?')) {
      removerNota(id)
    }
  }
  
  // Formatação de data
  const formatarData = (dataString: string) => {
    const data = new Date(dataString)
    return data.toLocaleDateString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric'
    })
  }
  
  // Verifica se estamos no modo refúgio para simplificar a interface
  const interfaceSimplificada = modoRefugio
  
  return (
    <div className="space-y-4">
      {/* Barra de busca */}
      <div className="relative">
        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={16} />
        <Input
          type="text"
          placeholder="Buscar notas..."
          value={termoBusca}
          onChange={(e) => setTermoBusca(e.target.value)}
          className="pl-10"
          aria-label="Buscar notas"
        />
      </div>
      
      {/* Lista de notas */}
      <div className="space-y-3">
        {notasSecao.length === 0 ? (
          <p className="text-center text-gray-500 dark:text-gray-400 py-4">
            {termoBusca 
              ? 'Nenhuma nota encontrada para esta busca' 
              : 'Nenhuma nota registrada nesta seção ainda'}
          </p>
        ) : (
          notasSecao.map((nota) => (
            <Card
              key={nota.id}
              className={`${
                interfaceSimplificada ? 'opacity-90' : ''
              }`}
            >
              <div 
                className="p-4 cursor-pointer hover:shadow-md transition-shadow border-l-4 border-l-autoconhecimento-primary"
                onClick={() => onSelectNota(nota.id)}
              >
                <div className="flex justify-between items-start">
                  <h4 className="text-lg font-medium text-gray-800 dark:text-white line-clamp-1">
                    {nota.titulo}
                  </h4>
                  
                  <div className="flex space-x-1">
                    {!interfaceSimplificada && (
                      <>
                        <button
                          className="p-1 text-gray-500 hover:text-autoconhecimento-primary transition-colors"
                          onClick={(e) => {
                            e.stopPropagation()
                            onSelectNota(nota.id)
                          }}
                          aria-label="Editar nota"
                        >
                          <Edit size={16} />
                        </button>
                        <button
                          className="p-1 text-gray-500 hover:text-red-500 transition-colors"
                          onClick={(e) => handleRemoverNota(nota.id, e)}
                          aria-label="Excluir nota"
                        >
                          <Trash2 size={16} />
                        </button>
                      </>
                    )}
                  </div>
                </div>
                
                <p className="text-gray-600 dark:text-gray-300 text-sm mt-2 line-clamp-2">
                  {nota.conteudo}
                </p>
                
                {!interfaceSimplificada && nota.tags.length > 0 && (
                  <div className="mt-3 flex flex-wrap gap-1">
                    {nota.tags.map((tag) => (
                      <Badge 
                        key={tag}
                        className="bg-autoconhecimento-light text-autoconhecimento-primary px-2 py-0.5 text-xs"
                      >
                        {tag}
                      </Badge>
                    ))}
                  </div>
                )}
                
                <div className="mt-2 flex justify-between items-center text-xs text-gray-500 dark:text-gray-400">
                  <span>Atualizado em {formatarData(nota.dataAtualizacao)}</span>
                  {nota.imagemUrl && (
                    <span className="flex items-center">
                      <ImageIcon size={12} className="mr-1" />
                      <span>Âncora visual</span>
                    </span>
                  )}
                </div>
              </div>
            </Card>
          ))
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/components/autoconhecimento/ModoRefugio.tsx">
'use client'

import { useAutoconhecimentoStore } from '@/app/stores/autoconhecimentoStore'
import { Button } from '@/app/components/ui/Button'
import { ShieldAlert, ShieldCheck } from 'lucide-react'

export function ModoRefugio() {
  const { modoRefugio, alternarModoRefugio } = useAutoconhecimentoStore()
  
  return (
    <div className={`fixed bottom-6 right-6 z-50 ${modoRefugio ? 'scale-110' : ''} transition-all duration-300`}>
      <Button
        onClick={alternarModoRefugio}
        className={`flex items-center p-3 rounded-full shadow-lg ${
          modoRefugio 
            ? 'bg-autoconhecimento-primary text-white' 
            : 'bg-white dark:bg-gray-800 text-autoconhecimento-primary dark:text-autoconhecimento-light'
        }`}
        aria-label={modoRefugio ? 'Desativar modo refúgio' : 'Ativar modo refúgio'}
      >
        {modoRefugio ? (
          <ShieldCheck className="h-6 w-6" />
        ) : (
          <ShieldAlert className="h-6 w-6" />
        )}
      </Button>
      
      {modoRefugio && (
        <div className="absolute -top-12 right-0 bg-autoconhecimento-primary text-white px-3 py-1 rounded text-sm whitespace-nowrap">
          Modo refúgio ativado
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/components/concursos/ConcursoForm.tsx">
'use client';

import React, { useState } from 'react';
import { Button } from '@/app/components/ui/Button';
import { Input } from '@/app/components/ui/Input';
import { Modal } from '@/app/components/ui/Modal';
import { Calendar, Plus, X } from 'lucide-react';
import { useConcursosStore, type Concurso } from '@/app/stores/concursosStore';

interface ConcursoFormProps {
  isOpen: boolean;
  onClose: () => void;
  concursoParaEditar?: Concurso;
}

export function ConcursoForm({ isOpen, onClose, concursoParaEditar }: ConcursoFormProps) {
  const { adicionarConcurso, atualizarConcurso } = useConcursosStore();
  const [formData, setFormData] = useState({
    titulo: concursoParaEditar?.titulo || '',
    organizadora: concursoParaEditar?.organizadora || '',
    dataInscricao: concursoParaEditar?.dataInscricao || '',
    dataProva: concursoParaEditar?.dataProva || '',
    edital: concursoParaEditar?.edital || '',
    status: concursoParaEditar?.status || 'planejado',
    conteudoProgramatico: concursoParaEditar?.conteudoProgramatico || []
  });

  const [novaDisciplina, setNovaDisciplina] = useState('');
  const [novoTopico, setNovoTopico] = useState('');
  const [disciplinaSelecionada, setDisciplinaSelecionada] = useState('');
  const [loadingExtracao, setLoadingExtracao] = useState(false);
  const [extracaoErro, setExtracaoErro] = useState<string | null>(null);
  const [extracaoSucesso, setExtracaoSucesso] = useState<string | null>(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (concursoParaEditar) {
      atualizarConcurso(concursoParaEditar.id, formData);
    } else {
      adicionarConcurso(formData);
    }
    
    onClose();
  };

  const adicionarDisciplina = () => {
    if (!novaDisciplina.trim()) return;
    
    setFormData(prev => ({
      ...prev,
      conteudoProgramatico: [
        ...prev.conteudoProgramatico,
        {
          disciplina: novaDisciplina,
          topicos: [],
          progresso: 0
        }
      ]
    }));
    
    setNovaDisciplina('');
  };

  const adicionarTopico = () => {
    if (!novoTopico.trim() || !disciplinaSelecionada) return;
    
    setFormData(prev => ({
      ...prev,
      conteudoProgramatico: prev.conteudoProgramatico.map(d =>
        d.disciplina === disciplinaSelecionada
          ? { ...d, topicos: [...d.topicos, novoTopico] }
          : d
      )
    }));
    
    setNovoTopico('');
  };

  const removerDisciplina = (disciplina: string) => {
    setFormData(prev => ({
      ...prev,
      conteudoProgramatico: prev.conteudoProgramatico.filter(
        d => d.disciplina !== disciplina
      )
    }));
  };

  const removerTopico = (disciplina: string, topico: string) => {
    setFormData(prev => ({
      ...prev,
      conteudoProgramatico: prev.conteudoProgramatico.map(d =>
        d.disciplina === disciplina
          ? { ...d, topicos: d.topicos.filter(t => t !== topico) }
          : d
      )
    }));
  };

  return (
    <Modal
      isOpen={isOpen}
      onClose={onClose}
      title={concursoParaEditar ? "Editar Concurso" : "Novo Concurso"}
    >
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">
            Título
          </label>
          <Input
            value={formData.titulo}
            onChange={e => setFormData(prev => ({ ...prev, titulo: e.target.value }))}
            placeholder="Ex: Analista Administrativo - TRT"
            required
          />
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">
            Organizadora
          </label>
          <Input
            value={formData.organizadora}
            onChange={e => setFormData(prev => ({ ...prev, organizadora: e.target.value }))}
            placeholder="Ex: CESPE"
            required
          />
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium mb-1">
              Data de Inscrição
            </label>
            <Input
              type="date"
              value={formData.dataInscricao}
              onChange={e => setFormData(prev => ({ ...prev, dataInscricao: e.target.value }))}
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1">
              Data da Prova
            </label>
            <Input
              type="date"
              value={formData.dataProva}
              onChange={e => setFormData(prev => ({ ...prev, dataProva: e.target.value }))}
              required
            />
          </div>
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">
            Link do Edital (opcional)
          </label>
          <div className="flex gap-2 items-start">
            <Input
              type="url"
              value={formData.edital}
              onChange={e => setFormData(prev => ({ ...prev, edital: e.target.value }))}
              placeholder="https://..."
              className="flex-grow"
            />
            <Button
              type="button"
              variant="outline"
              disabled={!formData.edital || loadingExtracao}
              onClick={async () => {
                if (!formData.edital) return;
                setLoadingExtracao(true);
                setExtracaoErro(null);
                setExtracaoSucesso(null);
                try {
                  // Chamada à API de extração (simulada)
                  // const response = await fetch('/api/extrair-edital', {
                  //   method: 'POST',
                  //   headers: { 'Content-Type': 'application/json' },
                  //   body: JSON.stringify({ url: formData.edital })
                  // });
                  // if (!response.ok) {
                  //   throw new Error('Erro ao extrair dados do edital.');
                  // }
                  // const data = await response.json();

                  // Simulação de resposta da API
                  await new Promise(resolve => setTimeout(resolve, 1500)); // Simula delay
                  const data = {
                    titulo: "Concurso Extraído (Mock)",
                    organizadora: "Banca Extraída (Mock)",
                    dataInscricao: "2025-07-01",
                    dataProva: "2025-09-15",
                    // Adicionar preço, etapas, cronograma se a API retornar
                    conteudoProgramatico: [
                      { disciplina: "Conhecimentos Gerais (Extraído)", topicos: ["Atualidades", "Ética"], progresso: 0 },
                      { disciplina: "Conhecimentos Específicos (Extraído)", topicos: ["Legislação X", "Técnica Y"], progresso: 0 }
                    ]
                  };

                  // Preencher campos do formulário com os dados extraídos
                  setFormData(prev => ({
                    ...prev,
                    ...data
                  }));
                  setExtracaoSucesso('Dados extraídos com sucesso!');
                } catch (err) {
                  setExtracaoErro('Erro ao extrair dados do edital.');
                } finally {
                  setLoadingExtracao(false);
                }
              }}
              className="whitespace-nowrap"
            >
              {loadingExtracao ? 'Extraindo...' : 'Extrair dados'}
            </Button>
          </div>
          {extracaoErro && <div className="text-xs text-red-600 mt-1">{extracaoErro}</div>}
          {extracaoSucesso && <div className="text-xs text-green-600 mt-1">{extracaoSucesso}</div>}
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">
            Status
          </label>
          <select
            value={formData.status}
            onChange={e => setFormData(prev => ({ ...prev, status: e.target.value as Concurso['status'] }))}
            className="w-full border rounded-md p-2"
          >
            <option value="planejado">Planejado</option>
            <option value="inscrito">Inscrito</option>
            <option value="estudando">Estudando</option>
            <option value="realizado">Realizado</option>
            <option value="aguardando_resultado">Aguardando Resultado</option>
          </select>
        </div>

        <div className="border-t pt-4 mt-4">
          <h3 className="font-medium mb-2">Conteúdo Programático</h3>
          
          <div className="space-y-4">
            {/* Adicionar Nova Disciplina */}
            <div className="flex gap-2">
              <Input
                value={novaDisciplina}
                onChange={e => setNovaDisciplina(e.target.value)}
                placeholder="Nova disciplina..."
              />
              <Button type="button" onClick={adicionarDisciplina}>
                <Plus size={16} />
              </Button>
            </div>

            {/* Lista de Disciplinas */}
            {formData.conteudoProgramatico.map((d, i) => (
              <div key={i} className="border rounded-lg p-3">
                <div className="flex justify-between items-center mb-2">
                  <h4 className="font-medium">{d.disciplina}</h4>
                  <button
                    type="button"
                    onClick={() => removerDisciplina(d.disciplina)}
                    className="text-red-500 hover:text-red-700"
                  >
                    <X size={16} />
                  </button>
                </div>

                {/* Adicionar Novo Tópico */}
                <div className="flex gap-2 mb-2">
                  <Input
                    value={disciplinaSelecionada === d.disciplina ? novoTopico : ''}
                    onChange={e => {
                      setDisciplinaSelecionada(d.disciplina);
                      setNovoTopico(e.target.value);
                    }}
                    placeholder="Novo tópico..."
                    className="text-sm"
                  />
                  <Button
                    type="button"
                    onClick={adicionarTopico}
                    variant="outline"
                    className="p-2"
                    disabled={disciplinaSelecionada !== d.disciplina}
                  >
                    <Plus size={14} />
                  </Button>
                </div>

                {/* Lista de Tópicos */}
                <ul className="space-y-1">
                  {d.topicos.map((topico, j) => (
                    <li key={j} className="flex justify-between items-center text-sm">
                      <span>{topico}</span>
                      <button
                        type="button"
                        onClick={() => removerTopico(d.disciplina, topico)}
                        className="text-red-500 hover:text-red-700"
                      >
                        <X size={14} />
                      </button>
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        </div>

        <div className="flex justify-end gap-2 pt-4">
          <Button type="button" variant="outline" onClick={onClose}>
            Cancelar
          </Button>
          <Button type="submit">
            {concursoParaEditar ? 'Salvar Alterações' : 'Adicionar Concurso'}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
</file>

<file path="app/components/concursos/GeradorContextoLLM.tsx">
'use client';

import React, { useState } from 'react';
import { Button } from '@/app/components/ui/Button';
import { Input } from '@/app/components/ui/Input';
import { Textarea } from '@/app/components/ui/Textarea';
import { Alert } from '@/app/components/ui/Alert';
import { Card } from '@/app/components/ui/Card';
import { Download, UploadCloud, Wand2, Loader2 } from 'lucide-react';
import { useConcursosStore, Concurso } from '@/app/stores/concursosStore';

// Interface para o JSON esperado (simplificada, pode ser mais detalhada)
interface ConcursoJson {
  titulo: string;
  organizadora: string;
  dataInscricao: string; // Formato YYYY-MM-DD
  dataProva: string; // Formato YYYY-MM-DD
  edital?: string;
  status?: 'planejado' | 'inscrito' | 'estudando' | 'realizado' | 'aguardando_resultado';
  conteudoProgramatico?: { disciplina: string; topicos: string[] }[];
}

export function GeradorContextoLLM() {
  const { adicionarConcurso } = useConcursosStore();
  const [nomeConcurso, setNomeConcurso] = useState('');
  const [urlEdital, setUrlEdital] = useState('');
  const [generatedJson, setGeneratedJson] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  const handleGerarContexto = async () => {
    if (!nomeConcurso.trim() && !urlEdital.trim()) {
      setError('Por favor, informe o nome do concurso ou a URL do edital.');
      return;
    }
    setError(null);
    setSuccessMessage(null);
    setIsLoading(true);
    setGeneratedJson(''); // Limpa JSON anterior

    try {
      // --- Lógica de chamada da API LLM (Etapa 2) ---
      // const response = await fetch('/api/gerar-contexto-concurso', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify({ nome: nomeConcurso, url: urlEdital }),
      // });
      // if (!response.ok) {
      //   const errorData = await response.json();
      //   throw new Error(errorData.message || 'Falha ao gerar contexto.');
      // }
      // const data: ConcursoJson = await response.json();
      // setGeneratedJson(JSON.stringify(data, null, 2)); // Formata o JSON para exibição

      // --- Placeholder enquanto a API não existe ---
      await new Promise(resolve => setTimeout(resolve, 1500)); // Simula delay da API
      const mockData: ConcursoJson = {
        titulo: nomeConcurso || "Concurso Gerado (Mock)",
        organizadora: "Banca Exemplo",
        dataInscricao: "2025-06-01",
        dataProva: "2025-08-15",
        edital: urlEdital || undefined,
        status: "planejado",
        conteudoProgramatico: [
          { disciplina: "Português", topicos: ["Interpretação", "Gramática"] },
          { disciplina: "Matemática", topicos: ["Lógica", "Conjuntos"] }
        ]
      };
      setGeneratedJson(JSON.stringify(mockData, null, 2));
      setSuccessMessage('Contexto do concurso gerado (dados simulados).');
      // --- Fim do Placeholder ---

    } catch (err) {
      console.error("Erro ao gerar contexto:", err);
      setError(err instanceof Error ? err.message : 'Ocorreu um erro desconhecido.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleImportarJson = () => {
    setError(null);
    setSuccessMessage(null);
    if (!generatedJson) {
      setError('Nenhum JSON gerado para importar.');
      return;
    }
    try {
      const concursoData: ConcursoJson = JSON.parse(generatedJson);

      // Validação básica (pode ser mais robusta)
      if (!concursoData.titulo || !concursoData.organizadora || !concursoData.dataInscricao || !concursoData.dataProva) {
        throw new Error('JSON inválido ou faltando campos obrigatórios (título, organizadora, dataInscricao, dataProva).');
      }

      // Adaptação para o formato esperado por adicionarConcurso (Omit<Concurso, 'id'>)
      const dadosParaStore: Omit<Concurso, 'id'> = {
        titulo: concursoData.titulo,
        organizadora: concursoData.organizadora,
        dataInscricao: concursoData.dataInscricao,
        dataProva: concursoData.dataProva,
        edital: concursoData.edital,
        status: concursoData.status || 'planejado',
        // Garante que conteudoProgramatico seja um array e tenha a estrutura correta
        conteudoProgramatico: (concursoData.conteudoProgramatico || []).map(cp => ({
          disciplina: cp.disciplina || 'Não especificada',
          topicos: cp.topicos || [],
          progresso: 0 // Adiciona progresso inicial
        })),
      };

      adicionarConcurso(dadosParaStore);
      setSuccessMessage(`Concurso "${concursoData.titulo}" importado com sucesso!`);
      setGeneratedJson(''); // Limpa após importar
      setNomeConcurso('');
      setUrlEdital('');

    } catch (err) {
      console.error("Erro ao importar JSON:", err);
      setError(err instanceof Error ? err.message : 'Erro ao processar ou importar o JSON.');
    }
  };

  const handleBaixarJson = () => {
    if (!generatedJson) return;
    try {
      const data = JSON.parse(generatedJson);
      const blob = new Blob([generatedJson], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const fileName = data.titulo ? `${data.titulo.replace(/\s+/g, '_')}.json` : 'concurso.json';
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    } catch (err) {
       console.error("Erro ao baixar JSON:", err);
       setError('Erro ao formatar JSON para download.');
    }
  };

  return (
    <Card className="p-4 md:p-6">
      <h3 className="text-lg font-semibold mb-4">Gerar Contexto do Concurso (via LLM - Simulado)</h3>
      <div className="space-y-4">
        <Input
          label="Nome do Concurso (Opcional se URL for fornecida)"
          value={nomeConcurso}
          onChange={(e) => setNomeConcurso(e.target.value)}
          placeholder="Ex: Analista Judiciário - TRF"
          disabled={isLoading}
        />
        <Input
          label="URL do Edital (Opcional se Nome for fornecido)"
          value={urlEdital}
          onChange={(e) => setUrlEdital(e.target.value)}
          placeholder="https://..."
          disabled={isLoading}
        />
        <Button
          onClick={handleGerarContexto}
          disabled={isLoading || (!nomeConcurso.trim() && !urlEdital.trim())}
          className="w-full"
        >
          {isLoading ? (
            <Loader2 className="h-4 w-4 mr-2 animate-spin" />
          ) : (
            <Wand2 className="h-4 w-4 mr-2" />
          )}
          Gerar Contexto
        </Button>

        {error && <Alert variant="error">{error}</Alert>}
        {successMessage && <Alert variant="success">{successMessage}</Alert>}

        {generatedJson && (
          <div className="mt-6 space-y-3">
            <h4 className="font-medium">JSON Gerado:</h4>
            <Textarea
              value={generatedJson}
              readOnly
              rows={10}
              className="font-mono text-xs bg-gray-50 dark:bg-gray-800"
            />
            <div className="flex gap-2">
              <Button onClick={handleImportarJson} variant="default" className="flex-1">
                <UploadCloud className="h-4 w-4 mr-2" />
                Importar para o Sistema
              </Button>
              <Button onClick={handleBaixarJson} variant="outline">
                <Download className="h-4 w-4 mr-2" />
                Baixar JSON
              </Button>
            </div>
          </div>
        )}
      </div>
    </Card>
  );
}
</file>

<file path="app/components/concursos/GeradorQuestoesLLM.tsx">
'use client';

import React, { useState } from 'react';
import { Button } from '@/app/components/ui/Button';
import { Input } from '@/app/components/ui/Input';
import { Textarea } from '@/app/components/ui/Textarea';
import { Alert } from '@/app/components/ui/Alert';
import { Card } from '@/app/components/ui/Card';
import { Loader2, Wand2, UploadCloud, Search } from 'lucide-react';

// Estrutura da questão gerada pela LLM
interface QuestaoLLM {
  questao: string;
  alternativas: string[];
  correta: string; // Letra: "A", "B", "C", "D"
  disciplina: string;
  topico: string;
}

import { useQuestoesStore } from '@/app/stores/questoesStore';

interface GeradorQuestoesLLMProps {
  concursoId: string;
}

export function GeradorQuestoesLLM({ concursoId }: GeradorQuestoesLLMProps) {
  const [disciplina, setDisciplina] = useState('');
  const [topico, setTopico] = useState('');
  const [quantidade, setQuantidade] = useState(3);
  const [resumo, setResumo] = useState('');
  const [questoes, setQuestoes] = useState<QuestaoLLM[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [llmPerformance, setLlmPerformance] = useState<{ duration: number, prompt: string, rawResponse: any } | null>(null);
  const [dificuldade, setDificuldade] = useState<'facil' | 'medio' | 'dificil'>('facil');

  const { adicionarQuestoes } = useQuestoesStore();

  // Busca resumo via Perplexity MCP (simulado)
  const buscarResumo = async () => {
    setError(null);
    setSuccessMessage(null);
    setIsLoading(true);
    try {
      // Aqui seria feita a chamada real ao MCP
      // Exemplo:
      // const response = await use_mcp_tool('perplexity-search', 'search', {
      //   query: `Resumo dos principais tópicos de ${disciplina} sobre ${topico} para concursos públicos`
      // });
      // setResumo(response.data[0]?.snippet || '');

      // Simulação:
      await new Promise(resolve => setTimeout(resolve, 1200));
      setResumo(`Resumo simulado para ${disciplina} - ${topico}: principais conceitos, legislação e interpretação de textos.`);
      setSuccessMessage('Resumo obtido via MCP (simulado).');
    } catch (err) {
      setError('Erro ao buscar resumo via MCP.');
    } finally {
      setIsLoading(false);
    }
  };

  // Gera questões via API
  const gerarQuestoes = async () => {
    setError(null);
    setSuccessMessage(null);
    setIsLoading(true);
    setQuestoes([]);
    setLlmPerformance(null);
    const start = performance.now();
    let prompt = '';
    let rawResponse = null;
    try {
      // Limites de tokens por dificuldade
      const tokensPorDificuldade = {
        facil: 2000,
        medio: 5000,
        dificil: 8000,
      };
      // Instrução extra para a LLM conforme dificuldade
      let instrucaoDificuldade = '';
      if (dificuldade === 'facil') {
        instrucaoDificuldade = 'As questões devem ser diretas, sem exigir raciocínio complexo. Use até 2000 tokens.';
      } else if (dificuldade === 'medio') {
        instrucaoDificuldade = 'As questões devem exigir reflexão moderada, com enunciados mais elaborados. Use até 5000 tokens e invista mais recursos computacionais para garantir qualidade e profundidade.';
      } else if (dificuldade === 'dificil') {
        instrucaoDificuldade = 'As questões devem ser desafiadoras, exigindo análise crítica e interpretação profunda. Use até 8000 tokens e utilize o máximo de recursos computacionais para garantir questões complexas e bem fundamentadas.';
      }
      // Monta prompt para log
      prompt = `
Gere ${quantidade} questões objetivas de múltipla escolha, cada uma com 4 alternativas e apenas uma correta, no formato JSON abaixo. Use apenas o contexto fornecido.
Nível de dificuldade: ${dificuldade.toUpperCase()}. ${instrucaoDificuldade}

{
  "questao": "Enunciado da questão",
  "alternativas": [
    "Alternativa A",
    "Alternativa B",
    "Alternativa C",
    "Alternativa D"
  ],
  "correta": "Letra da alternativa correta (A, B, C ou D)",
  "disciplina": "${disciplina}",
  "topico": "${topico || ''}"
}

Contexto:
${resumo}
      `.trim();

      const response = await fetch('/api/gerar-questao', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          disciplina,
          topico,
          resumo,
          quantidade,
          dificuldade,
          max_tokens: tokensPorDificuldade[dificuldade]
        }),
      });
      rawResponse = await response.clone().json();
      if (!response.ok) {
        throw new Error(rawResponse.error || 'Erro ao gerar questões.');
      }
      setQuestoes(rawResponse.questoes || []);
      setSuccessMessage('Questões geradas com sucesso!');
      setLlmPerformance({
        duration: performance.now() - start,
        prompt,
        rawResponse
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro desconhecido ao gerar questões.');
      setLlmPerformance(null);
    } finally {
      setIsLoading(false);
    }
  };

  // Importa questões para o concurso/questoesStore
  const importarQuestoes = () => {
    setError(null);
    setSuccessMessage(null);
    if (!questoes.length) {
      setError('Nenhuma questão para importar.');
      return;
    }
    // Persiste as questões associadas ao concurso
    adicionarQuestoes(concursoId, questoes.map(q => {
      // Alternativas: transformar string[] em Alternativa[]
      const alternativas = q.alternativas.map((texto, idx) => {
        const letra = String.fromCharCode(65 + idx); // "A", "B", "C", "D"
        return {
          id: letra,
          texto,
          correta: letra === q.correta
        };
      });
      return {
        enunciado: q.questao,
        alternativas,
        respostaCorreta: q.correta,
        disciplina: q.disciplina,
        topico: q.topico
      };
    }));
    setSuccessMessage('Questões importadas para o concurso!');
  };

  return (
    <Card className="p-4 md:p-6">
      <h3 className="text-lg font-semibold mb-4">Gerar Questões Automáticas (LLM + MCP)</h3>
      <div className="space-y-4">
        <Input
          label="Disciplina"
          value={disciplina}
          onChange={e => setDisciplina(e.target.value)}
          placeholder="Ex: Português"
          disabled={isLoading}
        />
        <Input
          label="Tópico"
          value={topico}
          onChange={e => setTopico(e.target.value)}
          placeholder="Ex: Interpretação de Texto"
          disabled={isLoading}
        />
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Nível de Dificuldade</label>
          <select
            value={dificuldade}
            onChange={e => setDificuldade(e.target.value as 'facil' | 'medio' | 'dificil')}
            disabled={isLoading}
            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white text-sm mb-2"
          >
            <option value="facil">Fácil</option>
            <option value="medio">Médio</option>
            <option value="dificil">Difícil</option>
          </select>
        </div>
        <Input
          label="Quantidade de Questões"
          type="number"
          value={quantidade}
          min={1}
          max={5}
          onChange={e => setQuantidade(Math.max(1, Math.min(5, parseInt(e.target.value) || 1)))}
          disabled={isLoading}
        />
        <div className="flex gap-2 items-end">
          <Textarea
            label="Resumo/Contexto (opcional, pode ser preenchido manualmente ou via MCP)"
            value={resumo}
            onChange={e => setResumo(e.target.value)}
            rows={3}
            disabled={isLoading}
          />
          <Button onClick={buscarResumo} disabled={isLoading || !disciplina || !topico} variant="outline" size="sm">
            <Search className="h-4 w-4 mr-1" />
            Buscar Resumo (MCP)
          </Button>
        </div>
        <Button
          onClick={gerarQuestoes}
          disabled={isLoading || !disciplina || !quantidade}
          className="w-full"
        >
          {isLoading ? (
            <Loader2 className="h-4 w-4 mr-2 animate-spin" />
          ) : (
            <Wand2 className="h-4 w-4 mr-2" />
          )}
          Gerar Questões
        </Button>

        {error && <Alert variant="error">{error}</Alert>}
        {successMessage && <Alert variant="success">{successMessage}</Alert>}

        {questoes.length > 0 && (
          <div className="mt-6 space-y-3">
            <h4 className="font-medium">Questões Geradas:</h4>
            {questoes.map((q, i) => (
              <Card key={i} className="p-3 bg-gray-50 dark:bg-gray-800">
                <div className="mb-2 font-semibold">{q.questao}</div>
                <ol className="list-decimal ml-5">
                  {q.alternativas.map((alt, idx) => (
                    <li key={idx} className={q.correta === String.fromCharCode(65 + idx) ? 'font-bold text-green-700' : ''}>
                      {String.fromCharCode(65 + idx)}) {alt}
                    </li>
                  ))}
                </ol>
                <div className="mt-2 text-xs text-gray-500">
                  Disciplina: {q.disciplina} | Tópico: {q.topico}
                </div>
              </Card>
            ))}
            <Button onClick={importarQuestoes} variant="default" className="w-full mt-2">
              <UploadCloud className="h-4 w-4 mr-2" />
              Importar para Concurso
            </Button>
            {llmPerformance && (
              <div className="mt-4 text-xs text-gray-500">
                <div><b>Tempo de resposta LLM:</b> {llmPerformance.duration.toFixed(0)}ms</div>
                <details>
                  <summary className="cursor-pointer">Prompt usado</summary>
                  <pre className="whitespace-pre-wrap">{llmPerformance.prompt}</pre>
                </details>
                <details>
                  <summary className="cursor-pointer">Resposta bruta da LLM</summary>
                  <pre className="whitespace-pre-wrap">{JSON.stringify(llmPerformance.rawResponse, null, 2)}</pre>
                </details>
              </div>
            )}
          </div>
        )}
      </div>
    </Card>
  );
}
</file>

<file path="app/components/concursos/ImportarConcursoJsonModal.tsx">
import React, { useState } from "react";
import { Modal } from "../ui/Modal";
import { Input } from "../ui/Input";
import { Button } from "../ui/Button";

interface ImportarConcursoJsonModalProps {
  isOpen: boolean;
  onClose: () => void;
  onImport: (concurso: any) => void;
}

const TEMPLATE = `{
  "titulo": "",
  "organizadora": "",
  "dataInscricao": "",
  "dataProva": "",
  "linkEdital": "",
  "conteudoProgramatico": [
    {
      "disciplina": "",
      "topicos": ["", ""]
    }
  ]
}`;

function validarConcursoJson(json: any): string | null {
  if (typeof json !== "object" || !json) return "JSON inválido.";
  if (!json.titulo || !json.organizadora || !json.dataInscricao || !json.dataProva) return "Campos obrigatórios ausentes.";
  if (!Array.isArray(json.conteudoProgramatico) || json.conteudoProgramatico.length === 0) return "Conteúdo programático ausente.";
  for (const d of json.conteudoProgramatico) {
    if (!d.disciplina || !Array.isArray(d.topicos)) return "Disciplina ou tópicos inválidos.";
  }
  return null;
}

export function ImportarConcursoJsonModal({ isOpen, onClose, onImport }: ImportarConcursoJsonModalProps) {
  const [jsonText, setJsonText] = useState("");
  const [erro, setErro] = useState<string | null>(null);
  const [sucesso, setSucesso] = useState<string | null>(null);

  function parseDateBRtoISO(dateStr: string): string | null {
    // Aceita "dd/MM/yyyy" ou "dd/MM/yyyy a dd/MM/yyyy"
    if (!dateStr) return null;
    const match = dateStr.match(/^(\d{2})\/(\d{2})\/(\d{4})/);
    if (!match) return null;
    const [_, d, m, y] = match;
    return `${y}-${m}-${d}`;
  }

  const handleImport = () => {
    setErro(null);
    setSucesso(null);
    let parsed;
    try {
      parsed = JSON.parse(jsonText);
    } catch {
      setErro("JSON mal formatado.");
      return;
    }
    const valid = validarConcursoJson(parsed);
    if (valid) {
      setErro(valid);
      return;
    }
    // Corrigir datas para formato ISO
    const dataProvaISO = parseDateBRtoISO(parsed.dataProva);
    if (!dataProvaISO) {
      setErro("Data da prova inválida. Use formato dd/MM/yyyy.");
      return;
    }
    let dataInscricaoISO = parseDateBRtoISO(parsed.dataInscricao);
    if (!dataInscricaoISO) {
      // Tentar extrair data inicial de intervalo
      const partes = parsed.dataInscricao.split(" a ");
      dataInscricaoISO = parseDateBRtoISO(partes[0]);
      if (!dataInscricaoISO) {
        setErro("Data de inscrição inválida. Use formato dd/MM/yyyy ou intervalo.");
        return;
      }
    }
    const concursoCorrigido = {
      ...parsed,
      dataProva: dataProvaISO,
      dataInscricao: dataInscricaoISO,
    };
    setSucesso("Concurso importado com sucesso!");
    onImport(concursoCorrigido);
    setTimeout(() => {
      setSucesso(null);
      onClose();
    }, 1000);
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Importar JSON do Edital">
      <div className="space-y-3">
        <p>Cole abaixo o JSON extraído da LLM externa (Claude, ChatGPT, etc.).</p>
        <textarea
          className="w-full border rounded p-2 font-mono text-sm"
          rows={10}
          value={jsonText}
          onChange={e => setJsonText(e.target.value)}
          placeholder={TEMPLATE}
        />
        <div>
          <Button onClick={handleImport}>Importar</Button>
          <Button variant="outline" onClick={onClose} className="ml-2">Cancelar</Button>
        </div>
        {erro && <div className="text-red-600 text-sm">{erro}</div>}
        {sucesso && <div className="text-green-600 text-sm">{sucesso}</div>}
        <details className="mt-2">
          <summary className="cursor-pointer text-xs text-gray-500">Ver template de exemplo</summary>
          <pre className="bg-gray-100 p-2 rounded text-xs">{TEMPLATE}</pre>
        </details>
      </div>
    </Modal>
  );
}
</file>

<file path="app/components/concursos/QuestaoCard.tsx">
'use client';

import React, { useState } from 'react';
import { Questao, Alternativa } from '@/app/stores/questoesStore';
import { Card } from '@/app/components/ui/Card';
import { Button } from '@/app/components/ui/Button';
// Remover importações de componentes inexistentes
// import { RadioGroup, RadioGroupItem } from "@/app/components/ui/radio-group";
// import { Label } from "@/app/components/ui/label";
import { CheckCircle, XCircle, HelpCircle, EyeOff } from 'lucide-react';

interface QuestaoCardProps {
  questao: Questao;
  modo: 'estudo' | 'simulado' | 'revisao'; // Modos diferentes podem ter UIs ligeiramente diferentes
  onResponder?: (questaoId: string, respostaUsuario: string, acertou: boolean) => void;
  numeroQuestao?: number; // Opcional, para exibir numeração
}

// Mapeamento de cores para disciplinas (exemplo, pode ser configurável)
const coresDisciplinas: { [key: string]: string } = {
  'Português': 'bg-blue-100 border-blue-300',
  'Matemática': 'bg-green-100 border-green-300',
  'Direito Administrativo': 'bg-yellow-100 border-yellow-300',
  'Direito Constitucional': 'bg-purple-100 border-purple-300',
  'Informática': 'bg-red-100 border-red-300',
  'default': 'bg-gray-100 border-gray-300',
};

export function QuestaoCard({ questao, modo, onResponder, numeroQuestao }: QuestaoCardProps) {
  const [respostaSelecionada, setRespostaSelecionada] = useState<string | undefined>(
    modo === 'revisao' ? questao.respostaUsuario : undefined
  );
  const [mostrarJustificativa, setMostrarJustificativa] = useState(modo === 'revisao');
  const [interfaceSimplificada, setInterfaceSimplificada] = useState(false);
  const [mostrarDica, setMostrarDica] = useState(false); // Para sistema progressivo de dicas

  const handleResposta = (valor: string) => {
    if (modo === 'revisao') return; // Não permite mudar resposta na revisão
    setRespostaSelecionada(valor);
    if (modo === 'simulado' && onResponder) {
      const acertou = valor === questao.respostaCorreta;
      onResponder(questao.id, valor, acertou);
      // Em modo simulado, geralmente não mostra a resposta imediatamente
    }
    if (modo === 'estudo') {
      setMostrarJustificativa(true); // Mostra justificativa ao responder em modo estudo
    }
  };

  const getCorDisciplina = (disciplina: string) => {
    return coresDisciplinas[disciplina] || coresDisciplinas['default'];
  };

  const getStatusAlternativa = (alt: Alternativa): 'correta' | 'incorreta' | 'neutra' => {
    if (modo !== 'revisao' && !mostrarJustificativa) return 'neutra';
    if (alt.correta) return 'correta';
    if (respostaSelecionada === alt.id && !alt.correta) return 'incorreta';
    return 'neutra';
  };

  const corBorda = getCorDisciplina(questao.disciplina);

  return (
    <Card className={`transition-all hover:shadow-md border-l-4 ${corBorda} ${interfaceSimplificada ? 'p-2' : 'p-4'}`}>
      <div className={` ${interfaceSimplificada ? 'space-y-1' : 'space-y-3'}`}>
        {/* Cabeçalho da Questão */}
        <div className="flex justify-between items-start text-xs text-gray-500">
          <div>
            {numeroQuestao && <span className="font-bold mr-2">Questão {numeroQuestao}</span>}
            <span>{questao.disciplina} {questao.topico ? `> ${questao.topico}` : ''}</span>
            {questao.banca && ` (${questao.banca}${questao.ano ? `, ${questao.ano}` : ''})`}
          </div>
          {/* Botões de controle da interface */}
          <div className="flex gap-2">
            {questao.justificativa && (
              <Button variant="ghost" size="sm" onClick={() => setMostrarDica(!mostrarDica)} title="Mostrar Dica/Justificativa">
                <HelpCircle size={14} />
              </Button>
            )}
            <Button variant="ghost" size="sm" onClick={() => setInterfaceSimplificada(!interfaceSimplificada)} title={interfaceSimplificada ? "Mostrar Interface Completa" : "Simplificar Interface"}>
              <EyeOff size={14} />
            </Button>
          </div>
        </div>

        {/* Enunciado */}
        <p className={`font-medium ${interfaceSimplificada ? 'text-sm' : 'text-base'}`}>{questao.enunciado}</p>

        {/* Alternativas (usando HTML padrão) */}
        <div className="space-y-2">
          {questao.alternativas.map((alt) => {
            const status = getStatusAlternativa(alt);
            let statusClasses = '';
            if (status === 'correta') statusClasses = 'text-green-700 font-semibold';
            if (status === 'incorreta') statusClasses = 'text-red-700 line-through';
            const inputId = `q-${questao.id}-alt-${alt.id}`;

            return (
              <div
                key={alt.id}
                className={`flex items-center space-x-3 p-2 rounded border ${
                  status === 'correta' ? 'bg-green-50 border-green-200' : ''
                } ${
                  status === 'incorreta' ? 'bg-red-50 border-red-200' : ''
                } ${
                  status === 'neutra' ? 'border-transparent hover:bg-gray-50' : ''
                }`}
              >
                <input
                  type="radio"
                  id={inputId}
                  name={`questao-${questao.id}`} // Agrupa os radios da mesma questão
                  value={alt.id}
                  checked={respostaSelecionada === alt.id}
                  onChange={(e) => handleResposta(e.target.value)}
                  disabled={modo === 'revisao'}
                  className="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300"
                />
                <label htmlFor={inputId} className={`flex-1 cursor-pointer ${statusClasses}`}>
                  {alt.texto}
                </label>
                {status === 'correta' && <CheckCircle size={16} className="text-green-600 flex-shrink-0" />}
                {status === 'incorreta' && <XCircle size={16} className="text-red-600 flex-shrink-0" />}
              </div>
            );
          })}
        </div>

        {/* Justificativa / Dica */}
        {(mostrarJustificativa || (mostrarDica && questao.justificativa)) && (
          <div className={`mt-3 pt-3 border-t text-sm ${interfaceSimplificada ? 'p-1 bg-gray-50 rounded' : 'p-3 bg-gray-50 rounded'}`}>
            <p className="font-semibold mb-1">Justificativa:</p>
            <p className="text-gray-700">{questao.justificativa || 'Sem justificativa cadastrada.'}</p>
          </div>
        )}

        {/* Botão de confirmação (opcional, mais útil em modo estudo) */}
        {modo === 'estudo' && !mostrarJustificativa && respostaSelecionada && (
          <div className="flex justify-end mt-3">
            <Button size="sm" onClick={() => setMostrarJustificativa(true)}>Confirmar Resposta</Button>
          </div>
        )}
      </div>
    </Card>
  );
}
</file>

<file path="app/components/concursos/QuestaoForm.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useQuestoesStore, Questao, Alternativa } from '@/app/stores/questoesStore';
import { Modal } from '@/app/components/ui/Modal';
import { Button } from '@/app/components/ui/Button';
import { Input } from '@/app/components/ui/Input';
import { Textarea } from '@/app/components/ui/Textarea';
import { Select } from '@/app/components/ui/Select';
import { Checkbox } from '@/app/components/ui/Checkbox';
import { PlusCircle, Trash2 } from 'lucide-react';

interface QuestaoFormProps {
  isOpen: boolean;
  onClose: () => void;
  concursoId: string; // Para associar a questão ao concurso correto
  questaoParaEditar?: Questao | null;
}

const niveisDificuldade = [
  { value: 'facil', label: 'Fácil' },
  { value: 'medio', label: 'Médio' },
  { value: 'dificil', label: 'Difícil' },
];

export function QuestaoForm({ isOpen, onClose, concursoId, questaoParaEditar }: QuestaoFormProps) {
  const { adicionarQuestao, atualizarQuestao } = useQuestoesStore();

  // Estado inicial do formulário
  const initialState = {
    disciplina: '',
    topico: '',
    enunciado: '',
    alternativas: [{ id: crypto.randomUUID(), texto: '', correta: false }],
    justificativa: '',
    nivelDificuldade: 'medio',
    ano: new Date().getFullYear(),
    banca: '',
    tags: '', // Usar string separada por vírgula para simplicidade no input
  };

  const [formData, setFormData] = useState(initialState);
  const [respostaCorretaId, setRespostaCorretaId] = useState<string | null>(null);

  useEffect(() => {
    if (questaoParaEditar) {
      // Preenche o formulário com dados da questão para edição
      setFormData({
        disciplina: questaoParaEditar.disciplina,
        topico: questaoParaEditar.topico,
        enunciado: questaoParaEditar.enunciado,
        alternativas: questaoParaEditar.alternativas.map(a => ({ ...a })), // Cria cópias
        justificativa: questaoParaEditar.justificativa || '',
        nivelDificuldade: questaoParaEditar.nivelDificuldade || 'medio',
        ano: questaoParaEditar.ano || new Date().getFullYear(),
        banca: questaoParaEditar.banca || '',
        tags: questaoParaEditar.tags?.join(', ') || '',
      });
      setRespostaCorretaId(questaoParaEditar.respostaCorreta);
    } else {
      // Reseta para o estado inicial ao abrir para adicionar nova questão
      setFormData(initialState);
      setRespostaCorretaId(null);
    }
  }, [questaoParaEditar, isOpen]); // Depende de isOpen para resetar ao reabrir

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleAlternativaChange = (id: string, texto: string) => {
    setFormData(prev => ({
      ...prev,
      alternativas: prev.alternativas.map(alt =>
        alt.id === id ? { ...alt, texto } : alt
      ),
    }));
  };

  const handleRespostaCorretaChange = (id: string) => {
    setRespostaCorretaId(id);
    setFormData(prev => ({
      ...prev,
      alternativas: prev.alternativas.map(alt => ({
        ...alt,
        correta: alt.id === id,
      })),
    }));
  };

  const adicionarAlternativa = () => {
    setFormData(prev => ({
      ...prev,
      alternativas: [...prev.alternativas, { id: crypto.randomUUID(), texto: '', correta: false }],
    }));
  };

  const removerAlternativa = (id: string) => {
    setFormData(prev => ({
      ...prev,
      alternativas: prev.alternativas.filter(alt => alt.id !== id),
    }));
    // Se remover a correta, desmarca
    if (respostaCorretaId === id) {
      setRespostaCorretaId(null);
    }
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (!respostaCorretaId) {
      alert('Por favor, marque uma alternativa como correta.');
      return;
    }

    // Garante que nivelDificuldade tenha o tipo correto
    const nivelDificuldadeTyped = formData.nivelDificuldade as 'facil' | 'medio' | 'dificil' | undefined;

    const questaoData = {
      ...formData,
      concursoId: concursoId,
      ano: Number(formData.ano) || undefined,
      tags: formData.tags.split(',').map(tag => tag.trim()).filter(tag => tag), // Converte string para array
      respostaCorreta: respostaCorretaId,
      alternativas: formData.alternativas, // Já está no formato correto
      nivelDificuldade: nivelDificuldadeTyped, // Usa o valor com tipo corrigido
    };

    // Remove o ID ao adicionar uma nova questão, pois ele é gerado pelo store
    const questaoParaAdicionar = { ...questaoData };
    // delete questaoParaAdicionar.id; // O tipo Omit já faz isso implicitamente

    try {
      if (questaoParaEditar) {
        // Passa o ID da questão a ser editada e os dados atualizados
        // questaoData já contém os dados formatados corretamente (sem ID no objeto principal)
        atualizarQuestao(questaoParaEditar.id, questaoData);
      } else {
        // Passa os dados sem o ID para adicionar
        // questaoParaAdicionar já está formatado corretamente
        adicionarQuestao(questaoParaAdicionar);
      }
      onClose(); // Fecha o modal após sucesso
    } catch (error) {
      console.error("Erro ao salvar questão:", error);
      alert(`Erro ao salvar questão: ${error instanceof Error ? error.message : String(error)}`);
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={questaoParaEditar ? 'Editar Questão' : 'Adicionar Nova Questão'}>
      <form onSubmit={handleSubmit} className="space-y-4">
        <Input
          label="Disciplina"
          name="disciplina"
          value={formData.disciplina}
          onChange={handleChange}
          required
        />
        <Input
          label="Tópico (Opcional)"
          name="topico"
          value={formData.topico}
          onChange={handleChange}
        />
        <Textarea
          label="Enunciado"
          name="enunciado"
          value={formData.enunciado}
          onChange={handleChange}
          required
          rows={4}
        />

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">Alternativas</label>
          <div className="space-y-2">
            {formData.alternativas.map((alt, index) => (
              <div key={alt.id} className="flex items-center gap-2">
                {/* Assume que a prop de mudança é 'onChange' ou similar, não 'onCheckedChange' */}
                {/* O componente Checkbox provavelmente passa o novo estado (boolean) ou um evento */}
                <Checkbox
                  id={`correta-${alt.id}`}
                  checked={respostaCorretaId === alt.id}
                  // Tentativa com onChange. Se falhar, verificar ui/Checkbox.tsx
                  onChange={() => handleRespostaCorretaChange(alt.id)}
                />
                <Input
                  placeholder={`Alternativa ${index + 1}`}
                  value={alt.texto}
                  onChange={(e) => handleAlternativaChange(alt.id, e.target.value)}
                  required
                  className="flex-grow"
                />
                {formData.alternativas.length > 1 && (
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={() => removerAlternativa(alt.id)}
                    className="text-red-500 hover:text-red-700"
                  >
                    <Trash2 size={16} />
                  </Button>
                )}
              </div>
            ))}
          </div>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={adicionarAlternativa}
            className="mt-2"
          >
            <PlusCircle size={16} className="mr-2" />
            Adicionar Alternativa
          </Button>
        </div>

        <Textarea
          label="Justificativa (Opcional)"
          name="justificativa"
          value={formData.justificativa}
          onChange={handleChange}
          rows={3}
        />

        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <Select
            label="Nível de Dificuldade"
            name="nivelDificuldade"
            value={formData.nivelDificuldade}
            onChange={handleChange}
            options={niveisDificuldade}
          />
          <Input
            label="Ano (Opcional)"
            name="ano"
            type="number"
            value={formData.ano}
            onChange={handleChange}
            placeholder="Ex: 2023"
          />
          <Input
            label="Banca (Opcional)"
            name="banca"
            value={formData.banca}
            onChange={handleChange}
          />
        </div>

        <Input
          label="Tags (separadas por vírgula, opcional)"
          name="tags"
          value={formData.tags}
          onChange={handleChange}
          placeholder="Ex: Direito Administrativo, Licitações, Lei 8666"
        />

        <div className="flex justify-end gap-2 pt-4">
          <Button type="button" variant="outline" onClick={onClose}>
            Cancelar
          </Button>
          <Button type="submit">
            {questaoParaEditar ? 'Salvar Alterações' : 'Adicionar Questão'}
          </Button>
        </div>
      </form>
    </Modal>
  );
}
</file>

<file path="app/components/concursos/QuestaoList.tsx">
'use client';

import React, { useState } from 'react';
import { useQuestoesStore, Questao } from '@/app/stores/questoesStore';
import { Card } from '@/app/components/ui/Card';
import { Button } from '@/app/components/ui/Button';
import { Edit, Trash, Plus, PlayCircle } from 'lucide-react';
import { Checkbox } from '@/app/components/ui/Checkbox';
import { useRouter } from 'next/navigation';

interface QuestaoListProps {
  concursoId: string;
  onAddQuestao: () => void;
  onEditQuestao: (questao: Questao) => void;
}

export function QuestaoList({ concursoId, onAddQuestao, onEditQuestao }: QuestaoListProps) {
  const { questoes, removerQuestao } = useQuestoesStore((state) => ({
    questoes: state.questoes.filter(q => q.concursoId === concursoId),
    removerQuestao: state.removerQuestao,
  }));

  // Agrupa questões por disciplina
  const disciplinas = Array.from(new Set(questoes.map(q => q.disciplina)));
  const [abaAtiva, setAbaAtiva] = useState(disciplinas[0] || '');
  const [selecionadas, setSelecionadas] = useState<string[]>([]);
  const router = useRouter();

  const handleRemover = (id: string) => {
    if (confirm('Tem certeza que deseja remover esta questão?')) {
      removerQuestao(id);
      setSelecionadas(selecionadas.filter(qid => qid !== id));
    }
  };

  const handleSelecionar = (id: string, checked: boolean) => {
    setSelecionadas((prev) =>
      checked ? [...prev, id] : prev.filter(qid => qid !== id)
    );
  };

  const handleSelecionarTodas = (checked: boolean) => {
    const idsDaAba = questoes.filter(q => q.disciplina === abaAtiva).map(q => q.id);
    setSelecionadas((prev) =>
      checked
        ? Array.from(new Set([...prev, ...idsDaAba]))
        : prev.filter(qid => !idsDaAba.includes(qid))
    );
  };

  const handleRealizarSimulado = () => {
    // Salva as questões selecionadas no localStorage para a página de simulado buscar
    const questoesSelecionadas = questoes.filter(q => selecionadas.includes(q.id));
    localStorage.setItem('simulado_personalizado_questoes', JSON.stringify(questoesSelecionadas));
    router.push('/estudos/simulado-personalizado');
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-lg font-semibold">Questões do Concurso</h2>
        <div className="flex gap-2">
          <Button
            onClick={handleRealizarSimulado}
            size="sm"
            variant="success"
            disabled={selecionadas.length === 0}
            className="flex items-center"
          >
            <PlayCircle size={16} className="mr-2" />
            Realizar Simulado
          </Button>
          <Button onClick={onAddQuestao} size="sm">
            <Plus size={16} className="mr-2" />
            Adicionar Questão
          </Button>
        </div>
      </div>

      {/* Abas de disciplinas */}
      <div className="flex gap-2 mb-4">
        {disciplinas.map((disciplina) => (
          <button
            key={disciplina}
            className={`px-4 py-2 rounded-t ${abaAtiva === disciplina ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`}
            onClick={() => setAbaAtiva(disciplina)}
          >
            {disciplina}
          </button>
        ))}
      </div>

      {/* Lista de questões da aba ativa */}
      {questoes.filter(q => q.disciplina === abaAtiva).length > 0 ? (
        <div className="space-y-3">
          <div className="flex items-center mb-2">
            <Checkbox
              checked={
                questoes.filter(q => q.disciplina === abaAtiva).every(q => selecionadas.includes(q.id))
              }
              onChange={e => handleSelecionarTodas(e.target.checked)}
              label="Selecionar todas"
            />
          </div>
          {questoes
            .filter(q => q.disciplina === abaAtiva)
            .map((questao) => (
              <Card key={questao.id} className="p-4">
                <div className="flex justify-between items-start">
                  <div className="flex items-start gap-3">
                    <Checkbox
                      checked={selecionadas.includes(questao.id)}
                      onChange={e => handleSelecionar(questao.id, e.target.checked)}
                    />
                    <div>
                      <p className="text-sm text-gray-500 mb-1">
                        {questao.disciplina} {questao.topico ? `> ${questao.topico}` : ''}
                        {questao.banca && ` (${questao.banca}${questao.ano ? `, ${questao.ano}` : ''})`}
                      </p>
                      <p className="font-medium">{questao.enunciado}</p>
                    </div>
                  </div>
                  <div className="flex gap-2 flex-shrink-0 ml-4">
                    <Button variant="outline" size="icon" onClick={() => onEditQuestao(questao)}>
                      <Edit size={16} />
                    </Button>
                    <Button variant="destructive" size="icon" onClick={() => handleRemover(questao.id)}>
                      <Trash size={16} />
                    </Button>
                  </div>
                </div>
              </Card>
            ))}
        </div>
      ) : (
        <div className="text-center py-8 border rounded-lg bg-gray-50">
          <p className="text-gray-500 mb-3">Nenhuma questão cadastrada para esta disciplina ainda.</p>
          <Button variant="outline" onClick={onAddQuestao}>
            <Plus size={16} className="mr-2" />
            Adicionar a primeira questão
          </Button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/components/estudos/simulado/HistoricoModal.tsx">
'use client';

import React, { useMemo } from 'react';
import { Modal } from '@/app/components/ui/Modal';
import { Button } from '@/app/components/ui/Button';
import { useHistoricoSimuladosStore } from '@/app/stores/historicoSimuladosStore';
import { useSimuladoStore } from '@/app/stores/simuladoStore'; // Para resetar ao clicar em Refazer
import { Badge } from '@/app/components/ui/Badge'; // Para exibir pontuações
import { RefreshCw } from 'lucide-react'; // Ícone para Refazer

interface HistoricoModalProps {
  isOpen: boolean;
  onClose: () => void;
}

const HistoricoModal: React.FC<HistoricoModalProps> = ({ isOpen, onClose }) => {
  const { historico } = useHistoricoSimuladosStore();
  const { resetSimulado } = useSimuladoStore(); // Pegar a função de reset

  // Calcula estatísticas (melhor/última) para cada simulado no histórico
  const historicoProcessado = useMemo(() => {
    return Object.entries(historico)
      .map(([identificador, entry]) => {
        if (!entry || entry.tentativas.length === 0) {
          return null; // Ignora entradas inválidas
        }
        const ultimaTentativa = entry.tentativas[entry.tentativas.length - 1];
        const melhorPercentual = Math.max(...entry.tentativas.map(t => t.percentual));
        return {
          identificador,
          titulo: entry.titulo,
          totalQuestoes: entry.totalQuestoes,
          ultimaPercentual: ultimaTentativa.percentual,
          ultimaTimestamp: ultimaTentativa.timestamp,
          melhorPercentual: melhorPercentual,
          numeroTentativas: entry.tentativas.length,
        };
      })
      .filter(item => item !== null) // Remove nulos
      // Ordena por data da última tentativa, mais recente primeiro
      .sort((a, b) => new Date(b!.ultimaTimestamp).getTime() - new Date(a!.ultimaTimestamp).getTime());
  }, [historico]);

  const handleRefazer = () => {
    resetSimulado(); // Reseta o estado do simulado atual
    onClose(); // Fecha o modal
    // O usuário precisará carregar o JSON manualmente
    // Poderíamos mostrar um toast/alerta aqui para instruir o usuário, mas vamos manter simples por ora.
  };

  // Formata data para exibição
  const formatarData = (dataIso: string | null): string => {
    if (!dataIso) return 'N/A';
    try {
      return new Date(dataIso).toLocaleDateString('pt-BR', {
        day: '2-digit', month: 'short', year: 'numeric'
      });
    } catch {
      return 'Data inválida';
    }
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Histórico de Simulados">
      <div className="max-h-[60vh] overflow-y-auto space-y-4 p-1"> {/* Altura máxima e scroll */}
        {historicoProcessado.length === 0 ? (
          <p className="text-center text-muted-foreground py-4">Nenhum simulado no histórico ainda.</p>
        ) : (
          historicoProcessado.map((item) => (
            <div key={item!.identificador} className="p-4 border rounded-md bg-background flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3">
              <div className="flex-grow">
                <h4 className="font-semibold">{item!.titulo}</h4>
                <p className="text-sm text-muted-foreground">
                  {item!.totalQuestoes} questões | {item!.numeroTentativas} tentativa(s) | Última em: {formatarData(item!.ultimaTimestamp)}
                </p>
                <div className="flex gap-2 mt-2 flex-wrap">
                  <Badge variant="secondary">Última: {item!.ultimaPercentual.toFixed(1)}%</Badge>
                  <Badge variant="default">Melhor: {item!.melhorPercentual.toFixed(1)}%</Badge>
                </div>
              </div>
              <Button onClick={handleRefazer} variant="ghost" size="sm" className="mt-2 sm:mt-0 flex-shrink-0">
                <RefreshCw className="mr-1 h-4 w-4" /> Refazer
              </Button>
            </div>
          ))
        )}
      </div>
    </Modal>
  );
};

export default HistoricoModal;
</file>

<file path="app/components/estudos/simulado/SimuladoLoader.tsx">
'use client';

import React, { useState, useCallback, useRef, useEffect } from 'react'; // Adicionar useEffect
import { useSimuladoStore, SimuladoData } from '@/app/stores/simuladoStore';
import { useConcursosStore } from '@/app/stores/concursosStore'; // Importar store de concursos
import { useQuestoesStore } from '@/app/stores/questoesStore'; // Importar store de questões
import { Button } from '@/app/components/ui/Button';
import { Input } from '@/app/components/ui/Input';
import { Textarea } from '@/app/components/ui/Textarea';
import { Alert } from '@/app/components/ui/Alert';
import { Select } from '@/app/components/ui/Select'; // Importar Select
import { Upload, ClipboardPaste, PlayCircle } from 'lucide-react'; // Importar ícones

const SimuladoLoader: React.FC = () => {
  const { loadSimulado, setStatus } = useSimuladoStore();
  const { concursos } = useConcursosStore(); // Obter lista de concursos
  const { buscarQuestoesPorConcurso } = useQuestoesStore(); // Obter função de busca
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [jsonText, setJsonText] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Estados para geração de simulado
  const [selectedConcursoId, setSelectedConcursoId] = useState<string>('');
  const [numQuestoes, setNumQuestoes] = useState<number>(10); // Default 10 questões
  const [concursoOptions, setConcursoOptions] = useState<{ value: string; label: string }[]>([]);

  // Popula as opções do select de concursos quando a lista de concursos mudar
  useEffect(() => {
    const options = concursos.map(c => ({ value: c.id, label: c.titulo }));
    setConcursoOptions(options);
    // Se havia um concurso selecionado que não existe mais, limpa a seleção
    if (selectedConcursoId && !options.some(opt => opt.value === selectedConcursoId)) {
      setSelectedConcursoId('');
    }
  }, [concursos, selectedConcursoId]);

  // Função genérica para processar os dados JSON (seja de arquivo ou texto)
  const processJsonData = (jsonData: string) => {
    try {
      const data: SimuladoData = JSON.parse(jsonData);

      // Validação básica da estrutura do JSON (pode ser mais robusta)
      if (!data.metadata || !data.questoes || !Array.isArray(data.questoes)) {
        throw new Error('Estrutura do JSON inválida. Verifique o formato do arquivo/texto.');
      }
      if (data.questoes.length === 0) {
        throw new Error('O JSON não contém questões.');
      }
      // Validação mais profunda das questões pode ser adicionada aqui

      loadSimulado(data); // Carrega os dados no store (que mudará o status para 'reviewing')
    } catch (err) {
      console.error('Erro ao processar o JSON:', err);
      setError(err instanceof Error ? err.message : 'Erro desconhecido ao processar o JSON.');
      setStatus('idle'); // Volta para o estado inicial em caso de erro
      setIsLoading(false); // Garante que o loading pare em caso de erro
    }
    // O finally que estava aqui foi movido para os handlers específicos
  };


  const handleFileChange = useCallback(
    (event: React.ChangeEvent<HTMLInputElement>) => {
      const file = event.target.files?.[0];
      if (!file) {
        setError('Nenhum arquivo selecionado.');
        return;
      }

      if (file.type !== 'application/json') {
        setError('Formato de arquivo inválido. Por favor, selecione um arquivo .json.');
        return;
      }

      setError(null);
      setIsLoading(true);
      setStatus('loading');

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result;
        if (typeof text === 'string') {
          processJsonData(text); // Chama a função genérica
        } else {
          setError('Falha ao ler o conteúdo do arquivo.');
          setStatus('idle');
        }
        // O setIsLoading(false) agora é chamado dentro de processJsonData em caso de sucesso/erro
      };
      reader.onerror = () => {
        // O setIsLoading(false) é chamado aqui também
        setError('Erro ao ler o arquivo.');
        setIsLoading(false); // Adicionado aqui
        setStatus('idle');
      };
      reader.readAsText(file);
    },
    [loadSimulado, setStatus, processJsonData] // Adicionar processJsonData às dependências
  );

  // Handler para carregar do texto da textarea
  const handleLoadFromText = () => {
    if (!jsonText.trim()) {
      setError('A caixa de texto está vazia.');
      return;
    }
    setError(null);
    setIsLoading(true);
    setStatus('loading');
    // Adiciona um pequeno delay para o feedback visual do loading ser percebido
    setTimeout(() => {
        processJsonData(jsonText);
        // O setIsLoading(false) é chamado dentro de processJsonData
    }, 100);
  };

  // Handler para gerar simulado a partir dos critérios selecionados
  const handleGenerateSimulado = () => {
    if (!selectedConcursoId) {
      setError('Por favor, selecione um concurso.');
      return;
    }
    if (numQuestoes <= 0) {
      setError('O número de questões deve ser maior que zero.');
      return;
    }

    setError(null);
    setIsLoading(true);
    setStatus('loading');

    try {
      const questoesDisponiveis = buscarQuestoesPorConcurso(selectedConcursoId);

      if (questoesDisponiveis.length === 0) {
        throw new Error('Nenhuma questão encontrada para este concurso.');
      }

      // Embaralhar e selecionar o número desejado de questões
      const questoesSelecionadas = [...questoesDisponiveis]
        .sort(() => 0.5 - Math.random()) // Embaralha
        .slice(0, numQuestoes); // Pega o número desejado

      const concursoSelecionado = concursos.find(c => c.id === selectedConcursoId);

      // Monta a estrutura SimuladoData
      const simuladoData: SimuladoData = {
        metadata: {
          titulo: `Simulado - ${concursoSelecionado?.titulo || 'Concurso Selecionado'}`,
          // descricao: `Simulado gerado com ${questoesSelecionadas.length} questões.`, // Remover campo inexistente
          totalQuestoes: questoesSelecionadas.length, // Adicionar totalQuestoes que é obrigatório
          dataGeracao: new Date().toISOString(),
          // origem: 'gerado_app', // Remover campo inexistente
          // Adicionar outros campos opcionais de metadata se disponíveis/relevantes
          concurso: concursoSelecionado?.titulo,
          // filtros: { // Remover campo inexistente
          //   concursoId: selectedConcursoId,
          //   numQuestoesSolicitadas: numQuestoes,
          //   numQuestoesGeradas: questoesSelecionadas.length,
          // }
        },
        // Mapeia as questões do questoesStore para o formato do simuladoStore
        questoes: questoesSelecionadas.map((q, index) => {
          const alternativasObj: { [key: string]: string } = {};
          let gabaritoKey = '';
          // Converte array de alternativas para objeto e encontra a chave do gabarito (a, b, c...)
          q.alternativas.forEach((alt, altIndex) => {
            const key = String.fromCharCode(97 + altIndex); // a, b, c...
            alternativasObj[key] = alt.texto;
            if (alt.id === q.respostaCorreta) {
              gabaritoKey = key;
            }
          });

          return {
            id: index + 1, // Usa o índice + 1 como ID numérico (pode ser frágil)
            enunciado: q.enunciado,
            alternativas: alternativasObj,
            gabarito: gabaritoKey,
            assunto: q.topico || q.disciplina, // Usa tópico ou disciplina como assunto
            dificuldade: q.nivelDificuldade ? (['facil', 'medio', 'dificil'].indexOf(q.nivelDificuldade) + 1) : undefined, // Mapeia dificuldade se existir
            explicacao: q.justificativa, // Usa justificativa como explicação
            // respondida, respostaUsuario, acertou não são parte da definição base da Questao no store
          };
        }),
      };

      loadSimulado(simuladoData); // Carrega o simulado gerado

    } catch (err) {
      console.error('Erro ao gerar simulado:', err);
      setError(err instanceof Error ? err.message : 'Erro desconhecido ao gerar simulado.');
      setStatus('idle');
    } finally {
      setIsLoading(false);
    }
  };


  return (
    <div className="p-6 border rounded-lg shadow-sm bg-card text-card-foreground space-y-6">
      <h2 className="text-xl font-semibold text-center">Iniciar Simulado</h2>

      {/* Mensagem de erro global */}
      {error && (
        <Alert variant="error" className="w-full mb-4">
          {error}
        </Alert>
      )}

      {error && (
        <Alert variant="error" className="w-full">
          {error}
        </Alert>
      )}

      {/* Opção 1: Gerar Simulado */}
      <div className="border p-4 rounded-md">
        <h3 className="text-lg font-medium mb-3">Gerar Simulado</h3>
        <div className="space-y-3">
          <Select
            label="Selecione o Concurso"
            value={selectedConcursoId}
            onChange={(e) => setSelectedConcursoId(e.target.value)}
            options={[{ value: '', label: 'Selecione...' }, ...concursoOptions]}
            disabled={isLoading || concursoOptions.length === 0}
          />
          <Input
            label="Número de Questões"
            type="number"
            value={numQuestoes}
            onChange={(e) => setNumQuestoes(Math.max(1, parseInt(e.target.value, 10) || 1))} // Garante > 0
            min="1"
            disabled={isLoading}
          />
          <Button
            onClick={handleGenerateSimulado}
            disabled={isLoading || !selectedConcursoId || numQuestoes <= 0}
            className="w-full justify-center"
          >
            {isLoading ? (
              <><PlayCircle size={16} className="mr-2 animate-pulse" /> Gerando...</>
            ) : (
              <><PlayCircle size={16} className="mr-2" /> Gerar e Iniciar Simulado</>
            )}
          </Button>
        </div>
         {concursoOptions.length === 0 && !isLoading && (
           <p className="text-xs text-muted-foreground mt-2 text-center">Nenhum concurso cadastrado ainda. Adicione um concurso para gerar simulados.</p>
         )}
      </div>


      {/* Divisor */}
      <div className="relative">
        <div className="absolute inset-0 flex items-center" aria-hidden="true">
          <div className="w-full border-t border-border" />
        </div>
        <div className="relative flex justify-center">
          <span className="bg-card px-2 text-sm text-muted-foreground">OU</span>
        </div>
      </div>

      {/* Opção 2: Carregar Arquivo */}
      <div className="border p-4 rounded-md">
         <h3 className="text-lg font-medium mb-3">Carregar de Arquivo .json</h3>
         <Button
             onClick={() => fileInputRef.current?.click()}
             disabled={isLoading}
             variant="outline"
             className="flex-grow justify-center"
           >
             <Upload size={16} className="mr-2" /> Selecionar Arquivo
           </Button>
           <Input
             id="file-upload"
             ref={fileInputRef}
             type="file"
             accept=".json"
             onChange={handleFileChange}
             disabled={isLoading}
             className="hidden" // Esconde o input padrão
           />
        {/* </div> removido - estava sobrando aqui */}
      </div>


      {/* Divisor */}
      <div className="relative">
        <div className="absolute inset-0 flex items-center" aria-hidden="true">
          <div className="w-full border-t border-border" />
        </div>
        <div className="relative flex justify-center">
          <span className="bg-card px-2 text-sm text-muted-foreground">OU</span>
        </div>
      </div>

      {/* Opção 3: Colar Texto */}
      <div className="border p-4 rounded-md">
         <h3 className="text-lg font-medium mb-3">Colar Texto JSON</h3>
         <Textarea
          id="json-text"
          value={jsonText}
          onChange={(e) => setJsonText(e.target.value)}
          placeholder="Cole o conteúdo JSON gerado pela IA aqui..."
          rows={8}
          className="mb-2"
          disabled={isLoading}
        />
        <Button
          onClick={handleLoadFromText}
          disabled={isLoading || !jsonText.trim()}
          className="w-full justify-center"
        >
          {isLoading ? (
             <><Upload size={16} className="mr-2 animate-pulse" /> Carregando...</>
          ) : (
             <><ClipboardPaste size={16} className="mr-2" /> Carregar Texto Colado</>
          )}
        </Button>
      </div>
    </div>
  );
};

export default SimuladoLoader;
</file>

<file path="app/components/estudos/simulado/SimuladoResults.tsx">
'use client';

import React, { useMemo } from 'react';
import { useSimuladoStore } from '@/app/stores/simuladoStore';
import { Card } from '@/app/components/ui/Card';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  Cell, // Para cores personalizadas nas barras
} from 'recharts';

const SimuladoResults: React.FC = () => {
  const { simuladoData, userAnswers } = useSimuladoStore();

  // Calcula os resultados apenas quando os dados mudarem
  const results = useMemo(() => {
    if (!simuladoData) {
      return { correctCount: 0, totalQuestions: 0, percentageCorrect: 0, percentageIncorrect: 0 };
    }

    let correctCount = 0;
    const totalQuestions = simuladoData.questoes.length;

    simuladoData.questoes.forEach((questao) => {
      if (userAnswers[questao.id] === questao.gabarito) {
        correctCount++;
      }
    });

    const percentageCorrect = totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;
    const percentageIncorrect = 100 - percentageCorrect;

    return {
      correctCount,
      totalQuestions,
      percentageCorrect,
      percentageIncorrect,
    };
  }, [simuladoData, userAnswers]);

  if (!simuladoData) {
    return <div>Erro: Dados do simulado não encontrados para exibir resultados.</div>;
  }

  // Dados para o gráfico
  const chartData = [
    { name: 'Acertos', value: results.percentageCorrect },
    { name: 'Erros', value: results.percentageIncorrect },
  ];

  // Cores para as barras
  const COLORS = ['#10B981', '#EF4444']; // Verde para acertos, Vermelho para erros (Tailwind colors)

  // Corrigindo a estrutura JSX
  return (
    <Card className="w-full max-w-xl mx-auto" title="Resultado da Conferência">
      {/* Seção de Texto com Resultados */}
      <div className="text-center mb-6">
        <p className="text-lg">
          Você acertou{' '}
          <span className="font-bold text-green-600 dark:text-green-400">{results.correctCount}</span> de{' '}
          <span className="font-bold">{results.totalQuestions}</span> questões.
        </p>
        <p className="text-2xl font-bold mt-1">
          {results.percentageCorrect.toFixed(1)}% de acerto
        </p>
      </div>

      {/* Seção do Gráfico */}
      <div style={{ width: '100%', height: 200 }}>
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={chartData}
            layout="vertical"
            margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
          >
            <XAxis type="number" domain={[0, 100]} hide />
            <YAxis type="category" dataKey="name" hide />
            <Tooltip formatter={(value: number) => `${value.toFixed(1)}%`} />
            <Bar dataKey="value" barSize={40} radius={[4, 4, 4, 4]}>
              {chartData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      </div>

      {/* Comentário sobre futuras adições */}
      {/* Poderia adicionar um botão para "Ver Gabarito Detalhado" ou "Refazer" aqui no futuro */}
    </Card>
  );
};

export default SimuladoResults;
</file>

<file path="app/components/estudos/simulado/SimuladoReview.tsx">
'use client';

import React from 'react';
import { useSimuladoStore } from '@/app/stores/simuladoStore';
import { Button } from '@/app/components/ui/Button';
import { Card } from '@/app/components/ui/Card'; // Usando Card existente (sem subcomponentes)
import { cn } from '@/app/lib/utils'; // Utilitário para classes condicionais

const SimuladoReview: React.FC = () => {
  const {
    simuladoData,
    currentQuestionIndex,
    userAnswers,
    selectAnswer,
    nextQuestion,
    prevQuestion,
    finishReview,
  } = useSimuladoStore();

  if (!simuladoData) {
    // Idealmente, este estado não deveria ser alcançado se a lógica da página estiver correta
    return <div>Erro: Nenhum simulado carregado.</div>;
  }

  const currentQuestion = simuladoData.questoes[currentQuestionIndex];
  const totalQuestoes = simuladoData.questoes.length;
  const isLastQuestion = currentQuestionIndex === totalQuestoes - 1;
  const userAnswer = userAnswers[currentQuestion.id];

  const handleSelectAnswer = (alternativeKey: string) => {
    selectAnswer(currentQuestion.id, alternativeKey);
  };

  const cardTitle = `Questão ${currentQuestionIndex + 1} de ${totalQuestoes}`;

  // Reconstruindo a estrutura JSX para garantir a correção
  return (
    <div className="w-full max-w-3xl mx-auto">
      {/* Card para exibir a questão */}
      <Card className="mb-4" title={cardTitle}>
        <p className="mb-6 whitespace-pre-wrap">{currentQuestion.enunciado}</p>
        <div className="space-y-3">
          {Object.entries(currentQuestion.alternativas).map(([key, text]) => (
            <Button
              key={key}
              variant={userAnswer === key ? 'default' : 'outline'}
              onClick={() => handleSelectAnswer(key)}
              className={cn(
                'w-full justify-start text-left h-auto py-3',
                userAnswer === key ? 'ring-2 ring-primary ring-offset-2' : ''
              )}
            >
              <span className="font-bold mr-2">{key.toUpperCase()})</span>
              <span className="whitespace-pre-wrap">{text}</span>
            </Button>
          ))}
        </div>
      </Card>

      {/* Div para os botões de navegação */}
      <div className="flex justify-between mt-4">
        <Button
          onClick={prevQuestion}
          disabled={currentQuestionIndex === 0}
          variant="outline"
        >
          Anterior
        </Button>
        {isLastQuestion ? (
          <Button onClick={finishReview} disabled={!userAnswer}>
            Finalizar Conferência
          </Button>
        ) : (
          <Button onClick={nextQuestion} disabled={!userAnswer}>
            Próxima
          </Button>
        )}
      </div>
    </div>
  );
};

export default SimuladoReview;
</file>

<file path="app/components/estudos/RegistroEstudos.tsx">
'use client'

import { useState } from 'react'
import { BookOpen, Plus, X, Edit, Trash, Check, Clock } from 'lucide-react'
import { useRegistroEstudosStore, SessaoEstudo } from '@/app/stores/registroEstudosStore'

export function RegistroEstudos() {
  const { sessoes, adicionarSessao, removerSessao, alternarCompletar, editarSessao } = useRegistroEstudosStore()
  
  const [novaSessao, setNovaSessao] = useState({
    titulo: '',
    descricao: '',
    duracao: 30,
  })
  
  const [editandoId, setEditandoId] = useState<string | null>(null)
  const [mostrarForm, setMostrarForm] = useState(false)

  const handleAdicionarSessao = () => {
    if (!novaSessao.titulo) return

    adicionarSessao(novaSessao)
    
    setNovaSessao({
      titulo: '',
      descricao: '',
      duracao: 30,
    })
    
    setMostrarForm(false)
  }

  const iniciarEdicao = (sessao: SessaoEstudo) => {
    setEditandoId(sessao.id)
    setNovaSessao({
      titulo: sessao.titulo,
      descricao: sessao.descricao,
      duracao: sessao.duracao,
    })
    setMostrarForm(true)
  }

  const salvarEdicao = () => {
    if (!editandoId || !novaSessao.titulo) return

    editarSessao(editandoId, novaSessao)
    
    setNovaSessao({
      titulo: '',
      descricao: '',
      duracao: 30,
    })
    
    setEditandoId(null)
    setMostrarForm(false)
  }

  const cancelarForm = () => {
    setNovaSessao({
      titulo: '',
      descricao: '',
      duracao: 30,
    })
    setEditandoId(null)
    setMostrarForm(false)
  }

  // Calcular estatísticas
  const sessoesCompletas = sessoes.filter((s) => s.completo).length
  const totalMinutos = sessoes.reduce((total, s) => total + (s.completo ? s.duracao : 0), 0)
  const totalHoras = Math.floor(totalMinutos / 60)
  const minutosRestantes = totalMinutos % 60

  return (
    <div className="space-y-4">
      {/* Estatísticas */}
      <div className="grid grid-cols-2 gap-4 mb-4">
        <div className="p-4 bg-estudos-light dark:bg-gray-800 rounded-lg border border-estudos-secondary/20 dark:border-estudos-dark/30">
          <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Sessões Completas
          </h4>
          <div className="flex items-center">
            <Check className="h-5 w-5 text-estudos-primary dark:text-estudos-secondary mr-2" />
            <span className="text-xl font-bold text-estudos-primary dark:text-estudos-secondary">
              {sessoesCompletas} / {sessoes.length}
            </span>
          </div>
        </div>
        
        <div className="p-4 bg-estudos-light dark:bg-gray-800 rounded-lg border border-estudos-secondary/20 dark:border-estudos-dark/30">
          <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Tempo Total
          </h4>
          <div className="flex items-center">
            <Clock className="h-5 w-5 text-estudos-primary dark:text-estudos-secondary mr-2" />
            <span className="text-xl font-bold text-estudos-primary dark:text-estudos-secondary">
              {totalHoras}h {minutosRestantes}min
            </span>
          </div>
        </div>
      </div>

      {/* Lista de Sessões */}
      <div className="space-y-3">
        {sessoes.map((sessao) => (
          <div
            key={sessao.id}
            className={`p-3 bg-white dark:bg-gray-800 rounded-lg border ${
              sessao.completo
                ? 'border-green-200 dark:border-green-900'
                : 'border-gray-200 dark:border-gray-700'
            }`}
          >
            <div className="flex items-start justify-between">
              <div className="flex items-start">
                <button
                  onClick={() => alternarCompletar(sessao.id)}
                  className={`mt-1 mr-3 flex-shrink-0 w-5 h-5 rounded-full border ${
                    sessao.completo
                      ? 'bg-green-500 border-green-500 text-white'
                      : 'border-gray-400 dark:border-gray-500'
                  } flex items-center justify-center`}
                  aria-label={sessao.completo ? 'Marcar como incompleto' : 'Marcar como completo'}
                >
                  {sessao.completo && <Check className="h-3 w-3" />}
                </button>
                
                <div>
                  <h3
                    className={`font-medium ${
                      sessao.completo
                        ? 'text-gray-500 dark:text-gray-400 line-through'
                        : 'text-gray-900 dark:text-white'
                    }`}
                  >
                    {sessao.titulo}
                  </h3>
                  
                  {sessao.descricao && (
                    <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                      {sessao.descricao}
                    </p>
                  )}
                  
                  <div className="flex items-center mt-2 text-xs text-gray-500 dark:text-gray-400">
                    <Clock className="h-3 w-3 mr-1" />
                    <span>{sessao.duracao} minutos</span>
                    <span className="mx-2">•</span>
                    <BookOpen className="h-3 w-3 mr-1" />
                    <span>{new Date(sessao.data).toLocaleDateString()}</span>
                  </div>
                </div>
              </div>
              
              <div className="flex space-x-1">
                <button
                  onClick={() => iniciarEdicao(sessao)}
                  className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                  aria-label="Editar sessão"
                >
                  <Edit className="h-4 w-4" />
                </button>
                
                <button
                  onClick={() => removerSessao(sessao.id)}
                  className="p-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                  aria-label="Remover sessão"
                >
                  <Trash className="h-4 w-4" />
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Formulário */}
      {mostrarForm ? (
        <div className="mt-4 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
          <div className="flex justify-between items-center mb-3">
            <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300">
              {editandoId ? 'Editar Sessão' : 'Nova Sessão de Estudo'}
            </h3>
            <button
              onClick={cancelarForm}
              className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
              aria-label="Fechar formulário"
            >
              <X className="h-5 w-5" />
            </button>
          </div>
          
          <div className="space-y-3">
            <div>
              <label htmlFor="titulo" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Título
              </label>
              <input
                type="text"
                id="titulo"
                value={novaSessao.titulo}
                onChange={(e) => setNovaSessao({ ...novaSessao, titulo: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                placeholder="Ex: Matemática - Álgebra"
              />
            </div>
            
            <div>
              <label htmlFor="descricao" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Descrição (opcional)
              </label>
              <textarea
                id="descricao"
                value={novaSessao.descricao}
                onChange={(e) => setNovaSessao({ ...novaSessao, descricao: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                placeholder="Detalhes sobre o que será estudado"
                rows={2}
              />
            </div>
            
            <div>
              <label htmlFor="duracao" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Duração (minutos)
              </label>
              <input
                type="number"
                id="duracao"
                min="5"
                max="240"
                value={novaSessao.duracao}
                onChange={(e) => setNovaSessao({ ...novaSessao, duracao: parseInt(e.target.value) || 30 })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
              />
            </div>
            
            <div className="flex justify-end pt-2">
              <button
                onClick={editandoId ? salvarEdicao : handleAdicionarSessao}
                disabled={!novaSessao.titulo}
                className="px-4 py-2 bg-estudos-primary text-white rounded-lg hover:bg-estudos-primary/90 focus:outline-none focus:ring-2 focus:ring-estudos-primary focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {editandoId ? 'Salvar Alterações' : 'Adicionar Sessão'}
              </button>
            </div>
          </div>
        </div>
      ) : (
        <button
          onClick={() => setMostrarForm(true)}
          className="w-full py-2 flex items-center justify-center bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg border border-dashed border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300"
          aria-label="Adicionar nova sessão de estudo"
        >
          <Plus className="h-5 w-5 mr-1" />
          <span>Adicionar Sessão de Estudo</span>
        </button>
      )}
    </div>
  )
}
</file>

<file path="app/components/estudos/TemporizadorPomodoro.tsx">
'use client'

import { useState, useEffect } from 'react'
import { Play, Pause, RefreshCw, Settings, X, Award } from 'lucide-react'; // Adicionar Award
import { usePomodoroStore } from '@/app/stores/pomodoroStore';

// Adicionar props para tipo e título opcional
interface TemporizadorPomodoroProps {
  tipo?: 'geral' | 'concurso';
  titulo?: string; // Para personalizar o título se necessário
}

export function TemporizadorPomodoro({ tipo = 'geral', titulo }: TemporizadorPomodoroProps) {
  const { configuracao, atualizarConfiguracao, ciclosCompletos, incrementarCiclosCompletos, resetarCiclosCompletos } = usePomodoroStore();

  const [isActive, setIsActive] = useState(false);
  const [isPaused, setIsPaused] = useState(true)
  const [time, setTime] = useState(configuracao.tempoFoco * 60) // tempo em segundos
  const [ciclo, setCiclo] = useState<'foco' | 'pausa' | 'longapausa'>('foco')
  const [showSettings, setShowSettings] = useState(false)
  const [configTemp, setConfigTemp] = useState(configuracao)

  useEffect(() => {
    // Reset timer quando a configuração mudar e o timer estiver parado
    if (!isActive || isPaused) {
      if (ciclo === 'foco') {
        setTime(configuracao.tempoFoco * 60);
      } else if (ciclo === 'pausa') {
        setTime(configuracao.tempoPausa * 60);
      } else {
        setTime(configuracao.tempoLongapausa * 60);
      }
    }
  }, [configuracao, isActive, isPaused, ciclo]);

  useEffect(() => {
    let interval: NodeJS.Timeout | null = null

    if (isActive && !isPaused) {
      interval = setInterval(() => {
        setTime((time) => {
          if (time <= 1) {
            // Tocar som de notificação
            if (typeof window !== 'undefined') {
              const audio = new Audio('/notification.mp3')
              audio.play().catch(() => {
                // Falha silenciosa se o navegador bloquear o áudio
                console.log('Notificação de áudio bloqueada pelo navegador')
              })
            }

            // Alternar entre ciclos
            if (ciclo === 'foco') {
              incrementarCiclosCompletos()
              
              // Verificar se deve ser uma pausa longa
              if ((ciclosCompletos + 1) % configuracao.ciclosAntesLongapausa === 0) {
                setCiclo('longapausa')
                return configuracao.tempoLongapausa * 60
              } else {
                setCiclo('pausa')
                return configuracao.tempoPausa * 60
              }
            } else {
              setCiclo('foco')
              return configuracao.tempoFoco * 60
            }
          }
          return time - 1
        })
      }, 1000)
    } else {
      interval && clearInterval(interval)
    }

    return () => {
      interval && clearInterval(interval)
    }
  }, [isActive, isPaused, ciclo, ciclosCompletos, configuracao, incrementarCiclosCompletos])

  const formatTime = () => {
    const minutes = Math.floor(time / 60)
    const seconds = time % 60
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
  }

  const handleStart = () => {
    setIsActive(true)
    setIsPaused(false)
  }

  const handlePause = () => {
    setIsPaused(true)
  }

  const handleReset = () => {
    setIsActive(false)
    setIsPaused(true)
    setCiclo('foco')
    setTime(configuracao.tempoFoco * 60)
    resetarCiclosCompletos()
  }

  const handleSettingsChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    setConfigTemp({
      ...configTemp,
      [name]: parseInt(value),
    })
  }

  const saveSettings = () => {
    atualizarConfiguracao(configTemp)
    setShowSettings(false)
  }

  // Determinar a cor com base no ciclo atual
  const cicloColor = 
    ciclo === 'foco' 
      ? 'text-estudos-primary dark:text-estudos-secondary' 
      : ciclo === 'pausa'
        ? 'text-green-600 dark:text-green-400'
        : 'text-blue-600 dark:text-blue-400'

  // Determinar a mensagem com base no ciclo atual
  const cicloMensagem = 
    ciclo === 'foco'
        ? tipo === 'concurso' ? 'Foco (Concurso)' : 'Tempo de foco'
        : ciclo === 'pausa'
          ? 'Pausa curta'
          : 'Pausa longa'

  // Determinar a cor de fundo com base no ciclo atual
  const cicloBgColor = 
    ciclo === 'foco' 
      ? 'bg-estudos-light dark:bg-estudos-dark/30' 
      : ciclo === 'pausa'
        ? 'bg-green-100 dark:bg-green-900/30'
        : 'bg-blue-100 dark:bg-blue-900/30'

  return (
    <div className="flex flex-col items-center">
      <div className="text-center mb-4">
        {/* Adiciona ícone se for tipo concurso */}
        <h3 className={`text-xl font-bold ${cicloColor} flex items-center justify-center gap-2`}>
           {tipo === 'concurso' && <Award size={20} />}
           {titulo || cicloMensagem} {/* Usa título customizado ou padrão */}
        </h3>
        <p className="text-gray-600 dark:text-gray-400 text-sm">
          Ciclos completos: {ciclosCompletos}
        </p>
      </div>

      <div className={`text-4xl font-mono font-bold mb-6 ${cicloBgColor} text-gray-800 dark:text-white px-6 py-3 rounded-xl`}>
        {formatTime()}
      </div>

      <div className="flex space-x-4 mb-6">
        {isPaused ? (
          <button
            onClick={handleStart}
            className="flex items-center px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500"
            aria-label="Iniciar temporizador"
          >
            <Play className="h-5 w-5 mr-1" />
            <span>Iniciar</span>
          </button>
        ) : (
          <button
            onClick={handlePause}
            className="flex items-center px-4 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-amber-500"
            aria-label="Pausar temporizador"
          >
            <Pause className="h-5 w-5 mr-1" />
            <span>Pausar</span>
          </button>
        )}

        <button
          onClick={handleReset}
          className="flex items-center px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
          aria-label="Reiniciar temporizador"
        >
          <RefreshCw className="h-5 w-5 mr-1" />
          <span>Reiniciar</span>
        </button>

        <button
          onClick={() => {
            setConfigTemp(configuracao);
            setShowSettings(true);
          }}
          className="flex items-center px-4 py-2 bg-blue-100 dark:bg-blue-900/20 text-blue-800 dark:text-blue-300 rounded-lg hover:bg-blue-200 dark:hover:bg-blue-800/30 focus:outline-none focus:ring-2 focus:ring-blue-500"
          aria-label="Configurações do temporizador"
        >
          <Settings className="h-5 w-5 mr-1" />
          <span>Ajustar</span>
        </button>
      </div>

      {/* Explicação do ciclo atual */}
      <div className={`p-3 ${cicloBgColor} rounded-lg text-sm text-gray-800 dark:text-gray-100 max-w-md`}>
        {ciclo === 'foco' ? (
          <p>Concentre-se em uma única tarefa. Evite distrações.</p>
        ) : ciclo === 'pausa' ? (
          <p>Faça uma pausa curta. Alongue-se ou beba água.</p>
        ) : (
          <p>Pausa longa! Levante-se e caminhe um pouco.</p>
        )}
      </div>

      {/* Modal de configurações */}
      {showSettings && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                Configurações do Temporizador
              </h3>
              <button
                onClick={() => setShowSettings(false)}
                className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                aria-label="Fechar configurações"
              >
                <X className="h-5 w-5" />
              </button>
            </div>

            <div className="space-y-4">
              <div>
                <label
                  htmlFor="tempoFoco"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >
                  Tempo de Foco (minutos)
                </label>
                <input
                  type="number"
                  id="tempoFoco"
                  name="tempoFoco"
                  min="1"
                  max="60"
                  value={configTemp.tempoFoco}
                  onChange={handleSettingsChange}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                />
              </div>

              <div>
                <label
                  htmlFor="tempoPausa"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >
                  Tempo de Pausa Curta (minutos)
                </label>
                <input
                  type="number"
                  id="tempoPausa"
                  name="tempoPausa"
                  min="1"
                  max="30"
                  value={configTemp.tempoPausa}
                  onChange={handleSettingsChange}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                />
              </div>

              <div>
                <label
                  htmlFor="tempoLongapausa"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >
                  Tempo de Pausa Longa (minutos)
                </label>
                <input
                  type="number"
                  id="tempoLongapausa"
                  name="tempoLongapausa"
                  min="5"
                  max="60"
                  value={configTemp.tempoLongapausa}
                  onChange={handleSettingsChange}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                />
              </div>

              <div>
                <label
                  htmlFor="ciclosAntesLongapausa"
                  className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
                >
                  Ciclos antes da Pausa Longa
                </label>
                <input
                  type="number"
                  id="ciclosAntesLongapausa"
                  name="ciclosAntesLongapausa"
                  min="1"
                  max="10"
                  value={configTemp.ciclosAntesLongapausa}
                  onChange={handleSettingsChange}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                />
              </div>

              <div className="pt-4 flex justify-end">
                <button
                  onClick={saveSettings}
                  className="px-4 py-2 bg-estudos-primary text-white rounded-lg hover:bg-estudos-primary/90 focus:outline-none focus:ring-2 focus:ring-estudos-primary focus:ring-offset-2"
                >
                  Salvar Configurações
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/components/estudos/VisualizadorChecklist.tsx">
'use client';

import { Fragment, ReactNode, useState, useEffect } from 'react';
import { Dialog, Transition } from '@headlessui/react';
import { X } from 'lucide-react';
import { cn } from '@/app/lib/utils';
import { Button } from '@/app/components/ui/Button';
import { Modal } from '@/app/components/ui/Modal'; // Import the Modal component

interface ChecklistItem {
  id: number;
  text: string;
  checked: boolean;
  level: number; // To handle indentation for sub-items
}

interface VisualizadorChecklistProps {
  isOpen: boolean;
  onClose: () => void;
  fileId: string | null;
  title?: string; // Optional title
}

export function VisualizadorChecklist({
  isOpen,
  onClose,
  fileId,
  title = 'Checklist', // Default title
}: VisualizadorChecklistProps) {
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [checklistItems, setChecklistItems] = useState<ChecklistItem[]>([]);

  useEffect(() => {
    if (!isOpen || !fileId) {
      setContent('');
      setChecklistItems([]);
      setError(null);
      return;
    }

    const fetchChecklist = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(`/api/drive/carregar-material?fileId=${encodeURIComponent(fileId)}`);
        if (!response.ok) {
          throw new Error(`Erro ao carregar o checklist do Google Drive: ${response.statusText}`);
        }
        const data = await response.json();
        if (!data.success) {
           throw new Error(data.error || 'Erro desconhecido ao carregar o checklist do Google Drive');
        }
        setContent(data.content);
        parseChecklist(data.content);
      } catch (err: any) {
        setError(err.message);
        setContent('');
        setChecklistItems([]);
      } finally {
        setLoading(false);
      }
    };

    fetchChecklist();
  }, [isOpen, fileId]);

  const parseChecklist = (markdownContent: string) => {
    const lines = markdownContent.split('\n');
    const items: ChecklistItem[] = [];
    let itemId = 0;

    lines.forEach(line => {
      const trimmedLine = line.trimStart();
      const level = line.length - trimmedLine.length; // Simple indentation level based on leading spaces

      const checkboxMatch = trimmedLine.match(/^- \[( |x)\] (.*)$/);
      if (checkboxMatch) {
        const checked = checkboxMatch[1] === 'x';
        const text = checkboxMatch[2].trim();
        items.push({ id: itemId++, text, checked, level });
      } else if (trimmedLine.startsWith('- ')) {
        // Handle list items that are not checkboxes, maybe just text
        const text = trimmedLine.substring(2).trim();
         items.push({ id: itemId++, text, checked: false, level, isText: true } as any); // Add a flag for non-checkbox items
      } else {
         // Handle other lines, maybe just text
         if (trimmedLine) {
            items.push({ id: itemId++, text: trimmedLine, checked: false, level, isText: true } as any);
         }
      }
    });

    setChecklistItems(items);
  };

  const handleCheckChange = (id: number) => {
    setChecklistItems(prevItems =>
      prevItems.map(item =>
        item.id === id ? { ...item, checked: !item.checked } : item
      )
    );
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={title} size="lg">
      {loading && <p>Carregando checklist...</p>}
      {error && <p className="text-red-500">Erro: {error}</p>}
      {!loading && !error && checklistItems.length > 0 && (
        <div className="prose dark:prose-invert max-w-none">
          <ul>
            {checklistItems.map(item => (
              <li key={item.id} style={{ marginLeft: `${item.level * 16}px` }}>
                {'isText' in item && (item as any).isText ? (
                   // Render as text if not a checkbox item
                   <span>{item.text}</span>
                ) : (
                   // Render as checkbox item
                   <label className="flex items-center space-x-2">
                     <input
                       type="checkbox"
                       checked={item.checked}
                       onChange={() => handleCheckChange(item.id)}
                       className="form-checkbox h-4 w-4 text-blue-600"
                     />
                     <span>{item.text}</span>
                   </label>
                )}
              </li>
            ))}
          </ul>
        </div>
      )}
       {!loading && !error && checklistItems.length === 0 && content && (
           <p>Nenhum item de checklist encontrado neste arquivo.</p>
       )}
        {!loading && !error && !content && !fileId && (
            <p>Selecione um arquivo de checklist para visualizar.</p>
        )}
    </Modal>
  );
}
</file>

<file path="app/components/estudos/VisualizadorMarkdown.tsx">
import React, { useState, useEffect } from 'react';
import { Modal } from '../ui/Modal';
import ReactMarkdown from 'react-markdown';

interface VisualizadorMarkdownProps {
  isOpen: boolean;
  onClose: () => void;
  fileId: string | null;
  title?: string;
}

const VisualizadorMarkdown: React.FC<VisualizadorMarkdownProps> = ({
  isOpen,
  onClose,
  fileId,
  title = "Material de Estudo",
}) => {
  const [content, setContent] = useState<string>('');
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!isOpen || !fileId) {
      // Reset state when modal is closed or no file ID is provided
      setContent('');
      setLoading(false);
      setError(null);
      return;
    }

    const fetchContent = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(`/api/drive/carregar-material?fileId=${encodeURIComponent(fileId)}`);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data.success && data.content) {
          setContent(data.content);
        } else {
          throw new Error(data.error || "Conteúdo não encontrado na resposta da API do Google Drive.");
        }
      } catch (err) {
        console.error("Erro ao buscar conteúdo Markdown do Google Drive:", err);
        setError("Erro ao carregar o material do Google Drive. Verifique o console para mais detalhes.");
      } finally {
        setLoading(false);
      }
    };

    fetchContent();

  }, [fileId, isOpen]); // Depend on fileId and isOpen

  return (
    <Modal isOpen={isOpen} onClose={onClose} title={title}>
      <div className="mt-4 max-h-[70vh] overflow-y-auto p-1">
        {loading && <p>Carregando...</p>}
        {error && <p className="text-red-500">{error}</p>}
        {!loading && !error && content && (
          <article className="prose dark:prose-invert max-w-none">
            <ReactMarkdown>{content}</ReactMarkdown>
          </article>
        )}
         {!loading && !error && !content && fileId && <p>Nenhum conteúdo para exibir.</p>}
         {!fileId && <p>Selecione um material para visualizar.</p>}
      </div>
    </Modal>
  );
};

export default VisualizadorMarkdown;
</file>

<file path="app/components/financas/AdicionarDespesa.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useFinancasStore } from '@/app/stores/financasStore'
import { Check, CreditCard, PlusCircle } from 'lucide-react'

export function AdicionarDespesa() {
  const { categorias, adicionarTransacao } = useFinancasStore()
  
  const [descricao, setDescricao] = useState('')
  const [valor, setValor] = useState('')
  const [categoriaId, setCategoriaId] = useState('')
  const [mostrarFeedback, setMostrarFeedback] = useState(false)
  
  // Inicializar categoria se estiver vazia
  useEffect(() => {
    if (!categoriaId && categorias.length > 0) {
      setCategoriaId(categorias[0].id)
    }
  }, [categorias, categoriaId])
  
  const handleAdicionarDespesa = (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!descricao || !valor || parseFloat(valor) <= 0 || !categoriaId) return
    
    const hoje = new Date().toISOString().split('T')[0]
    
    adicionarTransacao(
      hoje,
      parseFloat(valor),
      descricao,
      categoriaId,
      'despesa'
    )
    
    // Mostrar feedback visual
    setMostrarFeedback(true)
    
    // Limpar formulário
    setDescricao('')
    setValor('')
    
    // Esconder feedback após 1.5 segundos
    setTimeout(() => {
      setMostrarFeedback(false)
    }, 1500)
  }
  
  return (
    <div className="space-y-4">
      {mostrarFeedback ? (
        <div className="text-center p-6 bg-green-50 dark:bg-green-900/20 rounded-lg">
          <div className="inline-flex items-center justify-center w-12 h-12 bg-green-100 dark:bg-green-800 rounded-full text-green-600 dark:text-green-300 mb-4">
            <Check className="h-6 w-6" />
          </div>
          <h3 className="text-lg font-medium text-green-600 dark:text-green-300">
            Despesa Registrada!
          </h3>
          <p className="text-sm text-green-500 dark:text-green-400 mt-1">
            Sua despesa foi adicionada com sucesso.
          </p>
        </div>
      ) : (
        <form onSubmit={handleAdicionarDespesa} className="space-y-4">
          <div>
            <label htmlFor="despesaDescricao" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              Descrição
            </label>
            <input
              id="despesaDescricao"
              type="text"
              value={descricao}
              onChange={e => setDescricao(e.target.value)}
              className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
              placeholder="Ex: Mercado"
              required
            />
          </div>
          
          <div>
            <label htmlFor="despesaValor" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              Valor (R$)
            </label>
            <input
              id="despesaValor"
              type="number"
              value={valor}
              onChange={e => setValor(e.target.value)}
              className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
              placeholder="0,00"
              min="0.01"
              step="0.01"
              required
            />
          </div>
          
          <div>
            <label htmlFor="despesaCategoria" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
              Categoria
            </label>
            <div className="grid grid-cols-5 gap-2 mt-2">
              {categorias.map(categoria => (
                <button
                  key={categoria.id}
                  type="button"
                  onClick={() => setCategoriaId(categoria.id)}
                  className={`h-14 p-2 rounded-md flex flex-col items-center justify-center text-xs ${
                    categoriaId === categoria.id
                      ? 'ring-2 ring-offset-2 ring-gray-500'
                      : 'border border-gray-200 dark:border-gray-700'
                  }`}
                  style={{ backgroundColor: `${categoria.cor}20` }}
                  aria-label={`Selecionar categoria ${categoria.nome}`}
                >
                  <div 
                    className="w-6 h-6 rounded-full flex items-center justify-center mb-1"
                    style={{ backgroundColor: categoria.cor }}
                  >
                    <span className="text-white text-xs">
                      {/* Usar a primeira letra como ícone simplificado */}
                      {categoria.nome.charAt(0)}
                    </span>
                  </div>
                  <span className="truncate w-full text-center text-gray-900 dark:text-white">
                    {categoria.nome}
                  </span>
                </button>
              ))}
            </div>
          </div>
          
          <button
            type="submit"
            className="w-full px-4 py-3 mt-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 flex items-center justify-center"
          >
            <PlusCircle className="h-5 w-5 mr-2" />
            Adicionar Despesa
          </button>
        </form>
      )}
      
      {/* Dicas rápidas */}
      <div className="mt-4 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700">
        <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center mb-2">
          <CreditCard className="h-4 w-4 mr-1" /> 
          Dicas para registrar despesas
        </h3>
        <ul className="text-xs text-gray-500 dark:text-gray-400 space-y-1 ml-5 list-disc">
          <li>Registre despesas logo após realizá-las</li>
          <li>Use descrições curtas e específicas</li>
          <li>Categorize corretamente para melhor visualização</li>
        </ul>
      </div>
    </div>
  )
}
</file>

<file path="app/components/financas/CalendarioPagamentos.tsx">
'use client'

import { useState, useEffect } from 'react'
import { useFinancasStore } from '@/app/stores/financasStore'
import { Calendar, Plus, Check, X, ChevronLeft, ChevronRight } from 'lucide-react'

export function CalendarioPagamentos() {
  const { 
    pagamentosRecorrentes, 
    categorias,
    adicionarPagamentoRecorrente, 
    removerPagamentoRecorrente,
    marcarPagamentoComoPago
  } = useFinancasStore()
  
  const [mostrarFormulario, setMostrarFormulario] = useState(false)
  const [novoPagamento, setNovoPagamento] = useState({
    descricao: '',
    valor: 0,
    dataVencimento: '1', // dia do mês
    categoriaId: ''
  })
  
  const [mesAtual, setMesAtual] = useState(new Date().getMonth())
  const [anoAtual, setAnoAtual] = useState(new Date().getFullYear())
  
  // Formatador para valores monetários
  const formatadorMoeda = new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  })
  
  // Obter os nomes dos meses em português
  const nomesMeses = [
    'Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho',
    'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
  ]
  
  // Avançar para o próximo mês
  const avancarMes = () => {
    if (mesAtual === 11) {
      setMesAtual(0)
      setAnoAtual(anoAtual + 1)
    } else {
      setMesAtual(mesAtual + 1)
    }
  }
  
  // Retroceder para o mês anterior
  const retrocederMes = () => {
    if (mesAtual === 0) {
      setMesAtual(11)
      setAnoAtual(anoAtual - 1)
    } else {
      setMesAtual(mesAtual - 1)
    }
  }
  
  // Verificar se um pagamento é do mês atual
  const isDoMesAtual = (dataVencimento: string) => {
    const dia = parseInt(dataVencimento)
    const data = new Date(anoAtual, mesAtual, dia)
    return data.getMonth() === mesAtual && data.getFullYear() === anoAtual
  }
  
  // Filtrar pagamentos do mês atual
  const pagamentosDoMes = pagamentosRecorrentes.filter(pagamento => {
    return isDoMesAtual(pagamento.dataVencimento)
  })
  
  // Ordenar pagamentos por dia
  const pagamentosOrdenados = [...pagamentosDoMes].sort((a, b) => {
    return parseInt(a.dataVencimento) - parseInt(b.dataVencimento)
  })
  
  // Adicionar novo pagamento recorrente
  const handleAdicionarPagamento = () => {
    if (
      !novoPagamento.descricao || 
      novoPagamento.valor <= 0 || 
      !novoPagamento.dataVencimento || 
      !novoPagamento.categoriaId
    ) return
    
    adicionarPagamentoRecorrente(
      novoPagamento.descricao,
      novoPagamento.valor,
      novoPagamento.dataVencimento,
      novoPagamento.categoriaId
    )
    
    setNovoPagamento({
      descricao: '',
      valor: 0,
      dataVencimento: '1',
      categoriaId: ''
    })
    
    setMostrarFormulario(false)
  }
  
  // Verificar se um dia já passou no mês atual
  const isDataPassada = (dia: number) => {
    const hoje = new Date()
    const dataPagamento = new Date(anoAtual, mesAtual, dia)
    return dataPagamento < hoje
  }
  
  // Verificar se é o dia atual
  const isHoje = (dia: number) => {
    const hoje = new Date()
    return (
      dia === hoje.getDate() && 
      mesAtual === hoje.getMonth() && 
      anoAtual === hoje.getFullYear()
    )
  }
  
  // Gerar opções para os dias do mês
  const diasDoMes = Array.from({ length: 31 }, (_, i) => i + 1)
  
  useEffect(() => {
    // Inicializar a categoriaId se estiver vazia e houver categorias disponíveis
    if (!novoPagamento.categoriaId && categorias.length > 0) {
      setNovoPagamento(prev => ({ ...prev, categoriaId: categorias[0].id }))
    }
  }, [categorias, novoPagamento.categoriaId])
  
  return (
    <div className="space-y-4">
      {/* Seletor de mês */}
      <div className="flex items-center justify-between mb-4">
        <button
          onClick={retrocederMes}
          className="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700"
          aria-label="Mês anterior"
        >
          <ChevronLeft className="h-5 w-5" />
        </button>
        
        <h3 className="text-md font-medium text-gray-700 dark:text-gray-300">
          {nomesMeses[mesAtual]} {anoAtual}
        </h3>
        
        <button
          onClick={avancarMes}
          className="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700"
          aria-label="Próximo mês"
        >
          <ChevronRight className="h-5 w-5" />
        </button>
      </div>
      
      {/* Lista de pagamentos do mês */}
      <div className="space-y-2">
        {pagamentosOrdenados.length > 0 ? (
          pagamentosOrdenados.map(pagamento => {
            const categoria = categorias.find(c => c.id === pagamento.categoriaId)
            const diaVencimento = parseInt(pagamento.dataVencimento)
            const dataPassada = isDataPassada(diaVencimento)
            const hoje = isHoje(diaVencimento)
            
            return (
              <div
                key={pagamento.id}
                className={`border rounded-lg overflow-hidden ${
                  pagamento.pago 
                    ? 'border-green-200 dark:border-green-800' 
                    : hoje 
                      ? 'border-yellow-200 dark:border-yellow-800' 
                      : dataPassada 
                        ? 'border-red-200 dark:border-red-800'
                        : 'border-gray-200 dark:border-gray-700'
                }`}
              >
                <div 
                  className={`flex items-center justify-between p-3 ${
                    pagamento.pago 
                      ? 'bg-green-50 dark:bg-green-900/20' 
                      : hoje 
                        ? 'bg-yellow-50 dark:bg-yellow-900/20' 
                        : dataPassada 
                          ? 'bg-red-50 dark:bg-red-900/20'
                          : 'bg-gray-50 dark:bg-gray-800'
                  }`}
                >
                  <div className="flex items-center">
                    <div className="w-8 h-8 flex items-center justify-center bg-white dark:bg-gray-700 rounded-full mr-3 font-medium">
                      {pagamento.dataVencimento}
                    </div>
                    <div>
                      <div className="font-medium text-gray-900 dark:text-white">
                        {pagamento.descricao}
                      </div>
                      <div className="text-sm text-gray-500 dark:text-gray-400">
                        {categoria?.nome || 'Categoria não especificada'}
                      </div>
                    </div>
                  </div>
                  
                  <div className="flex items-center">
                    <div className="font-medium text-gray-900 dark:text-white mr-3">
                      {formatadorMoeda.format(pagamento.valor)}
                    </div>
                    
                    <button
                      onClick={() => marcarPagamentoComoPago(pagamento.id, !pagamento.pago)}
                      className={`p-1 rounded-full ${
                        pagamento.pago 
                          ? 'bg-green-100 text-green-600 dark:bg-green-900 dark:text-green-300' 
                          : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-300'
                      }`}
                      aria-label={pagamento.pago ? 'Marcar como não pago' : 'Marcar como pago'}
                    >
                      {pagamento.pago ? (
                        <Check className="h-5 w-5" />
                      ) : (
                        <X className="h-5 w-5" />
                      )}
                    </button>
                  </div>
                </div>
              </div>
            )
          })
        ) : (
          <div className="text-center py-6 text-gray-500 dark:text-gray-400">
            <Calendar className="h-10 w-10 mx-auto mb-2 opacity-50" />
            <p>Nenhum pagamento agendado para este mês</p>
          </div>
        )}
      </div>
      
      {/* Formulário para adicionar pagamento */}
      {mostrarFormulario ? (
        <div className="border border-gray-200 dark:border-gray-700 rounded-lg p-3 mt-3">
          <div className="space-y-3">
            <div>
              <label htmlFor="pagamentoDescricao" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Descrição
              </label>
              <input
                id="pagamentoDescricao"
                type="text"
                value={novoPagamento.descricao}
                onChange={e => setNovoPagamento({ ...novoPagamento, descricao: e.target.value })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                placeholder="Ex: Aluguel"
              />
            </div>
            
            <div>
              <label htmlFor="pagamentoValor" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Valor
              </label>
              <input
                id="pagamentoValor"
                type="number"
                value={novoPagamento.valor || ''}
                onChange={e => setNovoPagamento({ ...novoPagamento, valor: parseFloat(e.target.value) || 0 })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                placeholder="Valor"
                min="0.01"
                step="0.01"
              />
            </div>
            
            <div>
              <label htmlFor="pagamentoData" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Dia do Vencimento
              </label>
              <select
                id="pagamentoData"
                value={novoPagamento.dataVencimento}
                onChange={e => setNovoPagamento({ ...novoPagamento, dataVencimento: e.target.value })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
              >
                {diasDoMes.map(dia => (
                  <option key={dia} value={dia}>
                    {dia}
                  </option>
                ))}
              </select>
            </div>
            
            <div>
              <label htmlFor="pagamentoCategoria" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Categoria
              </label>
              <select
                id="pagamentoCategoria"
                value={novoPagamento.categoriaId}
                onChange={e => setNovoPagamento({ ...novoPagamento, categoriaId: e.target.value })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
              >
                {categorias.map(categoria => (
                  <option key={categoria.id} value={categoria.id}>
                    {categoria.nome}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex space-x-2 pt-2">
              <button
                onClick={handleAdicionarPagamento}
                className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                aria-label="Adicionar pagamento"
              >
                Adicionar
              </button>
              <button
                onClick={() => setMostrarFormulario(false)}
                className="flex-1 px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded hover:bg-gray-400 dark:hover:bg-gray-500"
                aria-label="Cancelar"
              >
                Cancelar
              </button>
            </div>
          </div>
        </div>
      ) : (
        <button
          onClick={() => setMostrarFormulario(true)}
          className="w-full px-4 py-2 flex items-center justify-center bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-md text-gray-700 dark:text-gray-300"
          aria-label="Adicionar novo pagamento"
        >
          <Plus className="h-5 w-5 mr-1" />
          Novo Pagamento
        </button>
      )}
    </div>
  )
}
</file>

<file path="app/components/financas/EnvelopesVirtuais.tsx">
'use client'

import { useState } from 'react'
import { useFinancasStore } from '@/app/stores/financasStore'
import { Plus, Edit2, Trash2, Save, X } from 'lucide-react'

export function EnvelopesVirtuais() {
  const { envelopes, adicionarEnvelope, atualizarEnvelope, removerEnvelope, registrarGastoEnvelope } = useFinancasStore()
  const [novoEnvelope, setNovoEnvelope] = useState({ nome: '', cor: '#2196F3', valorAlocado: 0 })
  const [valorGasto, setValorGasto] = useState<{id: string, valor: number} | null>(null)
  const [editando, setEditando] = useState<string | null>(null)
  const [mostrarFormulario, setMostrarFormulario] = useState(false)
  
  // Formatador para valores monetários
  const formatadorMoeda = new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  })
  
  // Lista de cores disponíveis para envelopes
  const coresPredefinidas = [
    '#FF5252', // Vermelho
    '#4CAF50', // Verde
    '#2196F3', // Azul
    '#FFC107', // Amarelo
    '#9C27B0', // Roxo
    '#FF9800', // Laranja
    '#00BCD4', // Ciano
  ]
  
  const handleAdicionarEnvelope = () => {
    if (!novoEnvelope.nome || novoEnvelope.valorAlocado <= 0) return
    
    adicionarEnvelope(
      novoEnvelope.nome,
      novoEnvelope.cor,
      novoEnvelope.valorAlocado
    )
    
    setNovoEnvelope({ nome: '', cor: '#2196F3', valorAlocado: 0 })
    setMostrarFormulario(false)
  }
  
  const iniciarEdicao = (id: string) => {
    const envelope = envelopes.find(e => e.id === id)
    if (envelope) {
      setNovoEnvelope({
        nome: envelope.nome,
        cor: envelope.cor,
        valorAlocado: envelope.valorAlocado
      })
      setEditando(id)
      setMostrarFormulario(true)
    }
  }
  
  const salvarEdicao = () => {
    if (!editando || !novoEnvelope.nome || novoEnvelope.valorAlocado <= 0) return
    
    atualizarEnvelope(
      editando,
      novoEnvelope.nome,
      novoEnvelope.cor,
      novoEnvelope.valorAlocado
    )
    
    setNovoEnvelope({ nome: '', cor: '#2196F3', valorAlocado: 0 })
    setEditando(null)
    setMostrarFormulario(false)
  }
  
  const cancelarForm = () => {
    setNovoEnvelope({ nome: '', cor: '#2196F3', valorAlocado: 0 })
    setEditando(null)
    setMostrarFormulario(false)
  }
  
  const handleRegistrarGasto = (id: string) => {
    if (!valorGasto || !valorGasto.valor || valorGasto.valor <= 0) return
    
    registrarGastoEnvelope(id, valorGasto.valor)
    setValorGasto(null)
  }
  
  return (
    <div className="space-y-4">
      {/* Visualização dos envelopes */}
      <div className="space-y-3">
        {envelopes.map(envelope => {
          const percentualUtilizado = envelope.valorAlocado > 0 
            ? (envelope.valorUtilizado / envelope.valorAlocado) * 100 
            : 0
          
          return (
            <div 
              key={envelope.id} 
              className="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden"
            >
              <div className="flex items-center justify-between p-3" style={{ backgroundColor: `${envelope.cor}20` }}>
                <div className="flex items-center">
                  <div 
                    className="w-4 h-4 mr-2 rounded-full" 
                    style={{ backgroundColor: envelope.cor }} 
                  />
                  <span className="font-medium text-gray-900 dark:text-white">
                    {envelope.nome}
                  </span>
                </div>
                <div className="flex space-x-1">
                  <button
                    onClick={() => iniciarEdicao(envelope.id)}
                    className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                    aria-label={`Editar envelope ${envelope.nome}`}
                  >
                    <Edit2 className="h-4 w-4" />
                  </button>
                  <button
                    onClick={() => removerEnvelope(envelope.id)}
                    className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                    aria-label={`Remover envelope ${envelope.nome}`}
                  >
                    <Trash2 className="h-4 w-4" />
                  </button>
                </div>
              </div>
              
              <div className="p-3">
                <div className="flex justify-between mb-1 text-sm">
                  <span>Utilizado: {formatadorMoeda.format(envelope.valorUtilizado)}</span>
                  <span>Total: {formatadorMoeda.format(envelope.valorAlocado)}</span>
                </div>
                
                {/* Barra de progresso */}
                <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-3">
                  <div 
                    className="h-2.5 rounded-full" 
                    style={{ 
                      width: `${Math.min(percentualUtilizado, 100)}%`, 
                      backgroundColor: envelope.cor 
                    }} 
                  />
                </div>
                
                {/* Registrar gasto */}
                {valorGasto && valorGasto.id === envelope.id ? (
                  <div className="flex mt-2">
                    <input
                      type="number"
                      value={valorGasto.valor || ''}
                      onChange={e => setValorGasto({ id: envelope.id, valor: parseFloat(e.target.value) || 0 })}
                      placeholder="Valor"
                      className="flex-1 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-l dark:bg-gray-700 dark:text-white text-sm"
                      min="0.01"
                      step="0.01"
                      aria-label="Valor do gasto"
                    />
                    <button
                      onClick={() => handleRegistrarGasto(envelope.id)}
                      className="px-2 py-1 bg-blue-500 text-white rounded-r hover:bg-blue-600 text-sm"
                      aria-label="Confirmar gasto"
                    >
                      <Save className="h-4 w-4" />
                    </button>
                    <button
                      onClick={() => setValorGasto(null)}
                      className="px-2 py-1 ml-1 bg-gray-500 text-white rounded hover:bg-gray-600 text-sm"
                      aria-label="Cancelar"
                    >
                      <X className="h-4 w-4" />
                    </button>
                  </div>
                ) : (
                  <button
                    onClick={() => setValorGasto({ id: envelope.id, valor: 0 })}
                    className="w-full mt-2 px-3 py-1 text-sm bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 rounded-md text-gray-600 dark:text-gray-300"
                    aria-label={`Registrar gasto no envelope ${envelope.nome}`}
                  >
                    Registrar Gasto
                  </button>
                )}
              </div>
            </div>
          )
        })}
      </div>
      
      {/* Formulário para adicionar ou editar envelope */}
      {mostrarFormulario ? (
        <div className="border border-gray-200 dark:border-gray-700 rounded-lg p-3">
          <div className="space-y-3">
            <div>
              <label htmlFor="envelopeNome" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Nome do Envelope
              </label>
              <input
                id="envelopeNome"
                type="text"
                value={novoEnvelope.nome}
                onChange={e => setNovoEnvelope({ ...novoEnvelope, nome: e.target.value })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                placeholder="Ex: Emergências"
              />
            </div>
            
            <div>
              <label htmlFor="envelopeValor" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Valor Alocado
              </label>
              <input
                id="envelopeValor"
                type="number"
                value={novoEnvelope.valorAlocado || ''}
                onChange={e => setNovoEnvelope({ ...novoEnvelope, valorAlocado: parseFloat(e.target.value) || 0 })}
                className="mt-1 w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md dark:bg-gray-700 dark:text-white"
                placeholder="Valor"
                min="0.01"
                step="0.01"
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Cor do Envelope
              </label>
              <div className="flex flex-wrap gap-2">
                {coresPredefinidas.map(cor => (
                  <button
                    key={cor}
                    type="button"
                    onClick={() => setNovoEnvelope({ ...novoEnvelope, cor })}
                    className={`w-8 h-8 rounded-full ${
                      novoEnvelope.cor === cor ? 'ring-2 ring-offset-2 ring-gray-500' : ''
                    }`}
                    style={{ backgroundColor: cor }}
                    aria-label={`Selecionar cor ${cor}`}
                  />
                ))}
              </div>
            </div>
            
            <div className="flex space-x-2 pt-2">
              {editando ? (
                <>
                  <button
                    onClick={salvarEdicao}
                    className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    aria-label="Salvar alterações no envelope"
                  >
                    Salvar
                  </button>
                  <button
                    onClick={cancelarForm}
                    className="flex-1 px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded hover:bg-gray-400 dark:hover:bg-gray-500"
                    aria-label="Cancelar edição"
                  >
                    Cancelar
                  </button>
                </>
              ) : (
                <>
                  <button
                    onClick={handleAdicionarEnvelope}
                    className="flex-1 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                    aria-label="Adicionar envelope"
                  >
                    Adicionar
                  </button>
                  <button
                    onClick={cancelarForm}
                    className="flex-1 px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 rounded hover:bg-gray-400 dark:hover:bg-gray-500"
                    aria-label="Cancelar"
                  >
                    Cancelar
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      ) : (
        <button
          onClick={() => setMostrarFormulario(true)}
          className="w-full px-4 py-2 flex items-center justify-center bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-md text-gray-700 dark:text-gray-300"
          aria-label="Adicionar novo envelope"
        >
          <Plus className="h-5 w-5 mr-1" />
          Novo Envelope
        </button>
      )}
    </div>
  )
}
</file>

<file path="app/components/financas/RastreadorGastos.tsx">
'use client'

import { useEffect, useState } from 'react'
import { useFinancasStore } from '@/app/stores/financasStore'
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts'
import { Home, ShoppingCart, Utensils, Car, Heart, Music } from 'lucide-react'

// Mapeamento de nomes de ícones para componentes Lucide
const iconesMapeados: Record<string, React.ReactNode> = {
  'home': <Home className="h-5 w-5" />,
  'shopping-cart': <ShoppingCart className="h-5 w-5" />,
  'utensils': <Utensils className="h-5 w-5" />,
  'car': <Car className="h-5 w-5" />,
  'heart': <Heart className="h-5 w-5" />,
  'music': <Music className="h-5 w-5" />,
}

// Change to default export
export default function RastreadorGastos() { 
  const { categorias, transacoes } = useFinancasStore()
  const [dadosGrafico, setDadosGrafico] = useState<Array<{ name: string; value: number; cor: string }>>([])
  const [totalGastos, setTotalGastos] = useState(0)
  
  // Calcular os dados do gráfico quando as transações ou categorias mudarem
  useEffect(() => {
    const despesas = transacoes.filter(t => t.tipo === 'despesa')
    const total = despesas.reduce((acc, t) => acc + t.valor, 0)
    setTotalGastos(total)
    
    // Agrupar transações por categoria e calcular o total por categoria
    const gastosPorCategoria: Record<string, number> = {}
    
    despesas.forEach(transacao => {
      if (!gastosPorCategoria[transacao.categoriaId]) {
        gastosPorCategoria[transacao.categoriaId] = 0
      }
      gastosPorCategoria[transacao.categoriaId] += transacao.valor
    })
    
    // Preparar os dados para o gráfico
    const dados = Object.entries(gastosPorCategoria).map(([categoriaId, valor]) => {
      const categoria = categorias.find(c => c.id === categoriaId)
      return {
        name: categoria ? categoria.nome : 'Outros',
        value: valor,
        cor: categoria ? categoria.cor : '#CCCCCC'
      }
    })
    
    setDadosGrafico(dados)
  }, [transacoes, categorias])
  
  // Formatador para valores monetários
  const formatadorMoeda = new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  })
  
  // Formatador para porcentagens
  const formatadorPorcentagem = new Intl.NumberFormat('pt-BR', {
    style: 'percent',
    minimumFractionDigits: 1,
    maximumFractionDigits: 1,
  })
  
  // Custom tooltip para o gráfico
  const CustomTooltip = ({ active, payload }: any) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload
      const percentual = data.value / totalGastos
      
      return (
        <div className="bg-white dark:bg-gray-800 p-2 border border-gray-200 dark:border-gray-700 rounded shadow-md">
          <p className="font-medium">{data.name}</p>
          <p className="text-sm">{formatadorMoeda.format(data.value)}</p>
          <p className="text-xs text-gray-500 dark:text-gray-400">
            {formatadorPorcentagem.format(percentual)}
          </p>
        </div>
      )
    }
    
    return null
  }
  
  return (
    <div className="space-y-4">
      {/* Exibir o gráfico apenas se houver dados */}
      {dadosGrafico.length > 0 ? (
        <div className="w-full h-64">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={dadosGrafico}
                cx="50%"
                cy="50%"
                labelLine={false}
                outerRadius={80}
                fill="#8884d8"
                dataKey="value"
              >
                {dadosGrafico.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.cor} />
                ))}
              </Pie>
              <Tooltip content={<CustomTooltip />} />
            </PieChart>
          </ResponsiveContainer>
        </div>
      ) : (
        <div className="flex flex-col items-center justify-center h-40 text-gray-500 dark:text-gray-400">
          <p>Sem despesas registradas</p>
          <p className="text-sm">Adicione despesas para visualizar o gráfico</p>
        </div>
      )}
      
      {/* Lista de categorias com valores */}
      <div className="space-y-2 mt-4">
        <h3 className="text-sm font-medium text-gray-900 dark:text-white mb-2">
          Total de Gastos: {formatadorMoeda.format(totalGastos)}
        </h3>
        
        {categorias.map(categoria => {
          const dadoCategoria = dadosGrafico.find(d => d.name === categoria.nome)
          const valorCategoria = dadoCategoria ? dadoCategoria.value : 0
          const percentual = totalGastos > 0 ? valorCategoria / totalGastos : 0
          
          return (
            <div 
              key={categoria.id}
              className="flex items-center justify-between p-2 rounded-lg"
              style={{ backgroundColor: `${categoria.cor}20` }}
            >
              <div className="flex items-center">
                <div className="p-1 rounded-full mr-2" style={{ backgroundColor: categoria.cor }}>
                  <span className="text-white">
                    {iconesMapeados[categoria.icone] || <ShoppingCart className="h-5 w-5" />}
                  </span>
                </div>
                <span className="font-medium text-gray-900 dark:text-white">
                  {categoria.nome}
                </span>
              </div>
              <div className="text-right">
                <div className="font-medium text-gray-900 dark:text-white">
                  {formatadorMoeda.format(valorCategoria)}
                </div>
                <div className="text-xs text-gray-500 dark:text-gray-400">
                  {formatadorPorcentagem.format(percentual)}
                </div>
              </div>
            </div>
          )
        })}
      </div>
    </div>
  )
}
</file>

<file path="app/components/hiperfocos/ConversorInteresses.tsx">
'use client'

import { useState, useRef, FormEvent } from 'react'
import { Rocket, CheckCircle, PlusCircle, X, Save } from 'lucide-react'
import { useHiperfocosStore, CORES_HIPERFOCOS } from '../../stores/hiperfocosStore'

export function ConversorInteresses() {
  const { adicionarHiperfoco, adicionarTarefa } = useHiperfocosStore()
  
  const [formData, setFormData] = useState({
    titulo: '',
    descricao: '',
    corSelecionada: CORES_HIPERFOCOS[0],
    tempoLimite: '',
    novasTarefas: [''] // Iniciar com um campo vazio
  })
  
  const [feedback, setFeedback] = useState<{
    tipo: 'sucesso' | 'erro',
    mensagem: string
  } | null>(null)
  
  const formRef = useRef<HTMLFormElement>(null)
  
  // Função para adicionar mais campos de tarefas
  const adicionarCampoTarefa = () => {
    setFormData({
      ...formData,
      novasTarefas: [...formData.novasTarefas, '']
    })
  }
  
  // Função para atualizar uma tarefa específica
  const atualizarTarefa = (index: number, valor: string) => {
    const tarefasAtualizadas = [...formData.novasTarefas]
    tarefasAtualizadas[index] = valor
    
    setFormData({
      ...formData,
      novasTarefas: tarefasAtualizadas
    })
  }
  
  // Função para remover uma tarefa
  const removerTarefa = (index: number) => {
    const tarefasAtualizadas = formData.novasTarefas.filter((_, i) => i !== index)
    
    setFormData({
      ...formData,
      novasTarefas: tarefasAtualizadas
    })
  }
  
  // Função para lidar com o envio do formulário
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    
    // Validação
    if (!formData.titulo) {
      setFeedback({
        tipo: 'erro',
        mensagem: 'O título do hiperfoco é obrigatório'
      })
      return
    }
    
    if (formData.novasTarefas.filter(t => t.trim() !== '').length === 0) {
      setFeedback({
        tipo: 'erro',
        mensagem: 'Adicione pelo menos uma tarefa'
      })
      return
    }
    
    try {
      // Criar um novo hiperfoco
      const tempoLimiteInt = formData.tempoLimite ? parseInt(formData.tempoLimite) : undefined
      const hiperfocoId = adicionarHiperfoco(
        formData.titulo,
        formData.descricao,
        formData.corSelecionada,
        tempoLimiteInt
      )
      
      // Adicionar as tarefas ao hiperfoco
      formData.novasTarefas
        .filter(tarefa => tarefa.trim() !== '')
        .forEach(tarefa => {
          adicionarTarefa(hiperfocoId, tarefa)
        })
      
      // Feedback de sucesso
      setFeedback({
        tipo: 'sucesso',
        mensagem: 'Hiperfoco criado com sucesso!'
      })
      
      // Limpar o formulário
      setFormData({
        titulo: '',
        descricao: '',
        corSelecionada: CORES_HIPERFOCOS[0],
        tempoLimite: '',
        novasTarefas: ['']
      })
      
      // Timer para remover o feedback
      setTimeout(() => {
        setFeedback(null)
      }, 3000)
    } catch (error) {
      setFeedback({
        tipo: 'erro',
        mensagem: 'Ocorreu um erro ao criar o hiperfoco'
      })
    }
  }
  
  return (
    <div>
      <div className="flex items-center mb-4">
        <Rocket className="h-6 w-6 text-hiperfocos-primary mr-2" aria-hidden="true" />
        <h2 className="text-xl font-semibold text-gray-800 dark:text-white">
          Conversor de Interesses
        </h2>
      </div>
      
      <p className="text-gray-600 dark:text-gray-300 mb-6">
        Transforme um interesse intenso em um projeto estruturado com tarefas claras e objetivas.
      </p>
      
      {feedback && (
        <div 
          className={`mb-4 p-3 rounded-md ${
            feedback.tipo === 'sucesso' 
              ? 'bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100' 
              : 'bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100'
          }`}
          role="alert"
        >
          {feedback.tipo === 'sucesso' ? (
            <CheckCircle className="h-5 w-5 inline mr-2" aria-hidden="true" />
          ) : (
            <X className="h-5 w-5 inline mr-2" aria-hidden="true" />
          )}
          {feedback.mensagem}
        </div>
      )}
      
      <form ref={formRef} onSubmit={handleSubmit} className="space-y-6">
        {/* Informações básicas do hiperfoco */}
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div>
            <label 
              htmlFor="titulo" 
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Título do Interesse/Hiperfoco *
            </label>
            <input
              type="text"
              id="titulo"
              name="titulo"
              value={formData.titulo}
              onChange={(e) => setFormData({ ...formData, titulo: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              aria-required="true"
            />
          </div>
          
          <div>
            <label 
              htmlFor="tempoLimite" 
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Tempo Limite (em minutos, opcional)
            </label>
            <input
              type="number"
              id="tempoLimite"
              name="tempoLimite"
              value={formData.tempoLimite}
              onChange={(e) => setFormData({ ...formData, tempoLimite: e.target.value })}
              min="1"
              placeholder="Ex: 60"
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            />
          </div>
        </div>
        
        <div>
          <label 
            htmlFor="descricao" 
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            Descrição
          </label>
          <textarea
            id="descricao"
            name="descricao"
            value={formData.descricao}
            onChange={(e) => setFormData({ ...formData, descricao: e.target.value })}
            rows={3}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            placeholder="Descreva seu interesse ou hiperfoco"
          />
        </div>
        
        {/* Seleção de cor */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            Cor do Hiperfoco
          </label>
          <div className="flex gap-2 flex-wrap">
            {CORES_HIPERFOCOS.map((cor) => (
              <button
                key={cor}
                type="button"
                onClick={() => setFormData({ ...formData, corSelecionada: cor })}
                className={`w-8 h-8 rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary ${
                  formData.corSelecionada === cor ? 'ring-2 ring-offset-2 ring-hiperfocos-primary' : ''
                }`}
                style={{ backgroundColor: cor }}
                aria-label={`Cor ${cor}`}
                aria-pressed={formData.corSelecionada === cor}
              />
            ))}
          </div>
        </div>
        
        {/* Lista de tarefas */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            Decomposição em Tarefas *
          </label>
          
          <div className="space-y-3">
            {formData.novasTarefas.map((tarefa, index) => (
              <div key={index} className="flex gap-2">
                <input
                  type="text"
                  value={tarefa}
                  onChange={(e) => atualizarTarefa(index, e.target.value)}
                  className="flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  placeholder={`Tarefa ${index + 1}`}
                  aria-label={`Tarefa ${index + 1}`}
                />
                
                <button
                  type="button"
                  onClick={() => removerTarefa(index)}
                  className="p-2 text-gray-500 rounded-md hover:bg-gray-100 hover:text-gray-700 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
                  aria-label="Remover tarefa"
                  disabled={formData.novasTarefas.length <= 1}
                >
                  <X className="h-5 w-5" aria-hidden="true" />
                </button>
              </div>
            ))}
          </div>
          
          <button
            type="button"
            onClick={adicionarCampoTarefa}
            className="mt-3 flex items-center text-hiperfocos-primary hover:text-hiperfocos-secondary"
            aria-label="Adicionar mais uma tarefa"
          >
            <PlusCircle className="h-5 w-5 mr-1" aria-hidden="true" />
            Adicionar mais uma tarefa
          </button>
        </div>
        
        {/* Botão de envio */}
        <div className="flex justify-end">
          <button
            type="submit"
            className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-hiperfocos-primary hover:bg-hiperfocos-secondary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary"
            aria-label="Converter interesse em hiperfoco"
          >
            <Save className="h-5 w-5 mr-2" aria-hidden="true" />
            Converter em Hiperfoco
          </button>
        </div>
      </form>
    </div>
  )
}
</file>

<file path="app/components/hiperfocos/SistemaAlternancia.tsx">
'use client'

import { useState, FormEvent } from 'react'
import { ArrowRightCircle, Clock, Plus, Check, AlertCircle, RefreshCcw } from 'lucide-react'
import { useHiperfocosStore, type SessaoAlternancia, type Hiperfoco } from '../../stores/hiperfocosStore'
import { format, parseISO, isAfter, addMinutes } from 'date-fns'
import { ptBR } from 'date-fns/locale'

export function SistemaAlternancia() {
  const { 
    hiperfocos, 
    sessoes, 
    adicionarSessao, 
    alternarHiperfoco, 
    concluirSessao, 
    removerSessao 
  } = useHiperfocosStore()
  
  const [novaAlternancia, setNovaAlternancia] = useState({
    titulo: '',
    hiperfocoId: '',
    tempoEstimado: ''
  })
  
  const [mostrarFormulario, setMostrarFormulario] = useState(false)
  const [feedbackMsg, setFeedbackMsg] = useState<string | null>(null)
  
  // Obter sessões ativas (não concluídas)
  const sessoesAtivas = sessoes.filter(sessao => !sessao.concluida)
  
  // Manipular o envio do formulário
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    
    if (!novaAlternancia.titulo || !novaAlternancia.hiperfocoId || !novaAlternancia.tempoEstimado) {
      setFeedbackMsg('Por favor, preencha todos os campos')
      return
    }
    
    const tempoEstimadoInt = parseInt(novaAlternancia.tempoEstimado)
    if (isNaN(tempoEstimadoInt) || tempoEstimadoInt <= 0) {
      setFeedbackMsg('Tempo estimado inválido')
      return
    }
    
    try {
      adicionarSessao(
        novaAlternancia.titulo,
        novaAlternancia.hiperfocoId,
        tempoEstimadoInt
      )
      
      // Limpar o formulário
      setNovaAlternancia({
        titulo: '',
        hiperfocoId: '',
        tempoEstimado: ''
      })
      
      setMostrarFormulario(false)
      setFeedbackMsg(null)
    } catch (error) {
      setFeedbackMsg('Erro ao criar a sessão')
    }
  }
  
  // Obter o nome de um hiperfoco pelo ID
  const getHiperfocoNome = (id: string | null): string => {
    if (!id) return 'Nenhum'
    
    const hiperfoco = hiperfocos.find(h => h.id === id)
    return hiperfoco ? hiperfoco.titulo : 'Desconhecido'
  }
  
  // Verificar se uma sessão está atrasada
  const isSessionOverdue = (sessao: SessaoAlternancia): boolean => {
    const inicioDate = parseISO(sessao.tempoInicio)
    const limiteDate = addMinutes(inicioDate, sessao.duracaoEstimada)
    return isAfter(new Date(), limiteDate)
  }
  
  // Alternar para um novo hiperfoco
  const handleAlternarHiperfoco = (sessaoId: string, hiperfocoId: string) => {
    alternarHiperfoco(sessaoId, hiperfocoId)
  }
  
  return (
    <div>
      <div className="flex items-center mb-4">
        <RefreshCcw className="h-6 w-6 text-hiperfocos-primary mr-2" aria-hidden="true" />
        <h2 className="text-xl font-semibold text-gray-800 dark:text-white">
          Sistema de Alternância
        </h2>
      </div>
      
      <p className="text-gray-600 dark:text-gray-300 mb-6">
        Gerencie transições entre diferentes hiperfocos para reduzir o impacto das mudanças de contexto.
      </p>
      
      {/* Mostrar feedback se houver */}
      {feedbackMsg && (
        <div className="bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100 p-3 rounded-md mb-4">
          <AlertCircle className="h-5 w-5 inline mr-2" aria-hidden="true" />
          {feedbackMsg}
        </div>
      )}
      
      {/* Sessões ativas */}
      {sessoesAtivas.length > 0 ? (
        <div className="space-y-4 mb-6">
          <h3 className="text-lg font-medium text-gray-800 dark:text-white">
            Sessões de Alternância Ativas
          </h3>
          
          {sessoesAtivas.map((sessao) => {
            const isOverdue = isSessionOverdue(sessao)
            const hiperfocoAtual = hiperfocos.find(h => h.id === sessao.hiperfocoAtual)
            
            return (
              <div 
                key={sessao.id} 
                className={`bg-white dark:bg-gray-700 rounded-lg shadow-sm p-4 border-l-4 ${
                  isOverdue ? 'border-amber-500' : 'border-hiperfocos-primary'
                }`}
              >
                <div className="flex justify-between items-start mb-3">
                  <div>
                    <h4 className="font-medium text-gray-800 dark:text-white">
                      {sessao.titulo}
                    </h4>
                    <p className="text-sm text-gray-500 dark:text-gray-400">
                      <Clock className="h-4 w-4 inline mr-1" aria-hidden="true" />
                      Iniciado: {format(parseISO(sessao.tempoInicio), "dd 'de' MMMM', às' HH:mm", { locale: ptBR })}
                    </p>
                  </div>
                  
                  <div className="flex space-x-2">
                    <button
                      onClick={() => concluirSessao(sessao.id)}
                      className="p-1.5 text-green-600 hover:bg-green-50 rounded-md dark:text-green-400 dark:hover:bg-gray-600"
                      aria-label="Marcar como concluída"
                    >
                      <Check className="h-5 w-5" aria-hidden="true" />
                    </button>
                  </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Hiperfoco atual */}
                  <div className="bg-gray-50 dark:bg-gray-800 p-3 rounded-md">
                    <span className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">
                      Hiperfoco Atual
                    </span>
                    <div 
                      className="px-3 py-1.5 rounded-md text-sm font-medium"
                      style={{ 
                        backgroundColor: hiperfocoAtual ? `${hiperfocoAtual.cor}20` : 'transparent',
                        color: hiperfocoAtual ? hiperfocoAtual.cor : 'inherit' 
                      }}
                    >
                      {getHiperfocoNome(sessao.hiperfocoAtual)}
                    </div>
                  </div>
                  
                  {/* Alternância */}
                  <div className="bg-gray-50 dark:bg-gray-800 p-3 rounded-md">
                    <span className="text-sm font-medium text-gray-500 dark:text-gray-400 block mb-1">
                      Alternar para
                    </span>
                    <select
                      className="w-full px-3 py-1.5 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white text-sm"
                      value=""
                      onChange={(e) => handleAlternarHiperfoco(sessao.id, e.target.value)}
                      aria-label="Selecionar novo hiperfoco"
                    >
                      <option value="" disabled>Escolha um hiperfoco</option>
                      {hiperfocos
                        .filter(h => h.id !== sessao.hiperfocoAtual)
                        .map(hiperfoco => (
                          <option key={hiperfoco.id} value={hiperfoco.id}>
                            {hiperfoco.titulo}
                          </option>
                        ))
                      }
                    </select>
                  </div>
                </div>
                
                {/* Hiperfoco anterior (se houver) */}
                {sessao.hiperfocoAnterior && (
                  <div className="mt-3 text-sm text-gray-500 dark:text-gray-400">
                    <ArrowRightCircle className="h-4 w-4 inline mr-1" aria-hidden="true" />
                    Alternou de: {getHiperfocoNome(sessao.hiperfocoAnterior)}
                  </div>
                )}
                
                {/* Mostrar alerta se estiver atrasado */}
                {isOverdue && (
                  <div className="mt-3 text-sm text-amber-500 dark:text-amber-400">
                    <AlertCircle className="h-4 w-4 inline mr-1" aria-hidden="true" />
                    Tempo estimado excedido! ({sessao.duracaoEstimada} minutos)
                  </div>
                )}
              </div>
            )
          })}
        </div>
      ) : (
        <div className="text-center py-8 text-gray-500 dark:text-gray-400 mb-6">
          <p>Nenhuma sessão de alternância ativa no momento.</p>
        </div>
      )}
      
      {/* Formulário para adicionar nova sessão */}
      {mostrarFormulario ? (
        <form onSubmit={handleSubmit} className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg mb-6">
          <h3 className="text-lg font-medium text-gray-800 dark:text-white mb-4">
            Nova Sessão de Alternância
          </h3>
          
          <div className="space-y-4">
            <div>
              <label 
                htmlFor="titulo" 
                className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
              >
                Título da Sessão
              </label>
              <input
                type="text"
                id="titulo"
                value={novaAlternancia.titulo}
                onChange={(e) => setNovaAlternancia({ ...novaAlternancia, titulo: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                placeholder="Ex: Sessão de estudo"
              />
            </div>
            
            <div>
              <label 
                htmlFor="hiperfoco" 
                className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
              >
                Hiperfoco Inicial
              </label>
              <select
                id="hiperfoco"
                value={novaAlternancia.hiperfocoId}
                onChange={(e) => setNovaAlternancia({ ...novaAlternancia, hiperfocoId: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              >
                <option value="">Selecione um hiperfoco</option>
                {hiperfocos.map(hiperfoco => (
                  <option key={hiperfoco.id} value={hiperfoco.id}>
                    {hiperfoco.titulo}
                  </option>
                ))}
              </select>
            </div>
            
            <div>
              <label 
                htmlFor="tempoEstimado" 
                className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
              >
                Tempo Estimado (minutos)
              </label>
              <input
                type="number"
                id="tempoEstimado"
                value={novaAlternancia.tempoEstimado}
                onChange={(e) => setNovaAlternancia({ ...novaAlternancia, tempoEstimado: e.target.value })}
                min="1"
                className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                placeholder="Ex: 30"
              />
            </div>
          </div>
          
          <div className="mt-4 flex justify-end space-x-3">
            <button
              type="button"
              onClick={() => setMostrarFormulario(false)}
              className="px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary dark:bg-gray-600 dark:text-white dark:border-gray-700 dark:hover:bg-gray-700"
            >
              Cancelar
            </button>
            <button
              type="submit"
              className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-hiperfocos-primary hover:bg-hiperfocos-secondary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary"
            >
              Iniciar Sessão
            </button>
          </div>
        </form>
      ) : (
        <button
          onClick={() => setMostrarFormulario(true)}
          className="flex items-center px-4 py-2 mb-6 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-hiperfocos-primary hover:bg-hiperfocos-secondary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-hiperfocos-primary"
          disabled={hiperfocos.length === 0}
        >
          <Plus className="h-5 w-5 mr-2" aria-hidden="true" />
          Nova Sessão de Alternância
        </button>
      )}
      
      {hiperfocos.length === 0 && (
        <div className="text-center py-4 text-gray-500 dark:text-gray-400 border border-dashed border-gray-300 dark:border-gray-600 rounded-md">
          <p>
            Para criar uma sessão de alternância, primeiro crie hiperfocos
            <br />na guia &quot;Conversor de Interesses&quot;.
          </p>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/components/hiperfocos/TemporizadorFoco.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { useHiperfocosStore } from '../../stores/hiperfocosStore'
import { Clock, Play, Pause, RotateCcw, Bell, Volume2, VolumeX } from 'lucide-react'

export function TemporizadorFoco() {
  const { hiperfocos } = useHiperfocosStore()
  
  const [hiperfocoSelecionadoId, setHiperfocoSelecionadoId] = useState<string>('')
  const [temporizadorAtivo, setTemporizadorAtivo] = useState(false)
  const [tempoRestante, setTempoRestante] = useState(0)
  const [tempoTotal, setTempoTotal] = useState(0)
  const [tempoPausa, setTempoPausa] = useState(0)
  const [tempoPersonalizado, setTempoPersonalizado] = useState('')
  const [somAtivado, setSomAtivado] = useState(true)
  
  const audioRef = useRef<HTMLAudioElement | null>(null)
  const timerRef = useRef<NodeJS.Timeout | null>(null)
  
  // Lidar com a seleção de hiperfoco
  useEffect(() => {
    if (!hiperfocoSelecionadoId) return
    
    const hiperfoco = hiperfocos.find(h => h.id === hiperfocoSelecionadoId)
    
    if (hiperfoco && hiperfoco.tempoLimite) {
      setTempoTotal(hiperfoco.tempoLimite * 60) // converter minutos para segundos
      setTempoRestante(hiperfoco.tempoLimite * 60)
      setTempoPausa(Math.floor(hiperfoco.tempoLimite * 60 * 0.1)) // 10% do tempo total para pausas
    } else {
      // Tempo padrão de 25 minutos (pomodoro)
      setTempoTotal(25 * 60)
      setTempoRestante(25 * 60)
      setTempoPausa(5 * 60) // 5 minutos de pausa
    }
    
    // Parar temporizador se estiver ativo
    if (temporizadorAtivo) {
      pararTemporizador()
    }
  }, [hiperfocoSelecionadoId, hiperfocos])
  
  // Limpar timer ao desmontar componente
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
    }
  }, [])
  
  // Iniciar temporizador
  const iniciarTemporizador = () => {
    if (!hiperfocoSelecionadoId) return
    
    setTemporizadorAtivo(true)
    
    timerRef.current = setInterval(() => {
      setTempoRestante(prev => {
        if (prev <= 1) {
          // Temporizador chegou a zero
          tocarAlarme()
          pararTemporizador()
          return 0
        }
        return prev - 1
      })
    }, 1000)
  }
  
  // Parar temporizador
  const pararTemporizador = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current)
      timerRef.current = null
    }
    setTemporizadorAtivo(false)
  }
  
  // Pausar/Resumir temporizador
  const toggleTemporizador = () => {
    if (temporizadorAtivo) {
      pararTemporizador()
    } else {
      iniciarTemporizador()
    }
  }
  
  // Reiniciar temporizador
  const reiniciarTemporizador = () => {
    pararTemporizador()
    setTempoRestante(tempoTotal)
  }
  
  // Tocar som de alarme
  const tocarAlarme = () => {
    if (!somAtivado) return
    
    if (audioRef.current) {
      audioRef.current.currentTime = 0
      audioRef.current.play().catch(e => console.error('Erro ao tocar alarme:', e))
    }
  }
  
  // Formatar tempo para exibição (minutos:segundos)
  const formatarTempo = (segundos: number) => {
    const mins = Math.floor(segundos / 60)
    const segs = segundos % 60
    return `${mins.toString().padStart(2, '0')}:${segs.toString().padStart(2, '0')}`
  }
  
  // Calcular percentual de progresso
  const calcularProgresso = () => {
    if (tempoTotal === 0) return 0
    return ((tempoTotal - tempoRestante) / tempoTotal) * 100
  }
  
  // Configurar tempo personalizado
  const definirTempoPersonalizado = () => {
    const minutos = parseInt(tempoPersonalizado)
    if (isNaN(minutos) || minutos <= 0) return
    
    pararTemporizador()
    const segundos = minutos * 60
    setTempoTotal(segundos)
    setTempoRestante(segundos)
    setTempoPausa(Math.floor(segundos * 0.1)) // 10% do tempo para pausas
    setTempoPersonalizado('')
  }
  
  // Iniciar tempo de pausa
  const iniciarPausa = () => {
    pararTemporizador()
    setTempoRestante(tempoPausa)
    setTempoTotal(tempoPausa)
  }
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-6">
        Temporizador de Foco
      </h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="bg-white dark:bg-gray-700 rounded-lg shadow-sm p-6">
          {/* Seletor de hiperfoco */}
          <div className="mb-6">
            <label htmlFor="hiperfoco-select" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Hiperfoco para temporizador
            </label>
            <select
              id="hiperfoco-select"
              value={hiperfocoSelecionadoId}
              onChange={(e) => setHiperfocoSelecionadoId(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            >
              <option value="">Selecione um hiperfoco</option>
              {hiperfocos.map((hiperfoco) => (
                <option key={hiperfoco.id} value={hiperfoco.id}>
                  {hiperfoco.titulo} {hiperfoco.tempoLimite ? `(${hiperfoco.tempoLimite} min)` : ''}
                </option>
              ))}
            </select>
          </div>
          
          {/* Tempo personalizado */}
          <div className="mb-6">
            <label htmlFor="tempo-personalizado" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Tempo personalizado (minutos)
            </label>
            <div className="flex">
              <input
                type="number"
                id="tempo-personalizado"
                value={tempoPersonalizado}
                onChange={(e) => setTempoPersonalizado(e.target.value)}
                min="1"
                className="flex-1 px-3 py-2 border border-gray-300 rounded-l-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                placeholder="Ex: 30"
              />
              <button
                onClick={definirTempoPersonalizado}
                className="px-4 py-2 bg-hiperfocos-primary text-white rounded-r-md hover:bg-hiperfocos-secondary"
                aria-label="Definir tempo personalizado"
              >
                Definir
              </button>
            </div>
          </div>
          
          {/* Áudio para o alarme */}
          <audio ref={audioRef} preload="auto">
            <source src="/sounds/alarm.mp3" type="audio/mpeg" />
            <source src="/sounds/alarm.ogg" type="audio/ogg" />
            Seu navegador não suporta o elemento de áudio.
          </audio>
          
          {/* Controle de som */}
          <div className="flex items-center justify-between mb-3">
            <span className="text-sm text-gray-600 dark:text-gray-300">
              Som de alarme
            </span>
            <button
              onClick={() => setSomAtivado(!somAtivado)}
              className={`p-2 rounded-md ${somAtivado ? 'text-hiperfocos-primary' : 'text-gray-400'}`}
              aria-label={somAtivado ? 'Desativar som' : 'Ativar som'}
              aria-pressed={somAtivado}
            >
              {somAtivado ? <Volume2 className="h-5 w-5" /> : <VolumeX className="h-5 w-5" />}
            </button>
          </div>
        </div>
        
        <div className="bg-white dark:bg-gray-700 rounded-lg shadow-sm p-6 flex flex-col items-center justify-center">
          {/* Display do temporizador */}
          <div className="relative w-48 h-48 mb-6">
            <div 
              className="absolute inset-0 rounded-full bg-gray-200 dark:bg-gray-600"
              style={{
                background: `conic-gradient(
                  ${hiperfocoSelecionadoId && hiperfocos.find(h => h.id === hiperfocoSelecionadoId)?.cor || '#0EA5E9'} ${calcularProgresso()}%, 
                  #9CA3AF ${calcularProgresso()}%
                )`
              }}
            />
            <div className="absolute inset-2 rounded-full bg-white dark:bg-gray-700 flex items-center justify-center">
              <div className="text-4xl font-bold text-gray-800 dark:text-white">
                {formatarTempo(tempoRestante)}
              </div>
            </div>
          </div>
          
          {/* Controles do temporizador */}
          <div className="flex space-x-4">
            <button
              onClick={toggleTemporizador}
              disabled={!hiperfocoSelecionadoId && tempoTotal === 0}
              className="p-3 bg-hiperfocos-primary text-white rounded-full hover:bg-hiperfocos-secondary disabled:opacity-50 disabled:cursor-not-allowed"
              aria-label={temporizadorAtivo ? 'Pausar temporizador' : 'Iniciar temporizador'}
            >
              {temporizadorAtivo ? <Pause className="h-6 w-6" /> : <Play className="h-6 w-6" />}
            </button>
            
            <button
              onClick={reiniciarTemporizador}
              disabled={tempoTotal === 0}
              className="p-3 bg-gray-200 text-gray-700 rounded-full hover:bg-gray-300 dark:bg-gray-600 dark:text-gray-200 dark:hover:bg-gray-500 disabled:opacity-50 disabled:cursor-not-allowed"
              aria-label="Reiniciar temporizador"
            >
              <RotateCcw className="h-6 w-6" />
            </button>
            
            <button
              onClick={iniciarPausa}
              disabled={!hiperfocoSelecionadoId && tempoTotal === 0}
              className="p-3 bg-hiperfocos-light text-hiperfocos-primary rounded-full hover:bg-opacity-80 disabled:opacity-50 disabled:cursor-not-allowed"
              aria-label="Iniciar pausa"
            >
              <Bell className="h-6 w-6" />
            </button>
          </div>
          
          {/* Status do temporizador */}
          <div className="mt-4 text-sm text-gray-600 dark:text-gray-300">
            {temporizadorAtivo ? 'Temporizador ativo' : 'Temporizador parado'}
          </div>
        </div>
      </div>
      
      {/* Nota explicativa */}
      <div className="mt-6 p-4 bg-blue-50 text-blue-800 dark:bg-blue-900 dark:text-blue-100 rounded-md">
        <h3 className="font-medium mb-2 flex items-center">
          <Clock className="h-5 w-5 mr-2" />
          Dica para gerenciar o tempo
        </h3>
        <p className="text-sm">
          Utilizar temporizadores ajuda a manter o foco e evitar o hiperfoco prolongado. 
          Defina intervalos de trabalho e pausa regulares para melhorar a produtividade.
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/components/hiperfocos/VisualizadorProjetos.tsx">
'use client'

import { useState } from 'react'
import { useHiperfocosStore, type Hiperfoco, type Tarefa } from '../../stores/hiperfocosStore'
import { ChevronDown, ChevronRight, Plus, Edit, Trash2, Check } from 'lucide-react'

export function VisualizadorProjetos() {
  const { 
    hiperfocos, 
    adicionarSubTarefa, 
    toggleTarefaConcluida, 
    toggleSubTarefaConcluida, 
    atualizarTarefa,
    atualizarSubTarefa,
    removerTarefa,
    removerSubTarefa
  } = useHiperfocosStore()
  
  const [hiperfocoAtivo, setHiperfocoAtivo] = useState<string | null>(
    hiperfocos.length > 0 ? hiperfocos[0].id : null
  )
  
  const [expandidas, setExpandidas] = useState<Record<string, boolean>>({})
  const [novaTarefaTexto, setNovaTarefaTexto] = useState<Record<string, string>>({})
  const [editando, setEditando] = useState<Record<string, boolean>>({})
  const [textoEdicao, setTextoEdicao] = useState<Record<string, string>>({})
  
  // Alterna a expansão de uma tarefa
  const toggleExpand = (tarefaId: string) => {
    setExpandidas(prev => ({
      ...prev,
      [tarefaId]: !prev[tarefaId]
    }))
  }
  
  // Inicia a edição de uma tarefa
  const iniciarEdicao = (id: string, texto: string) => {
    setEditando(prev => ({ ...prev, [id]: true }))
    setTextoEdicao(prev => ({ ...prev, [id]: texto }))
  }
  
  // Salva a edição de uma tarefa
  const salvarEdicao = (hiperfocoId: string, tarefaId: string, tipo: 'tarefa' | 'subtarefa', tarefaPaiId?: string) => {
    if (!textoEdicao[tarefaId] || textoEdicao[tarefaId].trim() === '') return
    
    if (tipo === 'tarefa') {
      atualizarTarefa(hiperfocoId, tarefaId, textoEdicao[tarefaId])
    } else if (tipo === 'subtarefa' && tarefaPaiId) {
      atualizarSubTarefa(hiperfocoId, tarefaPaiId, tarefaId, textoEdicao[tarefaId])
    }
    
    setEditando(prev => ({ ...prev, [tarefaId]: false }))
  }
  
  // Adiciona uma nova subtarefa
  const handleAddSubtarefa = (hiperfocoId: string, tarefaId: string) => {
    const texto = novaTarefaTexto[tarefaId]
    if (!texto || texto.trim() === '') return
    
    adicionarSubTarefa(hiperfocoId, tarefaId, texto)
    
    // Limpar o input e expandir a tarefa pai
    setNovaTarefaTexto(prev => ({ ...prev, [tarefaId]: '' }))
    setExpandidas(prev => ({ ...prev, [tarefaId]: true }))
  }
  
  // Renderiza uma tarefa com suas subtarefas
  const renderizarTarefa = (hiperfoco: Hiperfoco, tarefa: Tarefa) => {
    const isExpanded = expandidas[tarefa.id] || false
    const temSubtarefas = hiperfoco.subTarefas[tarefa.id]?.length > 0
    const isEditing = editando[tarefa.id] || false
    
    return (
      <div 
        key={tarefa.id}
        className="border-l-2 pl-3 my-2"
        style={{ borderColor: hiperfoco.cor }}
      >
        <div className="flex items-center">
          {/* Expandir/Colapsar */}
          <button
            onClick={() => toggleExpand(tarefa.id)}
            className={`p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-white ${!temSubtarefas && 'invisible'}`}
            aria-label={isExpanded ? 'Colapsar' : 'Expandir'}
          >
            {isExpanded ? 
              <ChevronDown className="h-4 w-4" aria-hidden="true" /> : 
              <ChevronRight className="h-4 w-4" aria-hidden="true" />
            }
          </button>
          
          {/* Checkbox */}
          <button
            onClick={() => toggleTarefaConcluida(hiperfoco.id, tarefa.id)}
            className={`p-1 rounded-md mr-2 ${
              tarefa.concluida 
                ? 'bg-green-100 text-green-600 dark:bg-green-800 dark:text-green-200' 
                : 'bg-gray-100 text-gray-400 dark:bg-gray-700 dark:text-gray-400'
            }`}
            aria-label={tarefa.concluida ? 'Marcar como não concluída' : 'Marcar como concluída'}
            aria-pressed={tarefa.concluida}
          >
            <Check className="h-4 w-4" aria-hidden="true" />
          </button>
          
          {/* Conteúdo da tarefa */}
          {isEditing ? (
            <input
              type="text"
              value={textoEdicao[tarefa.id] || ''}
              onChange={(e) => setTextoEdicao({ ...textoEdicao, [tarefa.id]: e.target.value })}
              onBlur={() => salvarEdicao(hiperfoco.id, tarefa.id, 'tarefa')}
              onKeyDown={(e) => e.key === 'Enter' && salvarEdicao(hiperfoco.id, tarefa.id, 'tarefa')}
              className="flex-1 px-2 py-1 border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              autoFocus
            />
          ) : (
            <span className={`flex-1 text-sm ${tarefa.concluida ? 'line-through text-gray-500 dark:text-gray-400' : 'text-gray-700 dark:text-gray-200'}`}>
              {tarefa.texto}
            </span>
          )}
          
          {/* Ações */}
          <div className="flex space-x-1 ml-2">
            <button
              onClick={() => iniciarEdicao(tarefa.id, tarefa.texto)}
              className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-white"
              aria-label="Editar tarefa"
            >
              <Edit className="h-4 w-4" aria-hidden="true" />
            </button>
            <button
              onClick={() => removerTarefa(hiperfoco.id, tarefa.id)}
              className="p-1 text-gray-500 hover:text-red-500 dark:text-gray-400 dark:hover:text-red-400"
              aria-label="Remover tarefa"
            >
              <Trash2 className="h-4 w-4" aria-hidden="true" />
            </button>
          </div>
        </div>
        
        {/* Sub-tarefas */}
        {isExpanded && (
          <div className="ml-6 mt-2">
            {/* Lista de subtarefas */}
            {(hiperfoco.subTarefas[tarefa.id] || []).map((subTarefa) => {
              const isSubEditing = editando[subTarefa.id] || false
              
              return (
                <div key={subTarefa.id} className="flex items-center mb-2">
                  <button
                    onClick={() => toggleSubTarefaConcluida(hiperfoco.id, tarefa.id, subTarefa.id)}
                    className={`p-1 rounded-md mr-2 ${
                      subTarefa.concluida 
                        ? 'bg-green-100 text-green-600 dark:bg-green-800 dark:text-green-200' 
                        : 'bg-gray-100 text-gray-400 dark:bg-gray-700 dark:text-gray-400'
                    }`}
                    aria-label={subTarefa.concluida ? 'Marcar como não concluída' : 'Marcar como concluída'}
                    aria-pressed={subTarefa.concluida}
                  >
                    <Check className="h-3 w-3" aria-hidden="true" />
                  </button>
                  
                  {isSubEditing ? (
                    <input
                      type="text"
                      value={textoEdicao[subTarefa.id] || ''}
                      onChange={(e) => setTextoEdicao({ ...textoEdicao, [subTarefa.id]: e.target.value })}
                      onBlur={() => salvarEdicao(hiperfoco.id, subTarefa.id, 'subtarefa', tarefa.id)}
                      onKeyDown={(e) => e.key === 'Enter' && salvarEdicao(hiperfoco.id, subTarefa.id, 'subtarefa', tarefa.id)}
                      className="flex-1 px-2 py-1 text-sm border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                      autoFocus
                    />
                  ) : (
                    <span className={`flex-1 text-xs ${subTarefa.concluida ? 'line-through text-gray-500 dark:text-gray-400' : 'text-gray-600 dark:text-gray-300'}`}>
                      {subTarefa.texto}
                    </span>
                  )}
                  
                  <div className="flex space-x-1 ml-2">
                    <button
                      onClick={() => iniciarEdicao(subTarefa.id, subTarefa.texto)}
                      className="p-0.5 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-white"
                      aria-label="Editar subtarefa"
                    >
                      <Edit className="h-3 w-3" aria-hidden="true" />
                    </button>
                    <button
                      onClick={() => removerSubTarefa(hiperfoco.id, tarefa.id, subTarefa.id)}
                      className="p-0.5 text-gray-500 hover:text-red-500 dark:text-gray-400 dark:hover:text-red-400"
                      aria-label="Remover subtarefa"
                    >
                      <Trash2 className="h-3 w-3" aria-hidden="true" />
                    </button>
                  </div>
                </div>
              )
            })}
            
            {/* Campo para adicionar nova subtarefa */}
            <div className="flex items-center mt-2">
              <input
                type="text"
                value={novaTarefaTexto[tarefa.id] || ''}
                onChange={(e) => setNovaTarefaTexto({ ...novaTarefaTexto, [tarefa.id]: e.target.value })}
                onKeyDown={(e) => e.key === 'Enter' && handleAddSubtarefa(hiperfoco.id, tarefa.id)}
                placeholder="Nova sub-tarefa..."
                className="flex-1 px-2 py-1 text-xs border border-gray-300 rounded-l-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                aria-label="Nova sub-tarefa"
              />
              <button
                onClick={() => handleAddSubtarefa(hiperfoco.id, tarefa.id)}
                className="px-2 py-1 bg-hiperfocos-primary text-white rounded-r-md hover:bg-hiperfocos-secondary"
                aria-label="Adicionar sub-tarefa"
              >
                <Plus className="h-3 w-3" aria-hidden="true" />
              </button>
            </div>
          </div>
        )}
      </div>
    )
  }
  
  // Obter o hiperfoco ativo
  const hiperfocoSelecionado = hiperfocos.find(h => h.id === hiperfocoAtivo) || null
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-4">
        Visualização em Árvore de Projetos
      </h2>
      
      {hiperfocos.length > 0 ? (
        <div>
          {/* Seletor de hiperfoco */}
          <div className="mb-6">
            <label htmlFor="hiperfoco-select" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Selecione um Hiperfoco
            </label>
            <select
              id="hiperfoco-select"
              value={hiperfocoAtivo || ''}
              onChange={(e) => setHiperfocoAtivo(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-hiperfocos-primary focus:border-hiperfocos-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            >
              {hiperfocos.map((hiperfoco) => (
                <option key={hiperfoco.id} value={hiperfoco.id}>
                  {hiperfoco.titulo}
                </option>
              ))}
            </select>
          </div>
          
          {hiperfocoSelecionado && (
            <div>
              {/* Cabeçalho do hiperfoco */}
              <div 
                className="mb-4 p-3 rounded-md"
                style={{ backgroundColor: `${hiperfocoSelecionado.cor}20` }}
              >
                <h3 
                  className="text-lg font-medium mb-1"
                  style={{ color: hiperfocoSelecionado.cor }}
                >
                  {hiperfocoSelecionado.titulo}
                </h3>
                {hiperfocoSelecionado.descricao && (
                  <p className="text-sm text-gray-600 dark:text-gray-300">
                    {hiperfocoSelecionado.descricao}
                  </p>
                )}
                
                <div className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                  {hiperfocoSelecionado.tarefas.filter(t => t.concluida).length} de {hiperfocoSelecionado.tarefas.length} tarefas concluídas
                </div>
              </div>
              
              {/* Árvore de tarefas */}
              <div className="bg-white dark:bg-gray-700 rounded-lg shadow-sm p-4">
                {hiperfocoSelecionado.tarefas.length > 0 ? (
                  <div>
                    {hiperfocoSelecionado.tarefas.map((tarefa) => renderizarTarefa(hiperfocoSelecionado, tarefa))}
                  </div>
                ) : (
                  <p className="text-center py-4 text-gray-500 dark:text-gray-400">
                    Este hiperfoco não possui tarefas.
                  </p>
                )}
              </div>
            </div>
          )}
        </div>
      ) : (
        <div className="text-center py-8 text-gray-500 dark:text-gray-400 border border-dashed border-gray-300 dark:border-gray-600 rounded-md">
          <p>
            Nenhum hiperfoco encontrado. Crie seu primeiro hiperfoco na guia &quot;Conversor de Interesses&quot;.
          </p>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/components/inicio/ChecklistMedicamentos.tsx">
'use client'

import { useMemo } from 'react'
import { Pill, CheckCircle2, Circle } from 'lucide-react'
import { useAppStore } from '@/app/store'
import { Medicamento } from '@/app/store'

export function ChecklistMedicamentos() {
  const { medicamentos, registrarTomadaMedicamento } = useAppStore(
    (state) => ({
      medicamentos: state.medicamentos || [],
      registrarTomadaMedicamento: state.registrarTomadaMedicamento
    })
  )
  
  // Filtrar apenas medicamentos diários
  const medicamentosDiarios = useMemo(() => {
    return medicamentos
      .filter((med: Medicamento) => med.frequencia === 'Diária')
      .sort((a: Medicamento, b: Medicamento) => a.nome.localeCompare(b.nome))
  }, [medicamentos])
  
  // Verificar se o medicamento foi tomado hoje
  const foiTomadoHoje = (medicamento: Medicamento): boolean => {
    if (!medicamento.ultimaTomada) return false
    
    const hoje = new Date().toISOString().split('T')[0]
    return medicamento.ultimaTomada.includes(hoje)
  }
  
  // Agrupar medicamentos por tipo
  const medicamentosPorTipo = useMemo(() => {
    const grupos: Record<string, Medicamento[]> = {
      'Anfetaminas': [],
      'Antidepressivos': [],
      'Suplementos': [],
      'Outros': []
    }
    
    medicamentosDiarios.forEach((med: Medicamento) => {
      // Lógica simplificada para categorização baseada no nome ou observações
      const nome = med.nome.toLowerCase()
      const obs = (med.observacoes || '').toLowerCase()
      
      if (nome.includes('venvanse') || nome.includes('ritalina') || 
          nome.includes('concerta') || nome.includes('adderall') || 
          obs.includes('anfetamina')) {
        grupos['Anfetaminas'].push(med)
      } 
      else if (nome.includes('prozac') || nome.includes('fluoxetina') || 
               nome.includes('sertralina') || nome.includes('escitalopram') ||
               nome.includes('paroxetina') || obs.includes('antidepressivo')) {
        grupos['Antidepressivos'].push(med)
      }
      else if (nome.includes('vitamina') || nome.includes('mineral') || 
               nome.includes('omega') || nome.includes('ômega') || 
               nome.includes('suplemento') || obs.includes('suplemento')) {
        grupos['Suplementos'].push(med)
      }
      else {
        grupos['Outros'].push(med)
      }
    })
    
    // Remover categorias vazias
    return Object.fromEntries(
      Object.entries(grupos).filter(([_, meds]) => meds.length > 0)
    )
  }, [medicamentosDiarios])
  
  // Registrar tomada de medicamento
  const handleToggleTomado = (id: string) => {
    const dataHora = new Date().toISOString()
    registrarTomadaMedicamento(id, dataHora)
  }
  
  // Se não houver medicamentos diários
  if (medicamentosDiarios.length === 0) {
    return (
      <div className="text-center text-gray-500 dark:text-gray-400 py-2">
        Nenhum medicamento diário cadastrado
      </div>
    )
  }
  
  return (
    <div className="space-y-3">
      <div className="flex items-center text-sm text-gray-600 dark:text-gray-300 mb-1">
        <Pill className="h-4 w-4 mr-1" />
        <h3 className="font-medium">Checklist de Medicamentos</h3>
      </div>
      
      <div className="space-y-4">
        {Object.entries(medicamentosPorTipo).map(([tipo, meds]) => (
          <div key={tipo} className="space-y-1">
            {Object.keys(medicamentosPorTipo).length > 1 && (
              <h4 className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">
                {tipo}
              </h4>
            )}
            
            <div className="space-y-1">
              {meds.map((medicamento: Medicamento) => {
                const tomadoHoje = foiTomadoHoje(medicamento)
                
                return (
                  <div 
                    key={medicamento.id}
                    className={`flex items-center p-2 rounded-md transition-colors ${
                      tomadoHoje 
                        ? 'bg-green-50 dark:bg-green-900/20' 
                        : 'bg-white dark:bg-gray-800'
                    }`}
                  >
                    <button
                      onClick={() => handleToggleTomado(medicamento.id)}
                      className="mr-2 text-green-600 dark:text-green-400 focus:outline-none"
                      aria-label={tomadoHoje ? 'Marcar como não tomado' : 'Marcar como tomado'}
                    >
                      {tomadoHoje ? (
                        <CheckCircle2 className="h-5 w-5" />
                      ) : (
                        <Circle className="h-5 w-5" />
                      )}
                    </button>
                    
                    <div className="flex-1">
                      <span className={`text-sm ${
                        tomadoHoje 
                          ? 'text-gray-500 dark:text-gray-400 line-through' 
                          : 'text-gray-800 dark:text-white'
                      }`}>
                        {medicamento.nome}
                      </span>
                      
                      {medicamento.dosagem && (
                        <span className="ml-1 text-xs text-gray-500 dark:text-gray-400">
                          ({medicamento.dosagem})
                        </span>
                      )}
                    </div>
                  </div>
                )
              })}
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}
</file>

<file path="app/components/inicio/LembretePausas.tsx">
'use client'

import { useState, useEffect } from 'react'
import { Play, Pause, RefreshCw } from 'lucide-react'

export function LembretePausas() {
  const [isActive, setIsActive] = useState(false)
  const [isPaused, setIsPaused] = useState(true)
  const [time, setTime] = useState(25 * 60) // 25 minutos em segundos
  const [ciclo, setCiclo] = useState('foco')

  useEffect(() => {
    let interval: NodeJS.Timeout | null = null

    if (isActive && !isPaused) {
      interval = setInterval(() => {
        setTime((time) => {
          if (time <= 1) {
            // Alternar entre ciclos de foco e pausa
            if (ciclo === 'foco') {
              setCiclo('pausa')
              return 5 * 60 // 5 minutos de pausa
            } else {
              setCiclo('foco')
              return 25 * 60 // 25 minutos de foco
            }
          }
          return time - 1
        })
      }, 1000)
    } else {
      interval && clearInterval(interval)
    }

    return () => {
      interval && clearInterval(interval)
    }
  }, [isActive, isPaused, ciclo])

  const formatTime = () => {
    const minutes = Math.floor(time / 60)
    const seconds = time % 60
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
  }

  const handleStart = () => {
    setIsActive(true)
    setIsPaused(false)
  }

  const handlePause = () => {
    setIsPaused(true)
  }

  const handleReset = () => {
    setIsActive(false)
    setIsPaused(true)
    setCiclo('foco')
    setTime(25 * 60)
  }

  // Determinar a cor com base no ciclo atual
  const cicloColor = ciclo === 'foco' 
    ? 'text-estudos-primary' 
    : 'text-lazer-primary'

  // Determinar a mensagem com base no ciclo atual
  const cicloMensagem = ciclo === 'foco'
    ? 'Tempo de foco'
    : 'Tempo de pausa'

  return (
    <div className="flex flex-col items-center">
      <div className="text-center mb-4">
        <h3 className={`text-xl font-bold ${cicloColor}`}>{cicloMensagem}</h3>
        <p className="text-gray-600 dark:text-gray-400 text-sm">
          Alterne entre períodos de foco e pausas curtas
        </p>
      </div>

      <div className="text-4xl font-mono font-bold mb-6 bg-gray-100 dark:bg-gray-700 px-6 py-3 rounded-xl">
        {formatTime()}
      </div>

      <div className="flex space-x-4">
        {isPaused ? (
          <button
            onClick={handleStart}
            className="flex items-center px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500"
            aria-label="Iniciar temporizador"
          >
            <Play className="h-5 w-5 mr-1" />
            <span>Iniciar</span>
          </button>
        ) : (
          <button
            onClick={handlePause}
            className="flex items-center px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 focus:outline-none focus:ring-2 focus:ring-yellow-500"
            aria-label="Pausar temporizador"
          >
            <Pause className="h-5 w-5 mr-1" />
            <span>Pausar</span>
          </button>
        )}

        <button
          onClick={handleReset}
          className="flex items-center px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
          aria-label="Reiniciar temporizador"
        >
          <RefreshCw className="h-5 w-5 mr-1" />
          <span>Reiniciar</span>
        </button>
      </div>

      <div className="mt-6 text-sm text-gray-600 dark:text-gray-400">
        <p>Dicas:</p>
        <ul className="list-disc pl-5 mt-1">
          <li>Durante o foco, concentre-se em uma única tarefa</li>
          <li>Use as pausas para alongar-se ou beber água</li>
          <li>Ajuste os tempos conforme sua necessidade</li>
        </ul>
      </div>
    </div>
  )
}
</file>

<file path="app/components/inicio/ListaPrioridades.tsx">
'use client'

import { useState, useEffect } from 'react';
import Link from 'next/link'; // Importar Link
import { CheckCircle2, Circle, PlusCircle, Edit2, Calendar, ChevronLeft, ChevronRight, X, Award } from 'lucide-react'; // Importar Award
import { Button } from '@/app/components/ui/Button';
import { Input } from '@/app/components/ui/Input';
import { Modal } from '@/app/components/ui/Modal'
import { Badge } from '@/app/components/ui/Badge'
import { usePrioridadesStore, Prioridade } from '@/app/stores/prioridadesStore'

export function ListaPrioridades() {
  const { 
    prioridades, 
    adicionarPrioridade, 
    editarPrioridade, 
    removerPrioridade, 
    toggleConcluida, 
    getHistoricoPorData,
    getDatasPrioridades
  } = usePrioridadesStore()
  
  const [novoTexto, setNovoTexto] = useState('')
  const [prioridadeEditando, setPrioridadeEditando] = useState<Prioridade | null>(null)
  const [textoEditando, setTextoEditando] = useState('')
  const [showHistory, setShowHistory] = useState(false)
  const [dataAtual, setDataAtual] = useState(new Date().toISOString().split('T')[0])
  const [prioridadesExibidas, setPrioridadesExibidas] = useState<Prioridade[]>([])
  const [datasHistorico, setDatasHistorico] = useState<string[]>([])

  // Carregar prioridades do dia atual
  useEffect(() => {
    const prioridadesDoDia = getHistoricoPorData(dataAtual)
    setPrioridadesExibidas(prioridadesDoDia)
  }, [prioridades, dataAtual, getHistoricoPorData])

  // Carregar datas disponíveis no histórico
  useEffect(() => {
    const datas = getDatasPrioridades()
    setDatasHistorico(datas)
  }, [prioridades, getDatasPrioridades])

  // Verifica se estamos vendo o dia atual
  const isToday = () => {
    const hoje = new Date().toISOString().split('T')[0]
    return dataAtual === hoje
  }

  // Funções para navegação no histórico
  const irParaDataAnterior = () => {
    const indexAtual = datasHistorico.indexOf(dataAtual)
    if (indexAtual < datasHistorico.length - 1) {
      setDataAtual(datasHistorico[indexAtual + 1])
    }
  }

  const irParaDataProxima = () => {
    const indexAtual = datasHistorico.indexOf(dataAtual)
    if (indexAtual > 0) {
      setDataAtual(datasHistorico[indexAtual - 1])
    }
  }

  const voltarParaHoje = () => {
    setDataAtual(new Date().toISOString().split('T')[0])
  }

  // Função para adicionar nova prioridade
  const handleAdicionarPrioridade = () => {
    if (!novoTexto.trim() || prioridadesExibidas.length >= 3) return
    
    adicionarPrioridade({
      texto: novoTexto,
      concluida: false
    })
    
    setNovoTexto('')
  }

  // Função para iniciar edição
  const iniciarEdicao = (prioridade: Prioridade) => {
    setPrioridadeEditando(prioridade)
    setTextoEditando(prioridade.texto)
  }

  // Função para salvar edição
  const salvarEdicao = () => {
    if (prioridadeEditando && textoEditando.trim()) {
      editarPrioridade(prioridadeEditando.id, textoEditando)
      setPrioridadeEditando(null)
    }
  }

  // Função para cancelar edição
  const cancelarEdicao = () => {
    setPrioridadeEditando(null)
  }

  // Formatar data para exibição (DD/MM/YYYY)
  const formatarData = (dataISO: string) => {
    const partes = dataISO.split('-')
    return `${partes[2]}/${partes[1]}/${partes[0]}`
  }

  return (
    <div className="space-y-4">
      {/* Cabeçalho com controles de histórico */}
      <div className="flex justify-between items-center mb-2">
        <Button 
          variant="ghost" 
          size="sm" 
          onClick={() => setShowHistory(!showHistory)}
          aria-label={showHistory ? "Esconder histórico" : "Mostrar histórico"}
        >
          <Calendar className="h-4 w-4 mr-1" />
          {showHistory ? 'Esconder Histórico' : 'Ver Histórico'}
        </Button>
        
        {isToday() ? (
          <Badge>Hoje</Badge>
        ) : (
          <Badge variant="secondary">{formatarData(dataAtual)}</Badge>
        )}
      </div>

      {/* Controles de navegação no histórico */}
      {showHistory && (
        <div className="flex items-center justify-between bg-gray-50 dark:bg-gray-800 p-2 rounded-lg mb-3">
          <Button 
            variant="ghost" 
            size="sm" 
            onClick={irParaDataAnterior}
            disabled={datasHistorico.indexOf(dataAtual) >= datasHistorico.length - 1}
            aria-label="Data anterior"
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
          
          <div className="text-sm font-medium">
            {formatarData(dataAtual)}
            {!isToday() && (
              <Button 
                variant="link" 
                size="sm" 
                className="ml-2 underline text-blue-600 dark:text-blue-400"
                onClick={voltarParaHoje}
              >
                Voltar para hoje
              </Button>
            )}
          </div>
          
          <Button 
            variant="ghost" 
            size="sm" 
            onClick={irParaDataProxima}
            disabled={datasHistorico.indexOf(dataAtual) <= 0}
            aria-label="Próxima data"
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      )}

      {/* Lista de prioridades */}
      <div className="space-y-2">
        {prioridadesExibidas.length === 0 ? (
          <div className="text-center py-6 text-gray-500 dark:text-gray-400">
            {isToday() ? (
              <p>Nenhuma prioridade definida para hoje.</p>
            ) : (
              <p>Nenhuma prioridade registrada para esta data.</p>
            )}
          </div>
        ) : (
          prioridadesExibidas.map((prioridade) => (
            <div
              key={prioridade.id}
              className={`flex items-center p-3 rounded-lg transition-colors duration-200 ${
                prioridade.concluida
                  ? 'bg-green-50 dark:bg-green-900/20'
                  : 'bg-white dark:bg-gray-800'
              }`}
            >
              {isToday() && (
                <button
                  onClick={() => toggleConcluida(prioridade.id)}
                  className="mr-3 text-green-600 dark:text-green-400 focus:outline-none"
                  aria-label={prioridade.concluida ? 'Marcar como não concluída' : 'Marcar como concluída'}
                >
                  {prioridade.concluida ? (
                    <CheckCircle2 className="h-6 w-6" />
                  ) : (
                    <Circle className="h-6 w-6" />
                  )}
                </button>
              )}

              {/* Ícone para prioridade de concurso */}
              {prioridade.tipo === 'concurso' && (
                <Award className="h-5 w-5 mr-2 text-indigo-600 flex-shrink-0" />
              )}

              {/* Texto da prioridade, com link se for de concurso */}
              <span
                className={`flex-1 ${
                  prioridade.concluida
                    ? 'text-gray-500 dark:text-gray-400 line-through'
                    : 'text-gray-900 dark:text-white'
                }`}
              >
                {prioridade.tipo === 'concurso' && prioridade.origemId ? (
                  <Link href={`/concursos/${prioridade.origemId}`} className="hover:underline">
                    {prioridade.texto}
                  </Link>
                ) : (
                  prioridade.texto
                )}
              </span>

              {isToday() && prioridade.tipo !== 'concurso' && ( // Não permite editar prioridades de concurso diretamente aqui
                <button
                  onClick={() => iniciarEdicao(prioridade)}
                  className="ml-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 focus:outline-none"
                  aria-label="Editar prioridade"
                >
                  <Edit2 className="h-4 w-4" />
                </button>
              )}
            </div>
          ))
        )}
      </div>

      {/* Input para adicionar nova prioridade (apenas no dia atual) */}
      {isToday() && prioridadesExibidas.length < 3 && (
        <div className="flex items-center mt-4">
          <Input
            type="text"
            value={novoTexto}
            onChange={(e) => setNovoTexto(e.target.value)}
            placeholder="Nova prioridade..."
            className="flex-1"
            maxLength={50}
          />
          <Button
            onClick={handleAdicionarPrioridade}
            className="ml-2"
            aria-label="Adicionar prioridade"
          >
            <PlusCircle className="h-5 w-5" />
          </Button>
        </div>
      )}

      {/* Mensagem quando atingir o limite de prioridades */}
      {isToday() && prioridadesExibidas.length >= 3 && (
        <p className="text-sm text-gray-500 dark:text-gray-400 italic">
          Máximo de 3 prioridades para manter o foco.
        </p>
      )}

      {/* Modal de edição */}
      {prioridadeEditando && (
        <Modal
          isOpen={!!prioridadeEditando}
          title="Editar Prioridade"
          onClose={cancelarEdicao}
        >
          <div className="space-y-4">
            <Input
              value={textoEditando}
              onChange={(e) => setTextoEditando(e.target.value)}
              placeholder="Texto da prioridade"
              maxLength={50}
            />
            
            <div className="flex justify-end space-x-2">
              <Button variant="outline" onClick={cancelarEdicao}>
                Cancelar
              </Button>
              <Button onClick={salvarEdicao} disabled={!textoEditando.trim()}>
                Salvar
              </Button>
            </div>
          </div>
        </Modal>
      )}
    </div>
  )
}
</file>

<file path="app/components/inicio/PainelDia.tsx">
'use client'

import { useState } from 'react'
import { Edit2, Check, X, Trash2, Plus } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Input } from '@/app/components/ui/Input'
import { usePainelDiaStore, BlocoTempo } from '@/app/stores/painelDiaStore'

export function PainelDia() {
  const { blocos, editarAtividade, editarCategoria, adicionarBloco, removerBloco } = usePainelDiaStore()
  const [blocoEditando, setBlocoEditando] = useState<string | null>(null)
  const [atividadeEditando, setAtividadeEditando] = useState('')
  const [novoBloco, setNovoBloco] = useState(false)
  const [novaHora, setNovaHora] = useState('')
  const [novaAtividade, setNovaAtividade] = useState('')
  
  // Função para obter a cor de fundo baseada na categoria
  const getBgColor = (categoria: BlocoTempo['categoria']) => {
    switch (categoria) {
      case 'inicio':
        return 'bg-opacity-40 bg-inicio-light border-inicio-primary'
      case 'alimentacao':
        return 'bg-opacity-40 bg-alimentacao-light border-alimentacao-primary'
      case 'estudos':
        return 'bg-opacity-40 bg-estudos-light border-estudos-primary'
      case 'saude':
        return 'bg-opacity-40 bg-saude-light border-saude-primary'
      case 'lazer':
        return 'bg-opacity-40 bg-lazer-light border-lazer-primary'
      default:
        return 'bg-gray-100 bg-opacity-40 border-gray-300 dark:bg-gray-700 dark:border-gray-600'
    }
  }

  // Iniciar edição de um bloco
  const iniciarEdicao = (bloco: BlocoTempo) => {
    setBlocoEditando(bloco.id)
    setAtividadeEditando(bloco.atividade)
  }

  // Salvar a edição de um bloco
  const salvarEdicao = () => {
    if (blocoEditando) {
      editarAtividade(blocoEditando, atividadeEditando)
      cancelarEdicao()
    }
  }

  // Cancelar a edição
  const cancelarEdicao = () => {
    setBlocoEditando(null)
    setAtividadeEditando('')
  }

  // Função para mostrar o formulário de novo bloco
  const mostrarNovoBloco = () => {
    setNovoBloco(true)
    setNovaHora('')
    setNovaAtividade('')
  }

  // Função para adicionar um novo bloco
  const adicionarNovoBloco = () => {
    if (novaHora && novaAtividade) {
      const id = `${Date.now()}`
      adicionarBloco({
        id,
        hora: novaHora,
        atividade: novaAtividade,
        categoria: 'nenhuma'
      })
      setNovoBloco(false)
      setNovaHora('')
      setNovaAtividade('')
    }
  }

  // Função para cancelar a adição de novo bloco
  const cancelarNovoBloco = () => {
    setNovoBloco(false)
    setNovaHora('')
    setNovaAtividade('')
  }

  // Ordenar blocos por hora
  const blocosOrdenados = [...blocos].sort((a, b) => {
    const horaA = a.hora.split(':').map(Number);
    const horaB = b.hora.split(':').map(Number);
    
    if (horaA[0] !== horaB[0]) {
      return horaA[0] - horaB[0];
    }
    return horaA[1] - horaB[1];
  });

  return (
    <div className="space-y-3">
      <div className="flex justify-end">
        <Button 
          size="sm" 
          variant="outline" 
          onClick={mostrarNovoBloco}
          className="flex items-center gap-1"
          aria-label="Adicionar novo horário"
        >
          <Plus className="h-4 w-4" /> Adicionar Horário
        </Button>
      </div>

      {novoBloco && (
        <div className="p-3 rounded-lg border border-gray-200 dark:border-gray-700 mb-3">
          <div className="flex flex-col gap-3">
            <div className="flex gap-2 items-center">
              <Input
                type="time"
                value={novaHora}
                onChange={(e) => setNovaHora(e.target.value)}
                className="w-24"
                placeholder="Hora"
                aria-label="Nova hora"
              />
              <Input
                value={novaAtividade}
                onChange={(e) => setNovaAtividade(e.target.value)}
                className="flex-1"
                placeholder="O que você planeja fazer neste horário?"
                aria-label="Nova atividade"
              />
            </div>
            <div className="flex justify-end gap-2">
              <Button
                size="sm"
                variant="outline"
                onClick={cancelarNovoBloco}
              >
                Cancelar
              </Button>
              <Button
                size="sm"
                onClick={adicionarNovoBloco}
                disabled={!novaHora || !novaAtividade}
              >
                Adicionar
              </Button>
            </div>
          </div>
        </div>
      )}

      <div className="grid grid-cols-1 gap-2">
        {blocosOrdenados.map((bloco) => (
          <div
            key={bloco.id}
            className={`p-3 rounded-lg border-l-4 ${getBgColor(bloco.categoria)} transition-all duration-200 backdrop-blur-sm group`}
          >
            <div className="flex items-center">
              <span className="font-medium text-gray-700 dark:text-gray-300 w-16">
                {bloco.hora}
              </span>
              
              {blocoEditando === bloco.id ? (
                <div className="flex-1 flex items-center gap-2">
                  <Input
                    value={atividadeEditando}
                    onChange={(e) => setAtividadeEditando(e.target.value)}
                    className="flex-1"
                    placeholder="O que você planeja fazer neste horário?"
                    aria-label="Editar atividade"
                    autoFocus
                  />
                  <div className="flex gap-1">
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={salvarEdicao}
                      aria-label="Salvar edição"
                    >
                      <Check className="h-4 w-4 text-green-500" />
                    </Button>
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={cancelarEdicao}
                      aria-label="Cancelar edição"
                    >
                      <X className="h-4 w-4 text-red-500" />
                    </Button>
                  </div>
                </div>
              ) : (
                <>
                  <span className="flex-1 text-gray-900 dark:text-white">
                    {bloco.atividade}
                  </span>
                  <div className="flex gap-1 opacity-0 group-hover:opacity-100">
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={() => iniciarEdicao(bloco)}
                      aria-label="Editar este horário"
                    >
                      <Edit2 className="h-4 w-4 text-gray-500" />
                    </Button>
                    <Button
                      size="sm"
                      variant="ghost"
                      onClick={() => removerBloco(bloco.id)}
                      aria-label="Remover este horário"
                    >
                      <Trash2 className="h-4 w-4 text-red-500" />
                    </Button>
                  </div>
                </>
              )}
            </div>
            
            {blocoEditando === bloco.id && (
              <div className="mt-2 flex flex-wrap gap-1">
                <span className="text-xs text-gray-500 dark:text-gray-400 mr-2">
                  Categoria:
                </span>
                <div className="flex flex-wrap gap-1">
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'alimentacao' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs bg-alimentacao-light text-alimentacao-primary border-alimentacao-primary"
                    onClick={() => editarCategoria(bloco.id, 'alimentacao')}
                  >
                    Alimentação
                  </Button>
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'estudos' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs bg-estudos-light text-estudos-primary border-estudos-primary"
                    onClick={() => editarCategoria(bloco.id, 'estudos')}
                  >
                    Estudos
                  </Button>
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'saude' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs bg-saude-light text-saude-primary border-saude-primary"
                    onClick={() => editarCategoria(bloco.id, 'saude')}
                  >
                    Saúde
                  </Button>
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'lazer' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs bg-lazer-light text-lazer-primary border-lazer-primary"
                    onClick={() => editarCategoria(bloco.id, 'lazer')}
                  >
                    Lazer
                  </Button>
                  <Button
                    size="sm"
                    variant={bloco.categoria === 'nenhuma' ? 'default' : 'outline'}
                    className="py-0 px-2 h-6 text-xs"
                    onClick={() => editarCategoria(bloco.id, 'nenhuma')}
                  >
                    Nenhuma
                  </Button>
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  )
}
</file>

<file path="app/components/inicio/ProximaProvaCard.tsx">
'use client';

import React from 'react';
import Link from 'next/link';
import { useConcursosStore, Concurso } from '@/app/stores/concursosStore';
import { Card } from '@/app/components/ui/Card';
import { Button } from '@/app/components/ui/Button';
import { CalendarCheck, ArrowRight } from 'lucide-react';
import { format, differenceInDays, isFuture } from 'date-fns';
import { ptBR } from 'date-fns/locale';

// Função para calcular e formatar a contagem regressiva
const formatCountdown = (dataProva: string): string => {
  const hoje = new Date();
  const provaDate = new Date(dataProva);
  const diasRestantes = differenceInDays(provaDate, hoje);

  if (diasRestantes < 0) {
    return 'Prova realizada';
  } else if (diasRestantes === 0) {
    return 'Prova é hoje!';
  } else if (diasRestantes === 1) {
    return 'Falta 1 dia';
  } else {
    return `Faltam ${diasRestantes} dias`;
  }
};

export function ProximaProvaCard() {
  const { concursos } = useConcursosStore();

  // Filtra concursos futuros e ordena pelos mais próximos
  const proximasProvas = concursos
    .filter(c => isFuture(new Date(c.dataProva)))
    .sort((a, b) => new Date(a.dataProva).getTime() - new Date(b.dataProva).getTime())
    .slice(0, 3); // Limita a 3 provas no card, por exemplo

  if (proximasProvas.length === 0) {
    // Pode retornar null ou uma mensagem indicando que não há provas futuras
    return null;
    // Ou:
    // return (
    //   <Card className="p-4 text-center text-gray-500">
    //     Nenhuma prova futura cadastrada.
    //   </Card>
    // );
  }

  return (
    <Card className="p-4">
      <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
        <CalendarCheck size={20} className="text-indigo-600" />
        Próximas Provas
      </h3>
      <div className="space-y-3">
        {proximasProvas.map((prova) => (
          <div key={prova.id} className="flex justify-between items-center border-b pb-2 last:border-b-0 last:pb-0">
            <div>
              <p className="font-medium">{prova.titulo}</p>
              <p className="text-sm text-gray-500">
                {format(new Date(prova.dataProva), 'dd/MM/yyyy', { locale: ptBR })}
              </p>
            </div>
            <div className="text-right">
               <p className="text-sm font-semibold text-indigo-600">{formatCountdown(prova.dataProva)}</p>
               <Link href={`/concursos/${prova.id}`} passHref>
                 <Button variant="link" size="sm" className="h-auto p-0 text-xs">
                   Ver detalhes <ArrowRight size={12} className="ml-1" />
                 </Button>
               </Link>
            </div>
          </div>
        ))}
      </div>
    </Card>
  );
}
</file>

<file path="app/components/layout/Footer.tsx">
'use client'

import Link from 'next/link'
import Image from 'next/image'

export function Footer() {
  return (
    <footer className="border-t border-gray-200 dark:border-gray-700 py-4 mt-8">
      <div className="container mx-auto px-4">
        <div className="flex flex-col items-center space-y-4">
          <div className="text-center text-sm text-gray-600 dark:text-gray-400 max-w-3xl">
            <p className="italic">
              "Whāia te iti kahurangi, ki te tuohu koe, me he maunga teitei" - 
              <span className="block sm:inline"> Provérbio da língua Māori</span>
            </p>
            <p className="mt-1 text-xs">
              Tradução: "Busque o tesouro que você mais valoriza, se você inclinar a cabeça, que seja para uma montanha elevada."
            </p>
          </div>
          
          <Link 
            href="https://github.com/cvaraujo12/stayfocus"
            target="_blank"
            rel="noopener noreferrer"
            className="text-gray-700 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
            aria-label="GitHub repository"
          >
            <div className="flex items-center space-x-2">
              <Image
                src="/images/cat-icon.svg"
                alt="GitHub"
                width={24}
                height={24}
                className="text-current"
              />
              <span className="text-xs">StayFocus GitHub</span>
            </div>
          </Link>
        </div>
      </div>
    </footer>
  )
}
</file>

<file path="app/components/layout/Header.tsx">
'use client'

import { useState, useEffect } from 'react'
import { Menu, X, Sun, Moon, HelpCircle, Anchor } from 'lucide-react'
import { useTheme } from 'next-themes'
import { Sidebar } from './Sidebar'
import Link from 'next/link'

export function Header() {
  const [sidebarOpen, setSidebarOpen] = useState(false)
  const { theme, setTheme } = useTheme()
  const [mounted, setMounted] = useState(false)
  
  // Garantir que o componente foi montado no cliente antes de renderizar ícones dinâmicos
  useEffect(() => {
    setMounted(true)
  }, [])

  const toggleTheme = () => {
    setTheme(theme === 'dark' ? 'light' : 'dark')
  }

  // Função para abrir o sidebar
  const openSidebar = () => {
    setSidebarOpen(true)
  }

  // Função para fechar o sidebar
  const closeSidebar = () => {
    setSidebarOpen(false)
  }

  return (
    <>
      {/* Sidebar controlável */}
      {sidebarOpen && (
        <Sidebar onClose={closeSidebar} />
      )}
      
      {/* Header fixo no topo */}
      <header className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 shadow-sm">
        <div className="flex items-center justify-between h-16 px-4">
          {/* Logo e menu button */}
          <div className="flex items-center">
            <button
              type="button"
              className="inline-flex items-center justify-center p-2 rounded-md text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              onClick={openSidebar}
              aria-label="Abrir menu"
            >
              <Menu className="h-6 w-6" aria-hidden="true" />
            </button>
            <div className="ml-3 flex items-center">
              <span className="sr-only">StayFocus</span>
            </div>
          </div>

          {/* Controles */}
          <div className="flex items-center space-x-3">
            {/* Ícone Zzz para Sono */}
            <Link href="/sono">
              <button
                className="p-2 rounded-full text-sono-primary hover:bg-sono-light focus:outline-none focus:ring-2 focus:ring-sono-primary"
                aria-label="Gestão do Sono"
              >
                {mounted ? (
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    aria-hidden="true"
                    className="h-5 w-5"
                    suppressHydrationWarning
                  >
                    <path d="M2 4v16"></path>
                    <path d="M2 8h18a2 2 0 0 1 2 2v10"></path>
                    <path d="M2 17h20"></path>
                    <path d="M6 8v9"></path>
                  </svg>
                ) : (
                  <div className="h-5 w-5" />
                )}
              </button>
            </Link>
            
            {/* Ícone de Âncora para Autoconhecimento */}
            <Link href="/autoconhecimento">
              <button
                className="p-2 rounded-full text-autoconhecimento-primary hover:bg-autoconhecimento-light focus:outline-none focus:ring-2 focus:ring-autoconhecimento-primary"
                aria-label="Notas de Autoconhecimento"
              >
                {mounted ? <Anchor className="h-5 w-5" aria-hidden="true" /> : <div className="h-5 w-5" />}
              </button>
            </Link>
            
            {/* Theme toggle */}
            <button
              onClick={toggleTheme}
              className="p-2 rounded-full text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              aria-label={theme === 'dark' ? 'Mudar para tema claro' : 'Mudar para tema escuro'}
              suppressHydrationWarning
            >
              {mounted && (
                theme === 'dark' ? (
                  <Sun className="h-5 w-5" aria-hidden="true" />
                ) : (
                  <Moon className="h-5 w-5" aria-hidden="true" />
                )
              )}
              {!mounted && <div className="h-5 w-5" />}
            </button>

            {/* Help button */}
            <Link href="/roadmap">
              <button
                className="p-2 rounded-full text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                aria-label="Roadmap e Ajuda"
              >
                {mounted ? <HelpCircle className="h-5 w-5" aria-hidden="true" /> : <div className="h-5 w-5" />}
              </button>
            </Link>

            {/* User profile */}
            <Link href="/perfil">
              <button 
                className="h-8 w-8 rounded-full bg-perfil-primary hover:bg-perfil-secondary text-white flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-perfil-primary"
                aria-label="Informações Pessoais"
              >
                <span className="text-sm font-medium">U</span>
              </button>
            </Link>
          </div>
        </div>
      </header>
    </>
  )
}
</file>

<file path="app/components/layout/Sidebar.tsx">
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { Home, Utensils, Book, BookOpen, Heart, Smile, DollarSign, Rocket, X } from 'lucide-react'
import { NavItem } from '@/app/types'

const navItems: NavItem[] = [
  {
    name: 'Início',
    href: '/',
    icon: Home,
    color: 'text-inicio-primary',
    activeColor: 'bg-inicio-light',
  },
  {
    name: 'Alimentação',
    href: '/alimentacao',
    icon: Utensils,
    color: 'text-alimentacao-primary',
    activeColor: 'bg-alimentacao-light',
  },
  {
    name: 'Receitas',
    href: '/receitas',
    icon: Book,
    color: 'text-blue-600',
    activeColor: 'bg-blue-100',
  },
  {
    name: 'Estudos',
    href: '/estudos',
    icon: BookOpen,
    color: 'text-estudos-primary',
    activeColor: 'bg-estudos-light',
  },
  {
    name: 'Saúde',
    href: '/saude',
    icon: Heart,
    color: 'text-saude-primary',
    activeColor: 'bg-saude-light',
  },
  {
    name: 'Lazer',
    href: '/lazer',
    icon: Smile,
    color: 'text-lazer-primary',
    activeColor: 'bg-lazer-light',
  },
  {
    name: 'Finanças',
    href: '/financas',
    icon: DollarSign,
    color: 'text-financas-primary',
    activeColor: 'bg-financas-light',
  },
  {
    name: 'Hiperfocos',
    href: '/hiperfocos',
    icon: Rocket,
    color: 'text-hiperfocos-primary',
    activeColor: 'bg-hiperfocos-light',
  },
]

type SidebarProps = {
  onClose: () => void
}

export function Sidebar({ onClose }: SidebarProps) {
  const pathname = usePathname() ?? '';

  const handleKeyDown = (event: React.KeyboardEvent) => {
    if (event.key === 'Escape') {
      onClose();
    }
  }

  return (
    <div 
      className="fixed inset-0 z-50 flex" 
      role="dialog" 
      aria-modal="true" 
      aria-label="Menu principal"
      onKeyDown={handleKeyDown}
    >
      {/* Overlay escuro com acessibilidade melhorada */}
      <div 
        className="fixed inset-0 bg-gray-900/60" 
        onClick={onClose}
        aria-hidden="true"
      />
      
      {/* Sidebar com estrutura semântica melhorada */}
      <div 
        className="relative flex-1 flex flex-col w-64 max-w-xs bg-white dark:bg-gray-800 shadow-xl"
        tabIndex={-1}
        role="document"
      >
        <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-xl font-bold text-gray-900 dark:text-white" id="sidebar-title">Menu</h2>
          <button
            className="p-2 rounded-md text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
            onClick={onClose}
            aria-label="Fechar menu"
            tabIndex={0}
          >
            <X className="h-5 w-5" aria-hidden="true" />
            <span className="sr-only">Fechar</span>
          </button>
        </div>
        
        <nav 
          className="flex-1 p-4 overflow-y-auto"
          aria-labelledby="sidebar-title"
        >
          <div className="space-y-2">
            {navItems.map((item) => {
              const isActive = pathname === item.href || pathname.startsWith(`${item.href}/`);
              
              return (
                <Link
                  key={item.name}
                  href={item.href}
                  className={`
                    flex items-center px-4 py-3 rounded-lg text-base font-medium transition-colors
                    ${isActive 
                      ? `${item.activeColor} ${item.color}` 
                      : 'text-gray-700 hover:bg-gray-100 dark:text-gray-200 dark:hover:bg-gray-700'}
                  `}
                  onClick={onClose}
                  aria-current={isActive ? 'page' : undefined}
                  tabIndex={0}
                >
                  <item.icon 
                    className={`mr-3 h-5 w-5 ${item.iconClasses || ''}`} 
                    aria-hidden="true" 
                  />
                  <span>{item.name}</span>
                </Link>
              )
            })}
          </div>
        </nav>
      </div>
    </div>
  )
}
</file>

<file path="app/components/lazer/AtividadesLazer.tsx">
'use client'

import { useState, useMemo } from 'react'
import { Plus, Trash, Clock, Calendar, Bookmark } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Input } from '@/app/components/ui/Input'
import { Textarea } from '@/app/components/ui/Textarea'
import { Badge } from '@/app/components/ui/Badge'
import { Select } from '@/app/components/ui/Select'
import { StatCard } from '@/app/components/ui/StatCard'
import { Alert } from '@/app/components/ui/Alert'
import { useAtividadesStore } from '@/app/stores/atividadesStore'

type Atividade = {
  id: string
  nome: string
  categoria: string
  duracao: number // em minutos
  observacoes: string
  data: string
  concluida: boolean
}

export function AtividadesLazer() {
  const { atividades, adicionarAtividade, removerAtividade, marcarConcluida } = useAtividadesStore()
  
  const [novaAtividade, setNovaAtividade] = useState<Omit<Atividade, 'id' | 'concluida'>>({
    nome: '',
    categoria: 'Criativa',
    duracao: 30,
    observacoes: '',
    data: new Date().toISOString().split('T')[0]
  })

  const [erro, setErro] = useState('')
  const [showForm, setShowForm] = useState(false)

  // Categorias de atividades de lazer
  const categorias = [
    { value: 'Criativa', label: 'Criativa' },
    { value: 'Física', label: 'Física' },
    { value: 'Social', label: 'Social' },
    { value: 'Relaxante', label: 'Relaxante' },
    { value: 'Intelectual', label: 'Intelectual' },
    { value: 'Outra', label: 'Outra' }
  ]

  // Estatísticas
  const estatisticas = useMemo(() => {
    const atividadesConcluidas = atividades.filter(a => a.concluida).length
    const totalMinutosLazer = atividades
      .filter(a => a.concluida)
      .reduce((acc, curr) => acc + curr.duracao, 0)
    
    // Categoria mais comum
    const contagem = atividades
      .filter(a => a.concluida)
      .reduce((acc, curr) => {
        acc[curr.categoria] = (acc[curr.categoria] || 0) + 1
        return acc
      }, {} as Record<string, number>)
    
    const categoriaMaisComum = Object.entries(contagem).sort((a, b) => b[1] - a[1])[0]?.[0] || 'N/A'
    
    return {
      atividadesConcluidas,
      totalMinutosLazer,
      categoriaMaisComum
    }
  }, [atividades])

  // Handler para adicionar atividade
  const handleAdicionarAtividade = () => {
    if (!novaAtividade.nome.trim()) {
      setErro('O nome da atividade é obrigatório')
      return
    }
    
    adicionarAtividade({
      ...novaAtividade,
      id: crypto.randomUUID(),
      concluida: false
    })
    
    // Resetar o formulário
    setNovaAtividade({
      nome: '',
      categoria: 'Criativa',
      duracao: 30,
      observacoes: '',
      data: new Date().toISOString().split('T')[0]
    })
    
    setErro('')
    setShowForm(false)
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center mb-4">
        <Button 
          onClick={() => setShowForm(!showForm)}
          aria-label={showForm ? "Cancelar adição" : "Adicionar nova atividade de lazer"}
        >
          {showForm ? 'Cancelar' : 'Nova Atividade'}
        </Button>
      </div>

      {/* Estatísticas */}
      <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
        <StatCard
          title="Atividades Realizadas"
          value={estatisticas.atividadesConcluidas.toString()}
          icon={<Bookmark className="h-5 w-5" />}
          description="Total concluído"
        />
        
        <StatCard
          title="Tempo de Lazer"
          value={`${Math.floor(estatisticas.totalMinutosLazer / 60)}h ${estatisticas.totalMinutosLazer % 60}m`}
          icon={<Clock className="h-5 w-5" />}
          description="Tempo acumulado"
        />
        
        <StatCard
          title="Categoria Favorita"
          value={estatisticas.categoriaMaisComum}
          icon={<Bookmark className="h-5 w-5" />}
          description="Mais frequente"
        />
      </div>

      {/* Formulário para adicionar nova atividade */}
      {showForm && (
        <div className="mb-6 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg">
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
            Nova Atividade de Lazer
          </h3>
          
          {erro && <Alert variant="error" className="mb-3">{erro}</Alert>}
          
          <div className="space-y-4">
            <div>
              <label htmlFor="nome" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Nome da atividade
              </label>
              <Input
                id="nome"
                value={novaAtividade.nome}
                onChange={e => setNovaAtividade({...novaAtividade, nome: e.target.value})}
                placeholder="Ex: Ler um livro"
                aria-required="true"
              />
            </div>
            
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <label htmlFor="categoria" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Categoria
                </label>
                <Select
                  id="categoria"
                  value={novaAtividade.categoria}
                  onChange={e => setNovaAtividade({...novaAtividade, categoria: e.target.value})}
                  options={categorias}
                />
              </div>
              
              <div>
                <label htmlFor="duracao" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Duração (minutos)
                </label>
                <Input
                  id="duracao"
                  type="number"
                  min="5"
                  max="240"
                  value={novaAtividade.duracao}
                  onChange={e => setNovaAtividade({...novaAtividade, duracao: parseInt(e.target.value) || 30})}
                />
              </div>
            </div>
            
            <div>
              <label htmlFor="data" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Data
              </label>
              <Input
                id="data"
                type="date"
                value={novaAtividade.data}
                onChange={e => setNovaAtividade({...novaAtividade, data: e.target.value})}
              />
            </div>
            
            <div>
              <label htmlFor="observacoes" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Observações (opcional)
              </label>
              <Textarea
                id="observacoes"
                value={novaAtividade.observacoes}
                onChange={e => setNovaAtividade({...novaAtividade, observacoes: e.target.value})}
                placeholder="Detalhes adicionais sobre a atividade..."
              />
            </div>
            
            <Button onClick={handleAdicionarAtividade} className="w-full">
              Adicionar Atividade
            </Button>
          </div>
        </div>
      )}

      {/* Lista de atividades */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
          Suas Atividades
        </h3>
        
        {atividades.length === 0 ? (
          <div className="text-center py-8 text-gray-500 dark:text-gray-400">
            <Calendar className="h-12 w-12 mx-auto mb-2 opacity-50" />
            <p>Você ainda não tem nenhuma atividade de lazer registrada.</p>
            <p className="mt-1">Adicione uma atividade para começar a acompanhar.</p>
          </div>
        ) : (
          <div className="space-y-3">
            {atividades.map(atividade => (
              <div 
                key={atividade.id}
                className={`p-4 rounded-lg border ${
                  atividade.concluida 
                    ? 'bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-700' 
                    : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700'
                }`}
              >
                <div className="flex justify-between items-start">
                  <div>
                    <div className="flex items-center">
                      <h4 className={`font-medium ${
                        atividade.concluida 
                          ? 'text-gray-500 dark:text-gray-400' 
                          : 'text-gray-900 dark:text-white'
                      }`}>
                        {atividade.nome}
                      </h4>
                      <Badge className="ml-2" variant={atividade.concluida ? "secondary" : "default"}>
                        {atividade.categoria}
                      </Badge>
                    </div>
                    
                    <div className="mt-1 text-sm text-gray-500 dark:text-gray-400 flex flex-wrap gap-3">
                      <span className="flex items-center">
                        <Clock className="h-4 w-4 mr-1" />
                        {atividade.duracao} min
                      </span>
                      <span className="flex items-center">
                        <Calendar className="h-4 w-4 mr-1" />
                        {new Date(atividade.data).toLocaleDateString('pt-BR')}
                      </span>
                    </div>
                    
                    {atividade.observacoes && (
                      <p className="mt-2 text-sm text-gray-600 dark:text-gray-300">
                        {atividade.observacoes}
                      </p>
                    )}
                  </div>
                  
                  <div className="flex space-x-2">
                    {!atividade.concluida && (
                      <Button 
                        variant="outline" 
                        size="sm"
                        onClick={() => marcarConcluida(atividade.id)}
                        aria-label="Marcar como concluída"
                      >
                        Concluir
                      </Button>
                    )}
                    <Button 
                      variant="destructive" 
                      size="sm"
                      onClick={() => removerAtividade(atividade.id)}
                      aria-label="Remover atividade"
                    >
                      <Trash className="h-4 w-4" />
                    </Button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/components/lazer/SugestoesDescanso.tsx">
'use client'

import { useState, useEffect } from 'react'
import { RefreshCw, Heart, ThumbsUp, ThumbsDown } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Badge } from '@/app/components/ui/Badge'
import { useSugestoesStore } from '@/app/stores/sugestoesStore'

// Lista de atividades de descanso por categoria
const atividadesDescanso = {
  rapidas: [
    "Faça uma pausa para respirar profundamente por 2 minutos",
    "Tome um copo de água e observe o ambiente ao redor",
    "Realize alongamentos simples para o pescoço e ombros",
    "Olhe pela janela e observe 5 coisas diferentes",
    "Faça uma pequena caminhada dentro de casa",
    "Pratique a técnica 5-4-3-2-1 (observe 5 coisas que você vê, 4 que você sente, etc)",
    "Faça um pequeno desenho abstrato em um papel",
    "Escute uma música que você goste",
  ],
  criativas: [
    "Colorir um pequeno desenho ou mandala",
    "Fazer um origami simples",
    "Escrever um haiku (poema de 3 linhas)",
    "Fazer um esboço rápido do que você vê",
    "Criar uma pequena colagem com materiais disponíveis",
    "Inventar uma história curta sobre um objeto aleatório",
    "Escrever três coisas pelas quais você é grato hoje",
    "Tocar um instrumento musical por alguns minutos (se disponível)",
  ],
  físicas: [
    "Dançar ao som de uma música animada",
    "Fazer 10 agachamentos",
    "Caminhar ao ar livre por 10 minutos",
    "Praticar yoga por 5-10 minutos",
    "Fazer um jogo rápido de arremesso com uma bolinha",
    "Pular corda por 2 minutos",
    "Subir e descer escadas algumas vezes",
    "Fazer alongamentos para todas as partes do corpo",
  ],
  relaxantes: [
    "Praticar meditação guiada de 5 minutos",
    "Fazer uma massagem nas próprias mãos",
    "Preparar e desfrutar de uma xícara de chá",
    "Observar a natureza pela janela ou ao ar livre",
    "Ouvir sons da natureza (chuva, pássaros, ondas)",
    "Fazer exercícios de respiração profunda",
    "Aplicar aromaterapia com óleos essenciais",
    "Deitar-se e relaxar todos os músculos por 5 minutos",
  ]
}

export function SugestoesDescanso() {
  const { sugestoesFavoritas, adicionarFavorita, removerFavorita } = useSugestoesStore()
  const [sugestaoAtual, setSugestaoAtual] = useState('')
  const [categoriaAtual, setCategoriaAtual] = useState<keyof typeof atividadesDescanso>('rapidas')
  
  // Função para gerar uma sugestão aleatória
  const gerarSugestaoAleatoria = () => {
    const categorias = Object.keys(atividadesDescanso) as Array<keyof typeof atividadesDescanso>
    const categoriaAleatoria = categorias[Math.floor(Math.random() * categorias.length)]
    
    const atividadesCategoria = atividadesDescanso[categoriaAleatoria]
    const sugestaoAleatoria = atividadesCategoria[Math.floor(Math.random() * atividadesCategoria.length)]
    
    setSugestaoAtual(sugestaoAleatoria)
    setCategoriaAtual(categoriaAleatoria)
  }

  // Gerar sugestão inicial ao montar o componente
  useEffect(() => {
    gerarSugestaoAleatoria()
  }, [])

  // Verificar se a sugestão atual está nos favoritos
  const estaNasFavoritas = sugestoesFavoritas.includes(sugestaoAtual)

  // Função para alternar favorito
  const toggleFavorita = () => {
    if (estaNasFavoritas) {
      removerFavorita(sugestaoAtual)
    } else {
      adicionarFavorita(sugestaoAtual)
    }
  }

  // Função para obter o nome exibido da categoria
  const getNomeCategoria = (categoria: keyof typeof atividadesDescanso) => {
    const nomes = {
      rapidas: 'Rápidas',
      criativas: 'Criativas',
      físicas: 'Físicas',
      relaxantes: 'Relaxantes'
    }
    return nomes[categoria]
  }

  // Função para obter a cor da categoria
  const getCorCategoria = (categoria: keyof typeof atividadesDescanso) => {
    const cores = {
      rapidas: 'bg-blue-100 text-blue-800 dark:bg-blue-700 dark:text-blue-100',
      criativas: 'bg-purple-100 text-purple-800 dark:bg-purple-700 dark:text-purple-100',
      físicas: 'bg-green-100 text-green-800 dark:bg-green-700 dark:text-green-100',
      relaxantes: 'bg-amber-100 text-amber-800 dark:bg-amber-700 dark:text-amber-100'
    }
    return cores[categoria]
  }

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center mb-4">
        <Button 
          onClick={gerarSugestaoAleatoria}
          size="sm"
          aria-label="Gerar nova sugestão"
        >
          <RefreshCw className="h-4 w-4 mr-2" />
          Nova Sugestão
        </Button>
      </div>

      {/* Sugestão atual */}
      <div className="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg mb-6 text-center relative">
        {sugestaoAtual && (
          <>
            <Badge 
              className={`absolute top-3 left-3 ${getCorCategoria(categoriaAtual)}`}
            >
              {getNomeCategoria(categoriaAtual)}
            </Badge>
            
            <p className="text-xl text-gray-900 dark:text-white font-medium mt-4">
              {sugestaoAtual}
            </p>
            
            <div className="flex justify-center mt-6 space-x-3">
              <Button
                variant={estaNasFavoritas ? "default" : "outline"}
                size="sm"
                onClick={toggleFavorita}
                aria-label={estaNasFavoritas ? "Remover dos favoritos" : "Adicionar aos favoritos"}
              >
                <Heart className={`h-4 w-4 mr-2 ${estaNasFavoritas ? 'fill-white' : ''}`} />
                {estaNasFavoritas ? 'Favorita' : 'Favoritar'}
              </Button>
              
              <Button
                variant="outline"
                size="sm"
                onClick={gerarSugestaoAleatoria}
                aria-label="Próxima sugestão"
              >
                <ThumbsDown className="h-4 w-4 mr-2" />
                Próxima
              </Button>
            </div>
          </>
        )}
      </div>

      {/* Sugestões Favoritas */}
      <div>
        <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
          Sugestões Favoritas
        </h3>
        
        {sugestoesFavoritas.length === 0 ? (
          <div className="text-center py-4 text-gray-500 dark:text-gray-400">
            <Heart className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>Você ainda não tem sugestões favoritas.</p>
            <p className="mt-1">Adicione suas favoritas para acessá-las facilmente.</p>
          </div>
        ) : (
          <div className="space-y-2">
            {sugestoesFavoritas.map((sugestao, index) => (
              <div 
                key={index}
                className="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg flex justify-between items-center"
              >
                <p className="text-gray-700 dark:text-gray-300">{sugestao}</p>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => removerFavorita(sugestao)}
                  aria-label="Remover dos favoritos"
                >
                  <Heart className="h-4 w-4 fill-red-500 text-red-500" />
                </Button>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/components/lazer/TemporizadorLazer.tsx">
'use client'

import { useState, useEffect, useRef } from 'react'
import { Play, Pause, RotateCcw, Bell, Volume2, VolumeX } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Slider } from '@/app/components/ui/Slider'
import { Select } from '@/app/components/ui/Select'
import { Badge } from '@/app/components/ui/Badge'

export function TemporizadorLazer() {
  // Estados
  const [duracaoTotal, setDuracaoTotal] = useState(30) // em minutos
  const [tempoRestante, setTempoRestante] = useState(duracaoTotal * 60) // em segundos
  const [ativo, setAtivo] = useState(false)
  const [presetSelecionado, setPresetSelecionado] = useState('personalizado')
  const [somAtivado, setSomAtivado] = useState(true)
  
  // Refs
  const timerRef = useRef<NodeJS.Timeout | null>(null)
  const audioRef = useRef<HTMLAudioElement | null>(null)
  
  // Presets de tempo
  const presets = [
    { value: 'curto', label: 'Curto (15 min)', duracao: 15 },
    { value: 'medio', label: 'Médio (30 min)', duracao: 30 },
    { value: 'longo', label: 'Longo (45 min)', duracao: 45 },
    { value: 'extenso', label: 'Extenso (60 min)', duracao: 60 },
    { value: 'personalizado', label: 'Personalizado', duracao: duracaoTotal }
  ]

  // Inicializar áudio
  useEffect(() => {
    if (typeof window !== 'undefined') {
      audioRef.current = new Audio('/sounds/bell.mp3') // Certifique-se de ter este arquivo
    }
    
    return () => {
      // Limpar timer ao desmontar
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
    }
  }, [])

  // Atualizar tempo restante quando duracaoTotal mudar
  useEffect(() => {
    setTempoRestante(duracaoTotal * 60)
  }, [duracaoTotal])

  // Iniciar/parar timer
  useEffect(() => {
    if (ativo) {
      timerRef.current = setInterval(() => {
        setTempoRestante(prev => {
          if (prev <= 1) {
            // Timer acabou
            if (somAtivado && audioRef.current) {
              audioRef.current.play().catch(e => console.error('Erro ao tocar som:', e))
            }
            clearInterval(timerRef.current!)
            setAtivo(false)
            return 0
          }
          return prev - 1
        })
      }, 1000)
    } else if (timerRef.current) {
      clearInterval(timerRef.current)
    }
    
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current)
      }
    }
  }, [ativo, somAtivado])

  // Formatar tempo para exibição (MM:SS)
  const formatarTempo = (segundos: number) => {
    const minutos = Math.floor(segundos / 60)
    const segundosRestantes = segundos % 60
    return `${minutos.toString().padStart(2, '0')}:${segundosRestantes.toString().padStart(2, '0')}`
  }

  // Calcular porcentagem de progresso
  const calcularProgresso = () => {
    const total = duracaoTotal * 60
    const progresso = ((total - tempoRestante) / total) * 100
    return progresso
  }

  // Lidar com mudança de preset
  const handleChangePreset = (valor: string) => {
    setPresetSelecionado(valor)
    
    if (valor !== 'personalizado') {
      const preset = presets.find(p => p.value === valor)
      if (preset) {
        setDuracaoTotal(preset.duracao)
      }
    }
  }

  // Resetar temporizador
  const resetarTemporizador = () => {
    setAtivo(false)
    if (timerRef.current) {
      clearInterval(timerRef.current)
    }
    setTempoRestante(duracaoTotal * 60)
  }

  // Alternar entre iniciar e pausar
  const toggleTimer = () => {
    setAtivo(!ativo)
  }

  return (
    <div className="flex flex-col space-y-4">
      <div className="flex justify-between items-center">
        <Button
          variant="outline"
          size="sm"
          onClick={() => setSomAtivado(!somAtivado)}
          aria-label={somAtivado ? 'Desativar som' : 'Ativar som'}
        >
          {somAtivado ? <Volume2 className="h-4 w-4" /> : <VolumeX className="h-4 w-4" />}
        </Button>
      </div>

      {/* Display do temporizador */}
      <div className="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg mb-6 text-center relative">
        <div className="absolute top-3 left-3 flex gap-2">
          {ativo && (
            <Badge variant="primary" className="animate-pulse">
              Em andamento
            </Badge>
          )}
        </div>
        
        {/* Tempo em formato grande */}
        <div className="text-6xl font-bold text-gray-900 dark:text-white py-8">
          {formatarTempo(tempoRestante)}
        </div>
        
        {/* Barra de progresso */}
        <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-6">
          <div 
            className="bg-lazer-primary h-2.5 rounded-full transition-all duration-1000"
            style={{ width: `${calcularProgresso()}%` }}
          />
        </div>
        
        {/* Controles */}
        <div className="flex justify-center space-x-4">
          <Button
            onClick={toggleTimer}
            size="lg"
            aria-label={ativo ? 'Pausar temporizador' : 'Iniciar temporizador'}
            className="w-32"
          >
            {ativo ? (
              <>
                <Pause className="h-5 w-5 mr-2" />
                Pausar
              </>
            ) : (
              <>
                <Play className="h-5 w-5 mr-2" />
                Iniciar
              </>
            )}
          </Button>
          
          <Button
            onClick={resetarTemporizador}
            variant="outline"
            size="lg"
            aria-label="Resetar temporizador"
            className="w-32"
          >
            <RotateCcw className="h-5 w-5 mr-2" />
            Resetar
          </Button>
        </div>
      </div>

      {/* Configurações do temporizador */}
      <div className="space-y-4">
        <h3 className="text-lg font-medium text-gray-900 dark:text-white">
          Configurações
        </h3>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Presets de Tempo
          </label>
          <Select
            value={presetSelecionado}
            onChange={e => handleChangePreset(e.target.value)}
            options={presets}
            disabled={ativo}
          />
        </div>
        
        {presetSelecionado === 'personalizado' && (
          <div>
            <div className="flex justify-between items-center mb-1">
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Duração (minutos): {duracaoTotal}
              </label>
            </div>
            <Slider
              min={5}
              max={120}
              step={5}
              value={duracaoTotal}
              onChange={setDuracaoTotal}
              disabled={ativo}
            />
          </div>
        )}
        
        <div className="bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-lg mt-4">
          <div className="flex items-start">
            <Bell className="h-5 w-5 text-yellow-500 dark:text-yellow-400 mr-3 mt-0.5" />
            <div>
              <h4 className="text-sm font-medium text-yellow-800 dark:text-yellow-300">
                Dica
              </h4>
              <p className="text-sm text-yellow-700 dark:text-yellow-400 mt-1">
                Use este temporizador para evitar o hiperfoco em atividades de lazer.
                Intervalos regulares ajudam a manter o equilíbrio em suas atividades diárias.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/perfil/InformacoesPessoais.tsx">
'use client'

import { useState } from 'react'
import { usePerfilStore } from '../../stores/perfilStore'
import { Save, User, Edit } from 'lucide-react'

export function InformacoesPessoais() {
  const { nome, atualizarNome } = usePerfilStore()
  const [novoNome, setNovoNome] = useState(nome)
  const [editando, setEditando] = useState(false)
  
  const iniciarEdicao = () => {
    setNovoNome(nome)
    setEditando(true)
  }
  
  const salvarAlteracoes = () => {
    if (novoNome.trim()) {
      atualizarNome(novoNome.trim())
    }
    setEditando(false)
  }
  
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6 mb-6">
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-4 flex items-center">
        <User className="h-5 w-5 mr-2 text-perfil-primary" />
        Informações Básicas
      </h2>
      
      <div className="space-y-4">
        {/* Nome do usuário */}
        <div>
          <label htmlFor="nome" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Nome
          </label>
          
          {editando ? (
            <div className="flex items-center">
              <input
                type="text"
                id="nome"
                value={novoNome}
                onChange={(e) => setNovoNome(e.target.value)}
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                placeholder="Seu nome"
                maxLength={30}
                required
              />
              
              <button
                onClick={salvarAlteracoes}
                className="ml-2 p-2 text-white bg-perfil-primary rounded-md hover:bg-perfil-secondary focus:outline-none focus:ring-2 focus:ring-perfil-primary"
                aria-label="Salvar nome"
              >
                <Save className="h-4 w-4" />
              </button>
            </div>
          ) : (
            <div className="flex items-center justify-between">
              <p className="text-gray-800 dark:text-white text-lg">{nome}</p>
              
              <button
                onClick={iniciarEdicao}
                className="p-2 text-gray-500 hover:text-perfil-primary focus:outline-none focus:ring-2 focus:ring-perfil-primary rounded-md"
                aria-label="Editar nome"
              >
                <Edit className="h-4 w-4" />
              </button>
            </div>
          )}
        </div>
        
        <div className="pt-4 border-t border-gray-200 dark:border-gray-700">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Seu nome é usado para personalizar a experiência no Painel ND. 
            As informações pessoais são armazenadas apenas no seu navegador.
          </p>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/perfil/MetasDiarias.tsx">
'use client'

import { useState } from 'react'
import { usePerfilStore } from '../../stores/perfilStore'
import { Save, Target, Clock, Droplet, Coffee } from 'lucide-react'

export function MetasDiarias() {
  const { metasDiarias, atualizarMetasDiarias } = usePerfilStore()
  const [editando, setEditando] = useState(false)
  const [metas, setMetas] = useState(metasDiarias)
  
  const iniciarEdicao = () => {
    setMetas({...metasDiarias})
    setEditando(true)
  }
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    const valorNumerico = parseInt(value)
    
    // Verificar se é um número válido
    if (!isNaN(valorNumerico)) {
      setMetas({
        ...metas,
        [name]: valorNumerico
      })
    }
  }
  
  const salvarAlteracoes = () => {
    atualizarMetasDiarias(metas)
    setEditando(false)
  }
  
  const cancelarEdicao = () => {
    setMetas({...metasDiarias})
    setEditando(false)
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6 mb-6">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-semibold text-gray-800 dark:text-white flex items-center">
          <Target className="h-5 w-5 mr-2 text-perfil-primary" />
          Metas Diárias
        </h2>
        
        {!editando ? (
          <button
            onClick={iniciarEdicao}
            className="px-3 py-2 text-sm text-white bg-perfil-primary rounded-md hover:bg-perfil-secondary focus:outline-none focus:ring-2 focus:ring-perfil-primary"
            aria-label="Editar metas"
          >
            Personalizar
          </button>
        ) : (
          <div className="flex gap-2">
            <button
              onClick={cancelarEdicao}
              className="px-3 py-2 text-sm text-gray-600 bg-gray-200 dark:text-gray-300 dark:bg-gray-700 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none"
              aria-label="Cancelar edição"
            >
              Cancelar
            </button>
            <button
              onClick={salvarAlteracoes}
              className="px-3 py-2 text-sm text-white bg-perfil-primary rounded-md hover:bg-perfil-secondary focus:outline-none focus:ring-2 focus:ring-perfil-primary"
              aria-label="Salvar metas"
            >
              Salvar
            </button>
          </div>
        )}
      </div>
      
      <div className="space-y-5">
        {/* Horas de sono */}
        <div className={`flex items-center ${editando ? 'bg-perfil-light dark:bg-gray-700 p-3 rounded-md' : ''}`}>
          <div className="w-8 h-8 rounded-full bg-sono-primary flex items-center justify-center mr-3">
            <Clock className="w-4 h-4 text-white" />
          </div>
          
          <div className="flex-1">
            <div className="text-sm font-medium text-gray-500 dark:text-gray-400">
              Horas de sono
            </div>
            
            {editando ? (
              <div className="flex items-center mt-1">
                <input
                  type="number"
                  name="horasSono"
                  value={metas.horasSono}
                  onChange={handleChange}
                  min="4"
                  max="12"
                  className="w-16 px-2 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-800 dark:border-gray-600 dark:text-white"
                />
                <span className="ml-2 text-gray-700 dark:text-gray-300">horas</span>
              </div>
            ) : (
              <div className="text-lg font-medium text-gray-800 dark:text-white">
                {metasDiarias.horasSono} horas
              </div>
            )}
          </div>
        </div>
        
        {/* Tarefas prioritárias */}
        <div className={`flex items-center ${editando ? 'bg-perfil-light dark:bg-gray-700 p-3 rounded-md' : ''}`}>
          <div className="w-8 h-8 rounded-full bg-hiperfocos-primary flex items-center justify-center mr-3">
            <Target className="w-4 h-4 text-white" />
          </div>
          
          <div className="flex-1">
            <div className="text-sm font-medium text-gray-500 dark:text-gray-400">
              Tarefas prioritárias
            </div>
            
            {editando ? (
              <div className="flex items-center mt-1">
                <input
                  type="number"
                  name="tarefasPrioritarias"
                  value={metas.tarefasPrioritarias}
                  onChange={handleChange}
                  min="1"
                  max="7"
                  className="w-16 px-2 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-800 dark:border-gray-600 dark:text-white"
                />
                <span className="ml-2 text-gray-700 dark:text-gray-300">por dia</span>
              </div>
            ) : (
              <div className="text-lg font-medium text-gray-800 dark:text-white">
                {metasDiarias.tarefasPrioritarias} por dia
              </div>
            )}
          </div>
        </div>
        
        {/* Copos de água */}
        <div className={`flex items-center ${editando ? 'bg-perfil-light dark:bg-gray-700 p-3 rounded-md' : ''}`}>
          <div className="w-8 h-8 rounded-full bg-alimentacao-primary flex items-center justify-center mr-3">
            <Droplet className="w-4 h-4 text-white" />
          </div>
          
          <div className="flex-1">
            <div className="text-sm font-medium text-gray-500 dark:text-gray-400">
              Copos de água
            </div>
            
            {editando ? (
              <div className="flex items-center mt-1">
                <input
                  type="number"
                  name="coposAgua"
                  value={metas.coposAgua}
                  onChange={handleChange}
                  min="2"
                  max="15"
                  className="w-16 px-2 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-800 dark:border-gray-600 dark:text-white"
                />
                <span className="ml-2 text-gray-700 dark:text-gray-300">por dia</span>
              </div>
            ) : (
              <div className="text-lg font-medium text-gray-800 dark:text-white">
                {metasDiarias.coposAgua} por dia
              </div>
            )}
          </div>
        </div>
        
        {/* Pausas programadas */}
        <div className={`flex items-center ${editando ? 'bg-perfil-light dark:bg-gray-700 p-3 rounded-md' : ''}`}>
          <div className="w-8 h-8 rounded-full bg-lazer-primary flex items-center justify-center mr-3">
            <Coffee className="w-4 h-4 text-white" />
          </div>
          
          <div className="flex-1">
            <div className="text-sm font-medium text-gray-500 dark:text-gray-400">
              Pausas programadas
            </div>
            
            {editando ? (
              <div className="flex items-center mt-1">
                <input
                  type="number"
                  name="pausasProgramadas"
                  value={metas.pausasProgramadas}
                  onChange={handleChange}
                  min="2"
                  max="10"
                  className="w-16 px-2 py-1 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-perfil-primary focus:border-perfil-primary dark:bg-gray-800 dark:border-gray-600 dark:text-white"
                />
                <span className="ml-2 text-gray-700 dark:text-gray-300">por dia</span>
              </div>
            ) : (
              <div className="text-lg font-medium text-gray-800 dark:text-white">
                {metasDiarias.pausasProgramadas} por dia
              </div>
            )}
          </div>
        </div>
      </div>
      
      <div className="mt-5 pt-4 border-t border-gray-200 dark:border-gray-700">
        <p className="text-sm text-gray-500 dark:text-gray-400">
          Suas metas diárias são usadas para personalizar recomendações e lembretes em todo o painel.
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/components/perfil/PreferenciasVisuais.tsx">
'use client'

import { usePerfilStore } from '../../stores/perfilStore'
import { Eye, BarChart2, Type, Bell, Coffee, Moon } from 'lucide-react'

export function PreferenciasVisuais() {
  const { 
    preferenciasVisuais, 
    atualizarPreferenciasVisuais, 
    notificacoesAtivas, 
    pausasAtivas,
    alternarNotificacoes,
    alternarPausas
  } = usePerfilStore()
  
  const toggleAltoContraste = () => {
    atualizarPreferenciasVisuais({ altoContraste: !preferenciasVisuais.altoContraste })
    
    // Aplicar classes ao documento para alto contraste
    if (!preferenciasVisuais.altoContraste) {
      document.documentElement.classList.add('alto-contraste')
    } else {
      document.documentElement.classList.remove('alto-contraste')
    }
  }
  
  const toggleReducaoEstimulos = () => {
    atualizarPreferenciasVisuais({ reducaoEstimulos: !preferenciasVisuais.reducaoEstimulos })
    
    // Aplicar classes ao documento para redução de estímulos
    if (!preferenciasVisuais.reducaoEstimulos) {
      document.documentElement.classList.add('reducao-estimulos')
    } else {
      document.documentElement.classList.remove('reducao-estimulos')
    }
  }
  
  const toggleTextoGrande = () => {
    atualizarPreferenciasVisuais({ textoGrande: !preferenciasVisuais.textoGrande })
    
    // Aplicar classes ao documento para texto grande
    if (!preferenciasVisuais.textoGrande) {
      document.documentElement.classList.add('texto-grande')
    } else {
      document.documentElement.classList.remove('texto-grande')
    }
  }
  
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm p-6">
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-4 flex items-center">
        <Eye className="h-5 w-5 mr-2 text-perfil-primary" />
        Preferências de Acessibilidade
      </h2>
      
      <div className="space-y-5">
        {/* Modos visuais */}
        <div>
          <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
            Modos Visuais
          </h3>
          
          <div className="space-y-3">
            {/* Alto contraste */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-gray-900 flex items-center justify-center mr-3">
                  <BarChart2 className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Alto Contraste
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Aumenta o contraste para melhor legibilidade
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={preferenciasVisuais.altoContraste}
                onClick={toggleAltoContraste}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  preferenciasVisuais.altoContraste ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar alto contraste</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    preferenciasVisuais.altoContraste ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
            
            {/* Redução de estímulos */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-gray-500 flex items-center justify-center mr-3">
                  <Moon className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Redução de Estímulos
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Remove animações e reduz cores intensas
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={preferenciasVisuais.reducaoEstimulos}
                onClick={toggleReducaoEstimulos}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  preferenciasVisuais.reducaoEstimulos ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar redução de estímulos</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    preferenciasVisuais.reducaoEstimulos ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
            
            {/* Texto grande */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center mr-3">
                  <Type className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Texto Grande
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Aumenta o tamanho do texto em toda a aplicação
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={preferenciasVisuais.textoGrande}
                onClick={toggleTextoGrande}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  preferenciasVisuais.textoGrande ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar texto grande</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    preferenciasVisuais.textoGrande ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
          </div>
        </div>
        
        {/* Preferências gerais */}
        <div className="pt-5 border-t border-gray-200 dark:border-gray-700">
          <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
            Preferências Gerais
          </h3>
          
          <div className="space-y-3">
            {/* Notificações */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center mr-3">
                  <Bell className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Lembretes
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Exibir lembretes visuais no painel
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={notificacoesAtivas}
                onClick={alternarNotificacoes}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  notificacoesAtivas ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar notificações</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    notificacoesAtivas ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
            
            {/* Pausas */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <div className="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center mr-3">
                  <Coffee className="w-4 h-4 text-white" />
                </div>
                <div>
                  <div className="font-medium text-gray-800 dark:text-white">
                    Pausas Programadas
                  </div>
                  <p className="text-xs text-gray-500 dark:text-gray-400">
                    Exibir lembretes para fazer pausas
                  </p>
                </div>
              </div>
              
              <button
                role="switch"
                aria-checked={pausasAtivas}
                onClick={alternarPausas}
                className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-perfil-primary ${
                  pausasAtivas ? 'bg-perfil-primary' : 'bg-gray-200 dark:bg-gray-700'
                }`}
              >
                <span className="sr-only">Ativar pausas programadas</span>
                <span
                  className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                    pausasAtivas ? 'translate-x-6' : 'translate-x-1'
                  }`}
                />
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <div className="mt-5 pt-4 border-t border-gray-200 dark:border-gray-700">
        <p className="text-sm text-gray-500 dark:text-gray-400">
          As preferências visuais são aplicadas imediatamente e salvas automaticamente para uso futuro.
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/components/receitas/AdicionarReceitaForm.tsx">
'use client';

import React, { useState, useEffect, ChangeEvent, FormEvent } from 'react';
import { useReceitasStore, Receita } from '../../stores/receitasStore';
import { Button } from '../ui/Button';
import { Input } from '../ui/Input';
import { Textarea } from '../ui/Textarea';
import { Select } from '../ui/Select';
import { TagInput } from '../ui/TagInput';
import { useRouter } from 'next/navigation';

// Define types for form state management
type IngredienteForm = { nome: string; quantidade: string; unidade: string }; // Use string for quantity input
type ReceitaFormState = Omit<Receita, 'id' | 'ingredientes' | 'tempoPreparo' | 'porcoes'> & {
    tempoPreparo: string; // Use string for input
    porcoes: string;      // Use string for input
    ingredientes: IngredienteForm[];
};

interface AdicionarReceitaFormProps {
  receitaParaEditar?: Receita | null; // Allow null or undefined
  aoFinalizar?: (receitaSalva: Receita) => void; // Callback after save/cancel
}

export function AdicionarReceitaForm({ receitaParaEditar, aoFinalizar }: AdicionarReceitaFormProps) {
  const router = useRouter();
  const { adicionarReceita, atualizarReceita } = useReceitasStore();
  const editando = !!receitaParaEditar;

  const initialState: ReceitaFormState = {
    nome: '',
    descricao: '',
    categorias: [],
    tags: [],
    tempoPreparo: '30',
    porcoes: '2',
    calorias: '',
    imagem: '', // Store URL or base64 string
    ingredientes: [{ nome: '', quantidade: '1', unidade: 'g' }],
    passos: [''],
  };

  const [receita, setReceita] = useState<ReceitaFormState>(initialState);
  const [previewImagem, setPreviewImagem] = useState<string | null>(receitaParaEditar?.imagem || null);

  // Populate form if editing
  useEffect(() => {
    if (editando && receitaParaEditar) {
      setReceita({
        ...receitaParaEditar,
        // Convert numbers/arrays back to string/correct format for form state
        tempoPreparo: String(receitaParaEditar.tempoPreparo || '30'),
        porcoes: String(receitaParaEditar.porcoes || '2'),
        calorias: String(receitaParaEditar.calorias || ''),
        ingredientes: receitaParaEditar.ingredientes.map(ing => ({
            ...ing,
            quantidade: String(ing.quantidade) // Convert quantity to string for input
        })) || [{ nome: '', quantidade: '1', unidade: 'g' }],
        passos: receitaParaEditar.passos || [''],
        categorias: receitaParaEditar.categorias || [],
        tags: receitaParaEditar.tags || [],
      });
      setPreviewImagem(receitaParaEditar.imagem || null);
    } else {
        setReceita(initialState); // Reset form if not editing
        setPreviewImagem(null);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [receitaParaEditar, editando]); // Rerun effect if receitaParaEditar changes


  const opcoesUnidades = [
    { value: 'g', label: 'gramas (g)' },
    { value: 'kg', label: 'quilos (kg)' },
    { value: 'ml', label: 'mililitros (ml)' },
    { value: 'l', label: 'litros (l)' },
    { value: 'unidade', label: 'unidade(s)' },
    { value: 'colher_sopa', label: 'colher(es) de sopa' },
    { value: 'colher_cha', label: 'colher(es) de chá' },
    { value: 'xicara', label: 'xícara(s)' },
    { value: 'pitada', label: 'pitada(s)' },
    { value: 'a_gosto', label: 'a gosto' },
  ];

  const categoriasDisponiveis = [
    { value: 'cafe_manha', label: 'Café da Manhã' },
    { value: 'almoco', label: 'Almoço' },
    { value: 'jantar', label: 'Jantar' },
    { value: 'lanche', label: 'Lanche' },
    { value: 'sobremesa', label: 'Sobremesa' },
    { value: 'bebida', label: 'Bebida' },
    { value: 'acompanhamento', label: 'Acompanhamento' },
    { value: 'sopa', label: 'Sopa' },
    { value: 'salada', label: 'Salada' },
  ];

  const tagsSugeridas = ['Sem Glúten', 'Vegano', 'Vegetariano', 'Low Carb', 'Rápido', 'Fácil', 'Saudável', 'Festa', 'Doce', 'Salgado'];

  const atualizarCampo = (campo: keyof ReceitaFormState, valor: any) => {
    setReceita(prev => ({ ...prev, [campo]: valor }));
  };

  // --- Ingredient Handlers ---
  const atualizarIngrediente = (index: number, campo: keyof IngredienteForm, valor: string) => {
    const novosIngredientes = [...receita.ingredientes];
    novosIngredientes[index] = { ...novosIngredientes[index], [campo]: valor };
    atualizarCampo('ingredientes', novosIngredientes);
  };

  const adicionarIngrediente = () => {
    atualizarCampo('ingredientes', [...receita.ingredientes, { nome: '', quantidade: '1', unidade: 'g' }]);
  };

  const removerIngrediente = (index: number) => {
    if (receita.ingredientes.length <= 1) return; // Keep at least one ingredient row
    const novosIngredientes = receita.ingredientes.filter((_, i) => i !== index);
    atualizarCampo('ingredientes', novosIngredientes);
  };

  // --- Step Handlers ---
   const atualizarPasso = (index: number, valor: string) => {
     const novosPassos = [...receita.passos];
     novosPassos[index] = valor;
     atualizarCampo('passos', novosPassos);
   };

   const adicionarPasso = () => {
     atualizarCampo('passos', [...receita.passos, '']);
   };

   const removerPasso = (index: number) => {
     if (receita.passos.length <= 1) return; // Keep at least one step row
     const novosPassos = receita.passos.filter((_, i) => i !== index);
     atualizarCampo('passos', novosPassos);
   };

   // --- Image Handler ---
   const handleImagemChange = (e: ChangeEvent<HTMLInputElement>) => {
     const file = e.target.files?.[0];
     if (file) {
       // Basic preview using FileReader (more robust than createObjectURL for state)
       const reader = new FileReader();
       reader.onloadend = () => {
         const result = reader.result as string;
         setPreviewImagem(result); // Show preview
         atualizarCampo('imagem', result); // Store base64 string or prepare for upload
       };
       reader.readAsDataURL(file);

       // TODO: Implement actual upload logic here if needed
       // e.g., upload to S3/Cloudinary and store the URL in 'imagem' field
       // For now, we store the base64 representation for simplicity
     } else {
       setPreviewImagem(null);
       atualizarCampo('imagem', '');
     }
   };

  // --- Form Submission ---
  const salvarReceita = (e: FormEvent) => {
    e.preventDefault(); // Prevent default form submission

    // Basic Validation
    if (!receita.nome || receita.ingredientes.some(ing => !ing.nome.trim()) || receita.passos.some(p => !p.trim())) {
      alert('Por favor, preencha o nome da receita, pelo menos um ingrediente e um passo do modo de preparo.');
      return;
    }

    // Prepare data for saving (convert strings back to numbers)
    const receitaParaSalvar: Receita = {
      ...receita,
      id: receitaParaEditar?.id || Date.now().toString(), // Use existing ID or generate new one
      tempoPreparo: parseInt(receita.tempoPreparo, 10) || 0,
      porcoes: parseInt(receita.porcoes, 10) || 1,
      calorias: receita.calorias, // Keep as string or parse if needed
      ingredientes: receita.ingredientes.map(ing => ({
        ...ing,
        quantidade: parseFloat(ing.quantidade.replace(',', '.')) || 0 // Handle comma decimal and parse
      })),
      // Ensure arrays are not empty strings
      passos: receita.passos.filter(p => p.trim() !== ''),
      categorias: receita.categorias || [],
      tags: receita.tags || [],
    };

    try {
        if (editando) {
          atualizarReceita(receitaParaSalvar);
          alert('Receita atualizada com sucesso!');
        } else {
          adicionarReceita(receitaParaSalvar);
          alert('Receita adicionada com sucesso!');
        }

        if (aoFinalizar) {
          aoFinalizar(receitaParaSalvar);
        } else {
          // Default behavior: redirect to the recipe details page
          router.push(`/receitas/${receitaParaSalvar.id}`);
        }
    } catch (error) {
        console.error("Erro ao salvar receita:", error);
        alert("Ocorreu um erro ao salvar a receita. Verifique o console para mais detalhes.");
    }
  };

  const handleCancel = () => {
    if (aoFinalizar) {
        aoFinalizar(null as any); // Indicate cancellation if using callback
    } else {
        router.back(); // Go back to the previous page
    }
  }

  return (
    <form onSubmit={salvarReceita} className="p-4 md:p-6 lg:p-8 max-w-4xl mx-auto space-y-8">
      <h1 className="text-2xl md:text-3xl font-bold mb-6 border-b pb-3">
        {editando ? 'Editar Receita' : 'Adicionar Nova Receita'}
      </h1>

      {/* Basic Info Section */}
      <section className="space-y-4">
        <h2 className="text-xl font-semibold">Informações Básicas</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label htmlFor="nome" className="block mb-2 font-medium text-sm">Nome da Receita*</label>
            <Input
              id="nome"
              value={receita.nome}
              onChange={(e) => atualizarCampo('nome', e.target.value)}
              placeholder="Ex: Bolo de Cenoura Fofinho"
              required
            />
          </div>
          <div>
            <label htmlFor="categorias" className="block mb-2 font-medium text-sm">Categorias</label>
            <Select
              id="categorias"
              options={categoriasDisponiveis}
              value={receita.categorias}
              onChange={(e) => {
                  // Handle multi-select: get all selected options
                  const selectedOptions = Array.from(e.target.selectedOptions, option => option.value);
                  atualizarCampo('categorias', selectedOptions);
              }}
              multiple // Enable multiple selections
              className="h-auto" // Adjust height for multi-select
            />
             <p className="text-xs text-gray-500 mt-1">Segure Ctrl/Cmd para selecionar múltiplas.</p>
          </div>
        </div>
        <div>
          <label htmlFor="descricao" className="block mb-2 font-medium text-sm">Descrição Breve</label>
          <Textarea
            id="descricao"
            value={receita.descricao}
            onChange={(e) => atualizarCampo('descricao', e.target.value)}
            placeholder="Uma breve descrição sobre a receita, dicas, etc."
            rows={3}
          />
        </div>
      </section>

      {/* Details Section */}
       <section className="space-y-4">
         <h2 className="text-xl font-semibold">Detalhes</h2>
         <div className="grid grid-cols-1 sm:grid-cols-3 gap-6">
           <div>
             <label htmlFor="tempoPreparo" className="block mb-2 font-medium text-sm">Tempo de Preparo (min)*</label>
             <Input
               id="tempoPreparo"
               type="number"
               value={receita.tempoPreparo}
               onChange={(e) => atualizarCampo('tempoPreparo', e.target.value)}
               min={1}
               required
             />
           </div>
           <div>
             <label htmlFor="porcoes" className="block mb-2 font-medium text-sm">Porções*</label>
             <Input
               id="porcoes"
               type="number"
               value={receita.porcoes}
               onChange={(e) => atualizarCampo('porcoes', e.target.value)}
               min={1}
               required
             />
           </div>
           <div>
             <label htmlFor="calorias" className="block mb-2 font-medium text-sm">Calorias (por porção)</label>
             <Input
               id="calorias"
               type="text" // Use text to allow ranges or 'N/A'
               value={receita.calorias}
               onChange={(e) => atualizarCampo('calorias', e.target.value)}
               placeholder="Ex: 350 ou N/A"
             />
           </div>
         </div>
          <div>
             <label htmlFor="tags-input" className="block mb-2 font-medium text-sm">Tags</label> {/* Changed htmlFor to match input inside TagInput if needed, or remove if label clicks container */}
             <TagInput
                 // id="tags" removed - TagInput doesn't accept id prop directly
                 tags={receita.tags}
                 onChange={(tags) => atualizarCampo('tags', tags)}
                 suggestions={tagsSugeridas}
                placeholder="Adicione tags (ex: Vegano, Rápido)"
            />
         </div>
       </section>

      {/* Image Section */}
      <section className="space-y-4">
        <h2 className="text-xl font-semibold">Imagem da Receita</h2>
        <div>
          <label htmlFor="imagem" className="block mb-2 font-medium text-sm">Carregar Imagem</label>
          <Input
            id="imagem"
            type="file"
            accept="image/*"
            onChange={handleImagemChange}
            className="file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary-50 file:text-primary-700 hover:file:bg-primary-100"
          />
          {previewImagem && (
            <div className="mt-4 relative h-48 w-full max-w-sm border rounded overflow-hidden">
              <img
                src={previewImagem}
                alt="Preview da Receita"
                className="w-full h-full object-cover"
              />
               <Button
                  type="button"
                  onClick={() => { setPreviewImagem(null); atualizarCampo('imagem', ''); }}
                  variant="danger"
                  size="sm"
                  className="absolute top-2 right-2 !p-1"
                  aria-label="Remover imagem"
               >
                 X
               </Button>
            </div>
          )}
        </div>
      </section>

      {/* Ingredients Section */}
      <section className="space-y-4">
        <div className="flex justify-between items-center mb-2">
          <h2 className="text-xl font-semibold">Ingredientes*</h2>
          <Button type="button" onClick={adicionarIngrediente} size="sm" variant="outline">+ Adicionar Ingrediente</Button>
        </div>
        <div className="space-y-3">
          {receita.ingredientes.map((ingrediente, index) => (
            <div key={index} className="flex flex-col sm:flex-row items-start sm:items-center gap-3 p-3 border rounded bg-gray-50 dark:bg-gray-800/50">
              <div className="grid grid-cols-3 sm:flex sm:items-center gap-2 w-full sm:w-auto">
                 <Input
                   type="text" // Allow fractions or ranges like '1/2' or '1-2'
                   value={ingrediente.quantidade}
                   onChange={(e) => atualizarIngrediente(index, 'quantidade', e.target.value)}
                   placeholder="Qtd."
                   className="w-full sm:w-20"
                   aria-label={`Quantidade do ingrediente ${index + 1}`}
                 />
                 <Select
                   options={opcoesUnidades}
                   value={ingrediente.unidade}
                   onChange={(e) => atualizarIngrediente(index, 'unidade', e.target.value)}
                   className="w-full sm:w-32"
                   aria-label={`Unidade do ingrediente ${index + 1}`}
                 />
                 <Input
                   value={ingrediente.nome}
                   onChange={(e) => atualizarIngrediente(index, 'nome', e.target.value)}
                   placeholder="Nome do Ingrediente"
                   className="flex-1 min-w-[150px] col-span-3 sm:col-span-1" // Span across on mobile
                   required
                   aria-label={`Nome do ingrediente ${index + 1}`}
                 />
              </div>
              <Button
                type="button"
                onClick={() => removerIngrediente(index)}
                variant="ghost"
                size="sm"
                className="text-red-500 hover:bg-red-100 dark:hover:bg-red-900/50 ml-auto mt-2 sm:mt-0"
                disabled={receita.ingredientes.length <= 1}
                aria-label={`Remover ingrediente ${index + 1}`}
              >
                Remover
              </Button>
            </div>
          ))}
        </div>
      </section>

      {/* Steps Section */}
      <section className="space-y-4">
         <div className="flex justify-between items-center mb-2">
           <h2 className="text-xl font-semibold">Modo de Preparo*</h2>
           <Button type="button" onClick={adicionarPasso} size="sm" variant="outline">+ Adicionar Passo</Button>
         </div>
         <div className="space-y-4">
           {receita.passos.map((passo, index) => (
             <div key={index} className="flex items-start gap-3">
               <span className="mt-2 font-semibold text-gray-500">{index + 1}.</span>
               <Textarea
                 value={passo}
                 onChange={(e) => atualizarPasso(index, e.target.value)}
                 placeholder={`Descreva o passo ${index + 1}`}
                 className="flex-1"
                 rows={3}
                 required
                 aria-label={`Passo ${index + 1} do modo de preparo`}
               />
               <Button
                 type="button"
                 onClick={() => removerPasso(index)}
                 variant="ghost"
                 size="sm"
                 className="text-red-500 hover:bg-red-100 dark:hover:bg-red-900/50 mt-1"
                 disabled={receita.passos.length <= 1}
                 aria-label={`Remover passo ${index + 1}`}
               >
                 Remover
               </Button>
             </div>
           ))}
         </div>
       </section>

      {/* Action Buttons */}
      <div className="flex justify-end gap-4 pt-6 border-t">
        <Button type="button" onClick={handleCancel} variant="outline">Cancelar</Button>
        <Button type="submit" color="primary">
          {editando ? 'Atualizar Receita' : 'Salvar Nova Receita'}
        </Button>
      </div>
    </form>
  );
}
</file>

<file path="app/components/receitas/DetalhesReceita.tsx">
'use client'; // Required for useState and hooks

import { useState, useEffect } from 'react'; // Import useEffect
import { useReceitasStore } from '../../stores/receitasStore';
import { useAlimentacaoStore } from '../../stores/alimentacaoStore'; // Assuming this store exists
import { Button } from '../ui/Button';
import { Tag } from '../ui/Tag';
import { useRouter } from 'next/navigation'; // Use next/navigation for App Router
import Link from 'next/link'; // Import Link

interface DetalhesReceitaProps {
  id: string;
}

export function DetalhesReceita({ id }: DetalhesReceitaProps) {
  const router = useRouter();
  const { obterReceitaPorId, removerReceita, alternarFavorito, favoritos } = useReceitasStore();
  const { adicionarRefeicao } = useAlimentacaoStore(); // Use adicionarRefeicao from alimentacaoStore
  const [porcoes, setPorcoes] = useState(1); // Default to 1 portion for calculation

  const receita = obterReceitaPorId(id);

  // Initialize porcoes state with the recipe's default portions once recipe is loaded using useEffect
  useEffect(() => {
    if (receita) {
      setPorcoes(receita.porcoes || 1);
    }
  }, [receita]); // Dependency array ensures this runs when recipe data is available/changes


  if (!receita) {
    // Optional: Add a loading state or redirect
    return <p className="p-4 text-center text-gray-500">Receita não encontrada ou carregando...</p>;
  }

  const isFavorito = favoritos.includes(id);

  const ajustarQuantidade = (quantidade: number | undefined) => {
    if (quantidade === undefined || receita.porcoes === undefined || receita.porcoes === 0) return 'N/A';
    // Handle 'a gosto' or similar units where quantity might not scale
    // For simplicity, we scale everything, but real-world might need checks
    const adjusted = (quantidade * porcoes) / receita.porcoes;
    // Format to 1 decimal place, but avoid .0
    return adjusted % 1 === 0 ? adjusted.toFixed(0) : adjusted.toFixed(1);
  };

  const adicionarAoPlanejamento = () => {
    // adicionarRefeicao takes only horario and descricao
    adicionarRefeicao(
        new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }), // Example: current time
        receita.nome // Use recipe name as description
        // receita.id is not passed as per store signature
    );
    // Optionally, navigate to the planner or show a confirmation message
    alert(`${receita.nome} adicionada ao planejador!`);
    // router.push('/alimentacao'); // Example navigation
  };

  const handleRemoverReceita = () => {
    if (window.confirm(`Tem certeza que deseja remover a receita "${receita.nome}"?`)) {
      removerReceita(id);
      router.push('/receitas'); // Redirect back to the list after deletion
    }
  };

  return (
    <div className="p-4 md:p-6 lg:p-8 max-w-5xl mx-auto">
      {/* Image Header */}
      <div className="relative h-48 sm:h-64 md:h-80 rounded-lg overflow-hidden mb-6 bg-gray-200 dark:bg-gray-700">
        {receita.imagem ? (
          <img
            src={receita.imagem}
            alt={receita.nome}
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-gray-500">
            <span>Sem imagem disponível</span>
          </div>
        )}
         {/* Favorite Button Overlay */}
         <button
            onClick={() => alternarFavorito(id)}
            className={`absolute top-3 right-3 p-2 rounded-full transition-colors duration-200 ${
              isFavorito ? 'bg-red-500 text-white' : 'bg-white/70 text-gray-700 hover:bg-white'
            }`}
            aria-label={isFavorito ? 'Remover dos Favoritos' : 'Adicionar aos Favoritos'}
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill={isFavorito ? 'currentColor' : 'none'} viewBox="0 0 24 24" stroke="currentColor" strokeWidth={isFavorito ? 0 : 2}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
            </svg>
          </button>
      </div>

      {/* Title and Tags */}
      <h1 className="text-3xl md:text-4xl font-bold mb-3">{receita.nome}</h1>
      {receita.descricao && <p className="text-lg text-gray-600 dark:text-gray-400 mb-4">{receita.descricao}</p>}
      <div className="flex flex-wrap gap-2 mb-6">
        {receita.tags?.map(tag => (
          <Tag key={tag}>{tag}</Tag>
        ))}
      </div>

      {/* Quick Info Boxes */}
      <div className="grid grid-cols-2 sm:grid-cols-3 gap-4 mb-8">
        <div className="bg-primary-50 dark:bg-primary-900/30 p-3 rounded-lg text-center">
          <p className="text-sm text-primary-700 dark:text-primary-300">Tempo de Preparo</p>
          <p className="font-bold text-lg">{receita.tempoPreparo || "N/A"} min</p>
        </div>
        <div className="bg-primary-50 dark:bg-primary-900/30 p-3 rounded-lg text-center">
          <p className="text-sm text-primary-700 dark:text-primary-300">Porções Originais</p>
          <p className="font-bold text-lg">{receita.porcoes || "N/A"}</p>
        </div>
        <div className="bg-primary-50 dark:bg-primary-900/30 p-3 rounded-lg text-center">
          <p className="text-sm text-primary-700 dark:text-primary-300">Calorias (aprox.)</p>
          <p className="font-bold text-lg">{receita.calorias || "N/A"}</p>
        </div>
      </div>

      {/* Ingredients and Instructions */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {/* Ingredients Section */}
        <div className="md:col-span-1">
          <h2 className="text-xl font-bold mb-4 border-b pb-2">Ingredientes</h2>
          <div className="flex items-center gap-4 mb-4">
            <label htmlFor="porcoes-input" className="text-sm font-medium">Ajustar para:</label>
            <div className="flex items-center border rounded">
               <button
                 onClick={() => setPorcoes(Math.max(1, porcoes - 1))}
                 className="px-2 py-1 border-r text-lg"
                 aria-label="Diminuir porções"
               >-</button>
               <input
                 id="porcoes-input"
                 type="number"
                 value={porcoes}
                 onChange={(e) => setPorcoes(Math.max(1, parseInt(e.target.value) || 1))}
                 min={1}
                 className="w-12 text-center py-1 outline-none bg-transparent"
                 aria-label="Número de porções"
               />
               <button
                 onClick={() => setPorcoes(porcoes + 1)}
                 className="px-2 py-1 border-l text-lg"
                 aria-label="Aumentar porções"
               >+</button>
            </div>
             <span className="text-sm">porções</span>
          </div>
          <ul className="space-y-2 text-sm">
            {receita.ingredientes?.map((ing, index) => (
              <li key={index} className="flex items-start gap-2">
                <span className="font-medium w-20 text-right">{ajustarQuantidade(ing.quantidade)} {ing.unidade}</span>
                <span>{ing.nome}</span>
              </li>
            ))}
             {!receita.ingredientes || receita.ingredientes.length === 0 && (
                <li className="text-gray-500">Nenhum ingrediente listado.</li>
             )}
          </ul>

          {/* Action Buttons */}
          <div className="mt-8 space-y-3">
            <Button onClick={adicionarAoPlanejamento} color="primary" className="w-full">
              Adicionar ao Planejador
            </Button>
             <Link href={`/receitas/editar/${id}`} passHref>
                <Button variant="outline" className="w-full">Editar Receita</Button>
             </Link>
            <Button onClick={handleRemoverReceita} variant="danger" className="w-full">
              Remover Receita
            </Button>
          </div>
        </div>

        {/* Instructions Section */}
        <div className="md:col-span-2">
          <h2 className="text-xl font-bold mb-4 border-b pb-2">Modo de Preparo</h2>
          {receita.passos && receita.passos.length > 0 ? (
            <ol className="space-y-4 list-decimal list-outside pl-5 marker:font-semibold marker:text-primary-600">
              {receita.passos.map((passo, index) => (
                <li key={index} className="pl-2 leading-relaxed">
                  {passo}
                </li>
              ))}
            </ol>
          ) : (
            <p className="text-gray-500">Nenhum passo de preparo listado.</p>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/components/receitas/FiltroCategorias.tsx">
import React from 'react';
import { Select } from '../ui/Select'; // Assuming Select component exists in ui directory

interface FiltroCategoriasProps {
  categoriaAtual: string;
  aoSelecionar: (categoria: string) => void;
  className?: string;
}

// Define categories directly in the component or fetch them from a store/API
const categorias = [
  { value: 'todas', label: 'Todas as Categorias' },
  { value: 'cafe_manha', label: 'Café da Manhã' },
  { value: 'almoco', label: 'Almoço' },
  { value: 'jantar', label: 'Jantar' },
  { value: 'lanche', label: 'Lanche' },
  { value: 'sobremesa', label: 'Sobremesa' },
  { value: 'bebida', label: 'Bebida' },
  // Add other categories as needed
];

export function FiltroCategorias({
  categoriaAtual,
  aoSelecionar,
  className = '',
}: FiltroCategoriasProps) {
  return (
    <div className={className}>
      <Select
        options={categorias}
        value={categoriaAtual}
        onChange={(e) => aoSelecionar(e.target.value)} // Extract value from event
        // placeholder prop removed
      />
    </div>
  );
}
</file>

<file path="app/components/receitas/ImportadorReceitas.tsx">
'use client';

import React, { useState, useRef, ChangeEvent } from 'react';
import { useReceitasStore, Receita } from '../../stores/receitasStore';
import { Button } from '../ui/Button';
import { Alert } from '../ui/Alert'; // Assuming Alert component exists for feedback

// Helper function to validate a single recipe object
const validarReceita = (obj: any): obj is Partial<Receita> => {
  if (typeof obj !== 'object' || obj === null) return false;

  // Check required fields (adjust based on strictness)
  if (typeof obj.nome !== 'string' || !obj.nome.trim()) return false;
  if (!Array.isArray(obj.ingredientes) || obj.ingredientes.length === 0) return false;
  if (!Array.isArray(obj.passos) || obj.passos.length === 0) return false;

  // Basic type checks for ingredients and steps
  if (!obj.ingredientes.every((ing: any) => typeof ing.nome === 'string' && typeof ing.quantidade === 'number' && typeof ing.unidade === 'string')) return false;
  if (!obj.passos.every((passo: any) => typeof passo === 'string')) return false;

  // Optional fields type checks (add more as needed)
  if (obj.descricao && typeof obj.descricao !== 'string') return false;
  if (obj.categorias && !Array.isArray(obj.categorias)) return false;
  if (obj.tags && !Array.isArray(obj.tags)) return false;
  if (obj.tempoPreparo && typeof obj.tempoPreparo !== 'number') return false;
  if (obj.porcoes && typeof obj.porcoes !== 'number') return false;
  if (obj.calorias && typeof obj.calorias !== 'string') return false; // Allow string for flexibility
  if (obj.imagem && typeof obj.imagem !== 'string') return false;

  return true;
};

export function ImportadorReceitas() {
  const { adicionarReceita } = useReceitasStore();
  const [isLoading, setIsLoading] = useState(false);
  const [feedback, setFeedback] = useState<{ type: 'success' | 'error'; message: string } | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = async (event: ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setIsLoading(true);
    setFeedback(null);

    try {
      const fileContent = await file.text();
      const jsonData = JSON.parse(fileContent);

      let receitasParaAdicionar: Receita[] = [];

      // Check if it's an array (multiple recipes) or single object
      if (Array.isArray(jsonData)) {
        jsonData.forEach((item, index) => {
          if (validarReceita(item)) {
            const validatedItem = item as Partial<Receita>; // Keep partial for optional fields
            // Construct the object explicitly to satisfy the Receita type
            receitasParaAdicionar.push({
              id: Date.now().toString() + index,
              nome: validatedItem.nome!, // Assert non-null (checked by validarReceita)
              descricao: validatedItem.descricao || '', // Default for optional
              categorias: validatedItem.categorias || [], // Default
              tags: validatedItem.tags || [], // Default
              tempoPreparo: validatedItem.tempoPreparo || 0, // Default
              porcoes: validatedItem.porcoes || 1, // Default
              calorias: validatedItem.calorias || '', // Default
              imagem: validatedItem.imagem || '', // Default
              ingredientes: validatedItem.ingredientes!, // Assert non-null (checked by validarReceita)
              passos: validatedItem.passos!, // Assert non-null (checked by validarReceita)
            });
          } else {
            console.warn(`Item ${index + 1} no JSON inválido ou incompleto. Ignorando.`);
            // Optionally provide more specific feedback
          }
        });
      } else if (validarReceita(jsonData)) {
         const validatedItem = jsonData as Partial<Receita>;
         // Construct the object explicitly to satisfy the Receita type
         receitasParaAdicionar.push({
            id: Date.now().toString(),
            nome: validatedItem.nome!, // Assert non-null
            descricao: validatedItem.descricao || '',
            categorias: validatedItem.categorias || [],
            tags: validatedItem.tags || [],
            tempoPreparo: validatedItem.tempoPreparo || 0,
            porcoes: validatedItem.porcoes || 1,
            calorias: validatedItem.calorias || '',
            imagem: validatedItem.imagem || '',
            ingredientes: validatedItem.ingredientes!, // Assert non-null
            passos: validatedItem.passos!, // Assert non-null
         });
      } else {
        throw new Error('Estrutura do JSON inválida. Esperado um objeto de receita ou um array de objetos de receita.');
      }

      if (receitasParaAdicionar.length === 0) {
         throw new Error('Nenhuma receita válida encontrada no arquivo JSON.');
      }

      // Add recipes to the store
      receitasParaAdicionar.forEach(receita => {
        // TODO: Consider adding duplicate check here before adding
        adicionarReceita(receita);
      });

      setFeedback({ type: 'success', message: `${receitasParaAdicionar.length} receita(s) importada(s) com sucesso!` });

    } catch (error: any) {
      console.error("Erro ao importar receitas:", error);
      setFeedback({ type: 'error', message: `Erro ao importar: ${error.message || 'Verifique o formato do arquivo JSON.'}` });
    } finally {
      setIsLoading(false);
      // Reset file input to allow importing the same file again if needed
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const triggerFileInput = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className="my-4 p-4 border rounded-lg bg-gray-50 dark:bg-gray-800/50">
       <h3 className="text-lg font-medium mb-2">Importar Receitas</h3>
       <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
         Selecione um arquivo `.json` contendo uma única receita ou um array de receitas para importar.
         {/* TODO: Add link to documentation/example format */}
       </p>
      <input
        type="file"
        accept=".json"
        ref={fileInputRef}
        onChange={handleFileChange}
        style={{ display: 'none' }} // Hide the default input
        disabled={isLoading}
      />
      <Button
        onClick={triggerFileInput}
        disabled={isLoading}
        variant="outline"
      >
        {isLoading ? 'Importando...' : 'Selecionar Arquivo JSON'}
      </Button>

      {feedback && (
        <Alert variant={feedback.type} className="mt-4"> {/* Changed 'type' to 'variant' */}
          {feedback.message}
        </Alert>
      )}
    </div>
  );
}
</file>

<file path="app/components/receitas/ListaCompras.tsx">
'use client';

import React, { useState, useMemo } from 'react';
import { useReceitasStore, Receita } from '../../stores/receitasStore';
import { Checkbox } from '../ui/Checkbox'; // Assuming Checkbox exists
import { Button } from '../ui/Button';
import { Input } from '../ui/Input'; // For portion adjustment

interface IngredienteAgrupado {
  nome: string;
  quantidadeTotal: number;
  unidade: string;
  key: string; // Unique key for state management (nome_unidade)
}

export function ListaCompras() {
  const { receitas } = useReceitasStore();
  const [receitasSelecionadas, setReceitasSelecionadas] = useState<string[]>([]);
  // Store portions as strings for input compatibility, parse when calculating
  const [porcoes, setPorcoes] = useState<Record<string, string>>({});
  const [itensComprados, setItensComprados] = useState<string[]>([]); // Store item keys (nome_unidade)

  // Initialize/update portions when a recipe is selected/deselected
  const toggleReceitaSelecionada = (id: string) => {
    const novasSelecionadas = [...receitasSelecionadas];
    const novasPorcoes = { ...porcoes };
    const receita = receitas.find(r => r.id === id);

    if (!receita) return;

    const index = novasSelecionadas.indexOf(id);
    if (index > -1) {
      novasSelecionadas.splice(index, 1); // Deselect
      delete novasPorcoes[id]; // Remove portion entry
    } else {
      novasSelecionadas.push(id); // Select
      novasPorcoes[id] = String(receita.porcoes || 1); // Initialize with recipe portions
    }
    setReceitasSelecionadas(novasSelecionadas);
    setPorcoes(novasPorcoes);
    // Optionally reset purchased items when selection changes
    // setItensComprados([]);
  };

  const atualizarPorcoes = (id: string, valor: string) => {
    // Allow empty input temporarily, default to 1 if invalid number
    const numValor = parseInt(valor, 10);
    setPorcoes({
      ...porcoes,
      [id]: valor // Store the raw string value
    });
  };

  // Memoize the shopping list generation for performance
  const listaCompras = useMemo<IngredienteAgrupado[]>(() => {
    const ingredientesAgrupados: Record<string, IngredienteAgrupado> = {};

    receitasSelecionadas.forEach(id => {
      const receita = receitas.find(r => r.id === id);
      if (!receita) return;

      const porcoesAtuais = parseInt(porcoes[id] || '1', 10) || 1; // Parse string, default to 1
      const porcoesOriginais = receita.porcoes || 1;
      const fatorMultiplicacao = porcoesOriginais > 0 ? porcoesAtuais / porcoesOriginais : 1;

      receita.ingredientes?.forEach(ing => {
        const chave = `${ing.nome.trim().toLowerCase()}_${ing.unidade}`; // Normalize key
        const quantidadeAjustada = (ing.quantidade || 0) * fatorMultiplicacao;

        if (ingredientesAgrupados[chave]) {
          ingredientesAgrupados[chave].quantidadeTotal += quantidadeAjustada;
        } else {
          ingredientesAgrupados[chave] = {
            nome: ing.nome.trim(),
            quantidadeTotal: quantidadeAjustada,
            unidade: ing.unidade,
            key: chave,
          };
        }
      });
    });

    return Object.values(ingredientesAgrupados)
      .filter(item => item.quantidadeTotal > 0) // Exclude items with zero quantity
      .sort((a, b) => a.nome.localeCompare(b.nome));
  }, [receitas, receitasSelecionadas, porcoes]);

  const toggleItemComprado = (itemKey: string) => {
    setItensComprados(prev =>
      prev.includes(itemKey)
        ? prev.filter(key => key !== itemKey)
        : [...prev, itemKey]
    );
  };

  const formatarQuantidade = (qtd: number): string => {
     // Simple formatting, could be enhanced (e.g., fractions)
     if (qtd === 0) return '0';
     if (qtd < 0.1) return qtd.toFixed(2); // Show more precision for small amounts
     if (qtd % 1 === 0) return qtd.toFixed(0); // No decimals for whole numbers
     return qtd.toFixed(1); // One decimal place otherwise
  }

  return (
    <div className="p-4 md:p-6 lg:p-8 max-w-4xl mx-auto">
      <h1 className="text-2xl md:text-3xl font-bold mb-6 border-b pb-3">Lista de Compras</h1>

      {/* Recipe Selection Section */}
      <section className="mb-8">
        <h2 className="text-xl font-semibold mb-4">1. Selecione as Receitas</h2>
        {receitas.length === 0 ? (
          <p className="text-gray-500 italic">
            Nenhuma receita cadastrada. Adicione receitas primeiro.
          </p>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
            {receitas.map(receita => (
              <div
                key={receita.id}
                className={`p-3 border rounded-lg cursor-pointer transition-all duration-200 ${
                  receitasSelecionadas.includes(receita.id)
                    ? 'border-primary-500 bg-primary-50 dark:bg-primary-900/30 shadow-sm'
                    : 'border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600'
                }`}
                onClick={() => toggleReceitaSelecionada(receita.id)}
              >
                <div className="flex items-start gap-3">
                  <Checkbox
                    id={`receita-${receita.id}`}
                    checked={receitasSelecionadas.includes(receita.id)}
                    onChange={() => {}} // Click handled by container
                    className="mt-1"
                  />
                  <div className="flex-grow">
                    <label htmlFor={`receita-${receita.id}`} className="font-medium cursor-pointer">{receita.nome}</label>
                    {receitasSelecionadas.includes(receita.id) && (
                      <div className="mt-2 flex items-center gap-2">
                        <label htmlFor={`porcoes-${receita.id}`} className="text-sm">Porções:</label>
                        <Input
                          id={`porcoes-${receita.id}`}
                          type="number"
                          value={porcoes[receita.id] || String(receita.porcoes || 1)}
                          onChange={(e) => {
                            e.stopPropagation(); // Prevent card click
                            atualizarPorcoes(receita.id, e.target.value);
                          }}
                          onClick={(e) => e.stopPropagation()} // Prevent card click
                          min={1}
                          className="w-16 h-8 text-sm p-1"
                        />
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </section>

      {/* Shopping List Section */}
      {receitasSelecionadas.length > 0 && (
        <section>
          <h2 className="text-xl font-semibold mb-4">2. Sua Lista de Compras</h2>
          {listaCompras.length === 0 ? (
            <p className="text-gray-500 italic">
              Nenhum ingrediente encontrado nas receitas selecionadas ou as quantidades resultaram em zero.
            </p>
          ) : (
            <>
              <div className="mb-4 flex flex-wrap gap-2">
                <Button
                  onClick={() => setItensComprados([])}
                  variant="outline"
                  size="sm"
                  disabled={itensComprados.length === 0}
                >
                  Desmarcar Todos
                </Button>
                <Button
                  onClick={() => setItensComprados(listaCompras.map(i => i.key))}
                  variant="outline"
                  size="sm"
                  disabled={itensComprados.length === listaCompras.length}
                >
                  Marcar Todos Como Comprados
                </Button>
                {/* Add Print/Share button later */}
                 {/* <Button variant="outline" size="sm" onClick={() => window.print()}>Imprimir</Button> */}
              </div>

              <ul className="space-y-2 mb-6 border rounded-lg p-4 bg-gray-50 dark:bg-gray-800/50">
                {listaCompras.map((item) => {
                  const isComprado = itensComprados.includes(item.key);
                  return (
                    <li
                      key={item.key}
                      className={`flex items-center gap-3 p-2 border-b last:border-b-0 dark:border-gray-700 ${
                        isComprado ? 'opacity-60' : ''
                      }`}
                    >
                      <Checkbox
                        id={`item-${item.key}`}
                        checked={isComprado}
                        onChange={() => toggleItemComprado(item.key)}
                      />
                      <label
                        htmlFor={`item-${item.key}`}
                        className={`flex-grow cursor-pointer ${isComprado ? 'line-through text-gray-500 dark:text-gray-400' : ''}`}
                      >
                        <span className="font-medium inline-block w-24 text-right mr-2">
                          {formatarQuantidade(item.quantidadeTotal)} {item.unidade}
                        </span>
                        <span>{item.nome}</span>
                      </label>
                    </li>
                  );
                })}
              </ul>
              {/* Add Share functionality later */}
              {/* <Button color="primary">Compartilhar Lista</Button> */}
            </>
          )}
        </section>
      )}
    </div>
  );
}
</file>

<file path="app/components/receitas/ListaReceitas.tsx">
import React from 'react';
import Link from 'next/link';
import { Receita } from '../../stores/receitasStore'; // Import the Receita type
import { Card } from '../ui/Card'; // Assuming Card component exists
import { Tag } from '../ui/Tag'; // Import Tag component

interface ListaReceitasProps {
  receitas: Receita[];
}

export function ListaReceitas({ receitas }: ListaReceitasProps) {
  if (receitas.length === 0) {
    return <p className="text-gray-500">Nenhuma receita encontrada.</p>;
  }

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
      {receitas.map((receita) => (
        <Link href={`/receitas/${receita.id}`} key={receita.id} legacyBehavior>
          <a className="block group">
            <Card className="h-full flex flex-col transition-shadow duration-200 group-hover:shadow-lg">
              <div className="relative h-40 w-full bg-gray-200 rounded-t-lg overflow-hidden">
                {receita.imagem ? (
                  <img
                    src={receita.imagem}
                    alt={receita.nome}
                    className="w-full h-full object-cover"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center text-gray-400">
                    <span>Sem imagem</span>
                  </div>
                )}
              </div>
              <div className="p-4 flex flex-col flex-grow">
                <h3 className="text-lg font-semibold mb-2 group-hover:text-primary-600">
                  {receita.nome}
                </h3>
                {receita.descricao && (
                   <p className="text-sm text-gray-600 mb-3 line-clamp-2 flex-grow">
                     {receita.descricao}
                   </p>
                )}
                <div className="mt-auto pt-2">
                   {receita.tags?.slice(0, 3).map((tag) => (
                     <Tag key={tag} className="mr-1 mb-1">{tag}</Tag>
                   ))}
                   {receita.tags?.length > 3 && <Tag className="mr-1 mb-1">...</Tag>}
                </div>
              </div>
            </Card>
          </a>
        </Link>
      ))}
    </div>
  );
}
</file>

<file path="app/components/saude/FatoresHumor.tsx">
'use client'

import { useMemo } from 'react'
import { RegistroHumor } from '@/app/store'
import { Card } from '../ui/Card'
import { Badge } from '../ui/Badge'

interface FatoresHumorProps {
  registros: RegistroHumor[]
  limite?: number
}

export function FatoresHumor({ registros, limite = 5 }: FatoresHumorProps) {
  // Calcula os fatores mais comuns
  const fatoresMaisComuns = useMemo(() => {
    const contagem: Record<string, number> = {}
    
    // Conta a ocorrência de cada fator
    registros.forEach(registro => {
      registro.fatores.forEach(fator => {
        contagem[fator] = (contagem[fator] || 0) + 1
      })
    })
    
    // Converte para array e ordena
    return Object.entries(contagem)
      .sort((a, b) => b[1] - a[1])
      .slice(0, limite)
      .map(([fator, count]) => ({
        fator,
        count,
        percentual: Math.round((count / registros.length) * 100)
      }))
  }, [registros, limite])
  
  if (registros.length === 0) {
    return (
      <Card className="p-4 text-center text-gray-500 dark:text-gray-400">
        Nenhum registro de humor encontrado
      </Card>
    )
  }
  
  return (
    <Card>
      <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
        Fatores Mais Comuns
      </h3>
      
      {fatoresMaisComuns.length === 0 ? (
        <p className="text-sm text-gray-500 dark:text-gray-400">
          Nenhum fator registrado ainda
        </p>
      ) : (
        <div className="space-y-2">
          {fatoresMaisComuns.map(({ fator, count, percentual }) => (
            <div key={fator} className="flex items-center justify-between">
              <div className="flex items-center">
                <Badge variant="secondary" className="mr-2">
                  {percentual}%
                </Badge>
                <span className="text-sm text-gray-700 dark:text-gray-300">
                  {fator}
                </span>
              </div>
              <span className="text-xs text-gray-500 dark:text-gray-400">
                {count} {count === 1 ? 'ocorrência' : 'ocorrências'}
              </span>
            </div>
          ))}
        </div>
      )}
    </Card>
  )
}
</file>

<file path="app/components/saude/HumorCalendar.tsx">
'use client'

import { useMemo } from 'react'
import { RegistroHumor } from '@/app/store'
import { cn } from '@/app/lib/utils'

interface HumorCalendarProps {
  registros: RegistroHumor[]
  mes: number
  ano: number
  onSelectDay: (data: string) => void
}

export function HumorCalendar({ registros, mes, ano, onSelectDay }: HumorCalendarProps) {
  // Gera os dias do mês selecionado
  const diasDoMes = useMemo(() => {
    const resultado = []
    const primeiroDia = new Date(ano, mes, 1)
    const ultimoDia = new Date(ano, mes + 1, 0)
    const diasNoMes = ultimoDia.getDate()
    
    // Preenche com dias vazios até o primeiro dia do mês
    const diaDaSemanaInicial = primeiroDia.getDay()
    for (let i = 0; i < diaDaSemanaInicial; i++) {
      resultado.push({ dia: 0, data: '' })
    }
    
    // Adiciona os dias do mês
    for (let dia = 1; dia <= diasNoMes; dia++) {
      const data = `${ano}-${String(mes + 1).padStart(2, '0')}-${String(dia).padStart(2, '0')}`
      resultado.push({ dia, data })
    }
    
    return resultado
  }, [mes, ano])
  
  // Mapeia os registros por data para fácil acesso
  const registrosPorData = useMemo(() => {
    const mapa: Record<string, RegistroHumor> = {}
    registros.forEach(registro => {
      mapa[registro.data] = registro
    })
    return mapa
  }, [registros])
  
  // Cores para os diferentes níveis de humor
  const coresHumor = {
    1: 'bg-red-500',
    2: 'bg-orange-400',
    3: 'bg-yellow-300',
    4: 'bg-green-300',
    5: 'bg-green-500',
  }
  
  // Nomes dos dias da semana
  const diasDaSemana = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb']
  
  return (
    <div className="w-full">
      <div className="grid grid-cols-7 gap-1 mb-1">
        {diasDaSemana.map((dia) => (
          <div 
            key={dia} 
            className="text-xs text-center font-medium text-gray-500 dark:text-gray-400"
          >
            {dia}
          </div>
        ))}
      </div>
      
      <div className="grid grid-cols-7 gap-1">
        {diasDoMes.map((item, index) => {
          if (item.dia === 0) {
            return <div key={`empty-${index}`} className="h-8 rounded-md" />
          }
          
          const registro = registrosPorData[item.data]
          const nivelHumor = registro?.nivel
          
          return (
            <button
              key={item.data}
              onClick={() => onSelectDay(item.data)}
              className={cn(
                "h-8 rounded-md flex items-center justify-center text-xs relative",
                nivelHumor 
                  ? coresHumor[nivelHumor as keyof typeof coresHumor] 
                  : "bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700",
                nivelHumor && "hover:opacity-80"
              )}
              aria-label={`Dia ${item.dia}, nível de humor ${nivelHumor || 'não registrado'}`}
            >
              {item.dia}
            </button>
          )
        })}
      </div>
    </div>
  )
}
</file>

<file path="app/components/saude/MedicamentosList.tsx">
'use client'

import { useMemo } from 'react'
import { Medicamento } from '@/app/store'
import { Card } from '../ui/Card'
import { Badge } from '../ui/Badge'
import { Pill, Clock, Edit, Trash2 } from 'lucide-react'
import { Button } from '../ui/Button'
import { format } from 'date-fns'
import { ptBR } from 'date-fns/locale'
import { Check, X, AlertCircle } from 'lucide-react'
import { Tooltip } from '../ui/Tooltip'

interface MedicamentosListProps {
  medicamentos: Medicamento[]
  onEdit: (id: string) => void
  onDelete: (id: string) => void
  onRegistrarTomada: (id: string) => void
}

export function MedicamentosList({
  medicamentos,
  onEdit,
  onDelete,
  onRegistrarTomada,
}: MedicamentosListProps) {
  // Ordena medicamentos por nome
  const medicamentosOrdenados = useMemo(() => {
    return [...medicamentos].sort((a, b) => a.nome.localeCompare(b.nome))
  }, [medicamentos])
  
  // Verifica se um medicamento foi tomado hoje
  const foiTomadoHoje = (medicamento: Medicamento) => {
    if (!medicamento.ultimaTomada) return false
    
    const hoje = new Date().toISOString().split('T')[0]
    return medicamento.ultimaTomada.includes(hoje)
  }
  
  // Função auxiliar para calcular se já pode tomar outra dose
  const podeTomar = (medicamento: Medicamento) => {
    if (!medicamento.ultimaTomada || !medicamento.intervalo) return true;
    
    const ultimaTomada = new Date(medicamento.ultimaTomada);
    const agora = new Date();
    const intervaloEmMinutos = medicamento.intervalo;
    
    // Calcula a diferença em minutos
    const diffEmMinutos = Math.floor((agora.getTime() - ultimaTomada.getTime()) / (1000 * 60));
    
    return diffEmMinutos >= intervaloEmMinutos;
  };
  
  // Formatar o tempo restante para próxima dose
  const formatarTempoRestante = (medicamento: Medicamento) => {
    if (!medicamento.ultimaTomada || !medicamento.intervalo) return "";
    
    const ultimaTomada = new Date(medicamento.ultimaTomada);
    const agora = new Date();
    const intervaloEmMinutos = medicamento.intervalo;
    
    // Calcula a diferença em minutos
    const diffEmMinutos = Math.floor((agora.getTime() - ultimaTomada.getTime()) / (1000 * 60));
    const minutosRestantes = intervaloEmMinutos - diffEmMinutos;
    
    if (minutosRestantes <= 0) return "";
    
    const horasRestantes = Math.floor(minutosRestantes / 60);
    const minRestantes = minutosRestantes % 60;
    
    if (horasRestantes > 0) {
      return `${horasRestantes}h${minRestantes > 0 ? ` ${minRestantes}min` : ''}`;
    }
    return `${minRestantes}min`;
  };

  if (medicamentosOrdenados.length === 0) {
    return (
      <div className="text-center py-8 border border-dashed border-gray-300 dark:border-gray-600 rounded-lg">
        <Pill className="mx-auto h-10 w-10 text-gray-400 mb-2" />
        <p className="text-gray-500 dark:text-gray-400">
          Você ainda não tem medicamentos cadastrados.
        </p>
        <p className="text-gray-400 dark:text-gray-500 text-sm mt-1">
          Adicione seu primeiro medicamento clicando no botão acima.
        </p>
      </div>
    )
  }

  return (
    <div className="space-y-4">
      {medicamentosOrdenados.map((medicamento) => {
        const tomadoHoje = medicamento.ultimaTomada
          ? new Date(medicamento.ultimaTomada).toISOString().split('T')[0] === new Date().toISOString().split('T')[0]
          : false;
          
        const tempoRestante = formatarTempoRestante(medicamento);
        const liberadoParaTomar = podeTomar(medicamento);

        return (
          <div
            key={medicamento.id}
            className={`p-4 bg-white dark:bg-gray-800 border rounded-lg ${
              tomadoHoje
                ? 'border-green-200 dark:border-green-900'
                : 'border-gray-200 dark:border-gray-700'
            }`}
          >
            <div className="flex items-start justify-between">
              <div className="flex-1">
                <div className="flex items-center mb-1">
                  <h3 className="font-medium text-gray-900 dark:text-white">
                    {medicamento.nome}
                  </h3>
                  {medicamento.dosagem && (
                    <Badge className="ml-2" variant="outline">
                      {medicamento.dosagem}
                    </Badge>
                  )}
                </div>

                <div className="flex flex-wrap gap-1 mt-2">
                  {medicamento.horarios.map((horario) => (
                    <Badge key={horario} variant="secondary" className="flex items-center">
                      <Clock className="h-3 w-3 mr-1" />
                      {horario}
                    </Badge>
                  ))}
                </div>
                
                {medicamento.frequencia && (
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">
                    Frequência: {medicamento.frequencia}
                  </p>
                )}
                
                {medicamento.intervalo && (
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                    Intervalo: {medicamento.intervalo >= 60 
                      ? `${Math.floor(medicamento.intervalo / 60)} hora${medicamento.intervalo >= 120 ? 's' : ''}` 
                      : `${medicamento.intervalo} minutos`}
                  </p>
                )}
                
                {medicamento.ultimaTomada && (
                  <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">
                    Última dose: {format(new Date(medicamento.ultimaTomada), "dd/MM/yyyy 'às' HH:mm", { locale: ptBR })}
                    {tempoRestante && (
                      <span className="ml-2 text-yellow-600 dark:text-yellow-400">
                        <AlertCircle className="inline h-3 w-3 mr-1" />
                        Próxima dose em {tempoRestante}
                      </span>
                    )}
                  </p>
                )}
              </div>

              <div className="flex flex-col gap-2 ml-4">
                <Tooltip content={liberadoParaTomar ? "Registrar dose tomada" : "Aguarde o intervalo entre doses"}>
                  <Button
                    size="icon"
                    variant={tomadoHoje ? "success" : "primary"}
                    onClick={() => onRegistrarTomada(medicamento.id)}
                    disabled={!liberadoParaTomar}
                    aria-label="Registrar dose tomada"
                  >
                    {tomadoHoje ? <Check className="h-4 w-4" /> : <Pill className="h-4 w-4" />}
                  </Button>
                </Tooltip>
                
                <Button
                  size="icon"
                  variant="outline"
                  onClick={() => onEdit(medicamento.id)}
                  aria-label="Editar medicamento"
                >
                  <Edit className="h-4 w-4" />
                </Button>
                
                <Button
                  size="icon"
                  variant="outline"
                  color="danger"
                  onClick={() => onDelete(medicamento.id)}
                  aria-label="Excluir medicamento"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>
        )
      })}
    </div>
  )
}

// Importando o utilitário cn
import { cn } from '@/app/lib/utils'
</file>

<file path="app/components/saude/MonitoramentoHumor.tsx">
'use client'

import { useState, useCallback, useMemo } from 'react'
import { Calendar, Plus, X, Edit, Trash, Smile, Frown, Meh, AlertCircle } from 'lucide-react'
import { useAppStore } from '@/app/store'
import { Card } from '../ui/Card'
import { Button } from '../ui/Button'
import { Input } from '../ui/Input'
import { Textarea } from '../ui/Textarea'
import { Badge } from '../ui/Badge'
import { Modal } from '../ui/Modal'
import { Alert } from '../ui/Alert'
import { StatCard } from './StatCard'
import { HumorCalendar } from './HumorCalendar'
import { FatoresHumor } from './FatoresHumor'

export function MonitoramentoHumor() {
  // Usar o Zustand para gerenciamento de estado
  const { registrosHumor, adicionarRegistroHumor, atualizarRegistroHumor, removerRegistroHumor } = useAppStore(
    (state) => ({
      registrosHumor: state.registrosHumor || [],
      adicionarRegistroHumor: state.adicionarRegistroHumor,
      atualizarRegistroHumor: state.atualizarRegistroHumor,
      removerRegistroHumor: state.removerRegistroHumor,
    })
  )
  
  const [novoRegistro, setNovoRegistro] = useState({
    data: new Date().toISOString().split('T')[0],
    nivel: 3,
    fatores: [] as string[],
    notas: '',
  })
  
  const [editandoId, setEditandoId] = useState<string | null>(null)
  const [mostrarForm, setMostrarForm] = useState(false)
  const [novoFator, setNovoFator] = useState('')
  const [mesAtual, setMesAtual] = useState(() => new Date().getMonth())
  const [anoAtual, setAnoAtual] = useState(() => new Date().getFullYear())
  const [erro, setErro] = useState('')

  // Usar useCallback para funções que são passadas como props ou dependências
  const handleAdicionarRegistro = useCallback(() => {
    if (!novoRegistro.data) {
      setErro('A data é obrigatória')
      return
    }

    adicionarRegistroHumor({
      data: novoRegistro.data,
      nivel: novoRegistro.nivel,
      fatores: [...novoRegistro.fatores],
      notas: novoRegistro.notas,
    })
    
    resetForm()
  }, [adicionarRegistroHumor, novoRegistro])

  const iniciarEdicao = useCallback((registro: typeof registrosHumor[0]) => {
    setEditandoId(registro.id)
    setNovoRegistro({
      data: registro.data,
      nivel: registro.nivel,
      fatores: [...registro.fatores],
      notas: registro.notas,
    })
    setMostrarForm(true)
  }, [])

  const salvarEdicao = useCallback(() => {
    if (!editandoId || !novoRegistro.data) {
      setErro('A data é obrigatória')
      return
    }

    atualizarRegistroHumor(editandoId, {
      data: novoRegistro.data,
      nivel: novoRegistro.nivel,
      fatores: [...novoRegistro.fatores],
      notas: novoRegistro.notas,
    })
    
    resetForm()
  }, [atualizarRegistroHumor, editandoId, novoRegistro])

  const adicionarFator = useCallback(() => {
    if (!novoFator) return
    
    if (novoRegistro.fatores.includes(novoFator)) {
      setErro('Este fator já foi adicionado')
      return
    }
    
    setNovoRegistro({
      ...novoRegistro,
      fatores: [...novoRegistro.fatores, novoFator],
    })
    
    setNovoFator('')
    setErro('')
  }, [novoFator, novoRegistro])

  const removerFator = useCallback((fator: string) => {
    setNovoRegistro({
      ...novoRegistro,
      fatores: novoRegistro.fatores.filter((f) => f !== fator),
    })
  }, [novoRegistro])

  const resetForm = useCallback(() => {
    setNovoRegistro({
      data: new Date().toISOString().split('T')[0],
      nivel: 3,
      fatores: [],
      notas: '',
    })
    setEditandoId(null)
    setMostrarForm(false)
    setNovoFator('')
    setErro('')
  }, [])

  // Usar useMemo para cálculos ou transformações de dados
  const registrosOrdenados = useMemo(() => {
    return [...registrosHumor].sort((a, b) => new Date(b.data).getTime() - new Date(a.data).getTime())
  }, [registrosHumor])

  const registrosPorMes = useMemo(() => {
    const meses: Record<string, typeof registrosHumor> = {}
    
    registrosOrdenados.forEach((registro) => {
      const [ano, mes] = registro.data.split('-')
      const chave = `${ano}-${mes}`
      
      if (!meses[chave]) {
        meses[chave] = []
      }
      
      meses[chave].push(registro)
    })
    
    return meses
  }, [registrosOrdenados])

  const humorMedio = useMemo(() => {
    if (registrosHumor.length === 0) return 0
    
    const soma = registrosHumor.reduce((acc, registro) => acc + registro.nivel, 0)
    return (soma / registrosHumor.length).toFixed(1)
  }, [registrosHumor])

  const tendenciaHumor = useMemo(() => {
    if (registrosHumor.length < 5) return null
    
    const registrosRecentes = [...registrosHumor]
      .sort((a, b) => new Date(b.data).getTime() - new Date(a.data).getTime())
      .slice(0, 5)
    
    const registrosAnteriores = [...registrosHumor]
      .sort((a, b) => new Date(b.data).getTime() - new Date(a.data).getTime())
      .slice(5, 10)
    
    if (registrosAnteriores.length === 0) return null
    
    const mediaRecente = registrosRecentes.reduce((acc, reg) => acc + reg.nivel, 0) / registrosRecentes.length
    const mediaAnterior = registrosAnteriores.reduce((acc, reg) => acc + reg.nivel, 0) / registrosAnteriores.length
    
    const diferenca = ((mediaRecente - mediaAnterior) / mediaAnterior) * 100
    
    return {
      valor: Math.abs(Number(diferenca.toFixed(0))),
      positivo: diferenca > 0
    }
  }, [registrosHumor])

  const formatarData = useCallback((data: string) => {
    return new Date(data).toLocaleDateString('pt-BR', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    })
  }, [])

  const handleMesAnterior = useCallback(() => {
    setMesAtual(prev => {
      if (prev === 0) {
        setAnoAtual(ano => ano - 1)
        return 11
      }
      return prev - 1
    })
  }, [])

  const handleProximoMes = useCallback(() => {
    setMesAtual(prev => {
      if (prev === 11) {
        setAnoAtual(ano => ano + 1)
        return 0
      }
      return prev + 1
    })
  }, [])

  const handleSelecionarDia = useCallback((data: string) => {
    const registroExistente = registrosHumor.find(r => r.data === data)
    
    if (registroExistente) {
      iniciarEdicao(registroExistente)
    } else {
      setNovoRegistro(prev => ({ ...prev, data }))
      setMostrarForm(true)
      setEditandoId(null)
    }
  }, [registrosHumor, iniciarEdicao])

  const nomeDoMes = useMemo(() => {
    return new Date(anoAtual, mesAtual).toLocaleDateString('pt-BR', { month: 'long' })
  }, [mesAtual, anoAtual])

  return (
    <div className="space-y-6">
      <div className="flex flex-col gap-4">
        <Card className="flex-1">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
              Monitoramento de Humor
            </h2>
            <Button
              onClick={() => {
                resetForm()
                setMostrarForm(true)
              }}
              icon={<Plus className="h-4 w-4" />}
              aria-label="Adicionar novo registro de humor"
            >
              Novo Registro
            </Button>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <StatCard
              title="Humor Médio"
              value={humorMedio}
              icon={<Smile className="h-5 w-5" />}
              description="Baseado em todos os registros"
              trend={tendenciaHumor ? {
                value: Number(tendenciaHumor.valor),
                label: "últimos registros",
                positive: tendenciaHumor.positivo
              } : undefined}
            />
            
            <div className="md:col-span-2">
              <FatoresHumor registros={registrosHumor} />
            </div>
          </div>
          
          <div className="mb-6">
            <div className="flex flex-wrap justify-between items-center mb-3 gap-2">
              <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                Calendário de Humor
              </h3>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleMesAnterior}
                  aria-label="Mês anterior"
                >
                  &larr;
                </Button>
                <span className="text-sm font-medium whitespace-nowrap">
                  {nomeDoMes} {anoAtual}
                </span>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleProximoMes}
                  aria-label="Próximo mês"
                >
                  &rarr;
                </Button>
              </div>
            </div>
            
            <div className="overflow-x-auto">
              <HumorCalendar
                registros={registrosHumor}
                mes={mesAtual}
                ano={anoAtual}
                onSelectDay={handleSelecionarDia}
              />
            </div>
          </div>
          
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
            Registros Recentes
          </h3>
          
          {registrosOrdenados.length === 0 ? (
            <Alert
              variant="info"
              title="Nenhum registro encontrado"
            >
              Adicione seu primeiro registro de humor usando o botão "Novo Registro".
            </Alert>
          ) : (
            <div className="space-y-3">
              {registrosOrdenados.slice(0, 5).map((registro) => (
                <Card key={registro.id} className="p-4">
                  <div className="flex justify-between items-start">
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2 mb-1 flex-wrap">
                        <span className="font-medium text-gray-900 dark:text-white">
                          {formatarData(registro.data)}
                        </span>
                        <div className="flex items-center">
                          {[1, 2, 3, 4, 5].map((nivel) => (
                            <span
                              key={nivel}
                              className={`w-5 h-5 rounded-full flex items-center justify-center text-xs ${
                                nivel <= registro.nivel
                                  ? 'bg-saude-primary text-white'
                                  : 'bg-gray-200 dark:bg-gray-700 text-gray-500 dark:text-gray-400'
                              }`}
                              aria-label={`Nível ${nivel} de 5`}
                            >
                              {nivel}
                            </span>
                          ))}
                        </div>
                      </div>
                      
                      {registro.fatores.length > 0 && (
                        <div className="flex flex-wrap gap-1 mb-2">
                          {registro.fatores.map((fator) => (
                            <Badge key={fator} variant="secondary">
                              {fator}
                            </Badge>
                          ))}
                        </div>
                      )}
                      
                      {registro.notas && (
                        <p className="text-sm text-gray-600 dark:text-gray-300 break-words">
                          {registro.notas}
                        </p>
                      )}
                    </div>
                    
                    <div className="flex gap-1 ml-2 flex-shrink-0">
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => iniciarEdicao(registro)}
                        aria-label="Editar registro"
                      >
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => removerRegistroHumor(registro.id)}
                        aria-label="Remover registro"
                      >
                        <Trash className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                </Card>
              ))}
            </div>
          )}
        </Card>
      </div>

      {/* Modal para adicionar/editar registro */}
      <Modal
        isOpen={mostrarForm}
        onClose={resetForm}
        title={editandoId ? "Editar Registro de Humor" : "Novo Registro de Humor"}
        footer={
          <div className="flex justify-end gap-2">
            <Button variant="outline" onClick={resetForm}>
              Cancelar
            </Button>
            <Button 
              onClick={editandoId ? salvarEdicao : handleAdicionarRegistro}
            >
              {editandoId ? "Salvar Alterações" : "Adicionar Registro"}
            </Button>
          </div>
        }
      >
        {erro && (
          <Alert variant="error" className="mb-4">
            {erro}
          </Alert>
        )}
        
        <div className="space-y-4">
          <Input
            type="date"
            value={novoRegistro.data}
            onChange={(e) => setNovoRegistro({ ...novoRegistro, data: e.target.value })}
            label="Data"
            required
          />
          
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Nível de Humor (1-5)
            </label>
            <div className="flex gap-2">
              {[1, 2, 3, 4, 5].map((nivel) => (
                <button
                  key={nivel}
                  type="button"
                  onClick={() => setNovoRegistro({ ...novoRegistro, nivel })}
                  className={`w-10 h-10 rounded-full flex items-center justify-center ${
                    nivel === novoRegistro.nivel
                      ? 'bg-saude-primary text-white'
                      : 'bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600'
                  }`}
                  aria-label={`Nível de humor ${nivel}`}
                  aria-pressed={nivel === novoRegistro.nivel}
                >
                  {nivel}
                </button>
              ))}
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Fatores que Influenciaram
            </label>
            <div className="flex gap-2 mb-2">
              <Input
                value={novoFator}
                onChange={(e) => setNovoFator(e.target.value)}
                placeholder="Adicionar fator..."
                className="flex-1"
              />
              <Button
                onClick={adicionarFator}
                disabled={!novoFator}
                aria-label="Adicionar fator"
              >
                <Plus className="h-4 w-4" />
              </Button>
            </div>
            
            {novoRegistro.fatores.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {novoRegistro.fatores.map((fator) => (
                  <Badge key={fator} variant="secondary" className="flex items-center gap-1">
                    {fator}
                    <button
                      onClick={() => removerFator(fator)}
                      className="ml-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                      aria-label={`Remover fator ${fator}`}
                    >
                      <X className="h-3 w-3" />
                    </button>
                  </Badge>
                ))}
              </div>
            )}
          </div>
          
          <Textarea
            value={novoRegistro.notas}
            onChange={(e) => setNovoRegistro({ ...novoRegistro, notas: e.target.value })}
            label="Notas (opcional)"
            placeholder="Adicione detalhes sobre como você se sentiu..."
          />
        </div>
      </Modal>
    </div>
  )
}
</file>

<file path="app/components/saude/RegistroMedicamentos.tsx">
'use client'

import { useState, useCallback, useMemo } from 'react'
import { Pill, Plus, X, Edit, Trash, Check, Clock, Calendar } from 'lucide-react'
import { useAppStore } from '@/app/store'
import { Card } from '../ui/Card'
import { Button } from '../ui/Button'
import { Input } from '../ui/Input'
import { Textarea } from '../ui/Textarea'
import { Select } from '../ui/Select'
import { Badge } from '../ui/Badge'
import { Modal } from '../ui/Modal'
import { Alert } from '../ui/Alert'
import { MedicamentosList } from './MedicamentosList'
import { StatCard } from './StatCard'

export function RegistroMedicamentos() {
  // Usar o Zustand para gerenciamento de estado
  const { medicamentos, adicionarMedicamento, atualizarMedicamento, removerMedicamento, registrarTomadaMedicamento } = useAppStore(
    (state) => ({
      medicamentos: state.medicamentos || [],
      adicionarMedicamento: state.adicionarMedicamento,
      atualizarMedicamento: state.atualizarMedicamento,
      removerMedicamento: state.removerMedicamento,
      registrarTomadaMedicamento: state.registrarTomadaMedicamento,
    })
  )
  
  const [novoMedicamento, setNovoMedicamento] = useState({
    nome: '',
    dosagem: '',
    frequencia: 'Diária',
    horarios: ['08:00'],
    observacoes: '',
    dataInicio: new Date().toISOString().split('T')[0],
    intervalo: 240, // 4 horas por padrão (em minutos)
  })
  
  const [editandoId, setEditandoId] = useState<string | null>(null)
  const [mostrarForm, setMostrarForm] = useState(false)
  const [novoHorario, setNovoHorario] = useState('08:00')
  const [erro, setErro] = useState('')

  // Usar useCallback para funções que são passadas como props ou dependências
  const handleAdicionarMedicamento = useCallback(() => {
    if (!novoMedicamento.nome) {
      setErro('O nome do medicamento é obrigatório')
      return
    }

    if (novoMedicamento.horarios.length === 0) {
      setErro('Adicione pelo menos um horário')
      return
    }
    
    adicionarMedicamento({
      nome: novoMedicamento.nome,
      dosagem: novoMedicamento.dosagem,
      frequencia: novoMedicamento.frequencia,
      horarios: [...novoMedicamento.horarios],
      observacoes: novoMedicamento.observacoes,
      dataInicio: novoMedicamento.dataInicio,
      ultimaTomada: null,
      intervalo: novoMedicamento.intervalo,
    })
    
    resetForm()
  }, [adicionarMedicamento, novoMedicamento])

  const iniciarEdicao = useCallback((id: string) => {
    const medicamento = medicamentos.find(med => med.id === id);
    if (!medicamento) return;
    
    setEditandoId(medicamento.id)
    setNovoMedicamento({
      nome: medicamento.nome,
      dosagem: medicamento.dosagem,
      frequencia: medicamento.frequencia,
      horarios: [...medicamento.horarios],
      observacoes: medicamento.observacoes,
      dataInicio: medicamento.dataInicio,
      intervalo: medicamento.intervalo || 240, // Se não tiver intervalo definido, usar 4 horas como padrão
    })
    setMostrarForm(true)
  }, [medicamentos])

  const salvarEdicao = useCallback(() => {
    if (!editandoId || !novoMedicamento.nome) {
      setErro('O nome do medicamento é obrigatório')
      return
    }

    if (novoMedicamento.horarios.length === 0) {
      setErro('Adicione pelo menos um horário')
      return
    }
    
    atualizarMedicamento(editandoId, {
      nome: novoMedicamento.nome,
      dosagem: novoMedicamento.dosagem,
      frequencia: novoMedicamento.frequencia,
      horarios: [...novoMedicamento.horarios],
      observacoes: novoMedicamento.observacoes,
      dataInicio: novoMedicamento.dataInicio,
      intervalo: novoMedicamento.intervalo,
    })
    
    resetForm()
  }, [atualizarMedicamento, editandoId, novoMedicamento])

  const adicionarHorario = useCallback(() => {
    if (!novoHorario) return
    
    if (novoMedicamento.horarios.includes(novoHorario)) {
      setErro('Este horário já foi adicionado')
      return
    }
    
    setNovoMedicamento({
      ...novoMedicamento,
      horarios: [...novoMedicamento.horarios, novoHorario].sort(),
    })
    
    setNovoHorario('08:00')
    setErro('')
  }, [novoHorario, novoMedicamento])

  const removerHorario = useCallback((horario: string) => {
    setNovoMedicamento({
      ...novoMedicamento,
      horarios: novoMedicamento.horarios.filter((h) => h !== horario),
    })
  }, [novoMedicamento])

  const handleRegistrarTomada = useCallback((id: string) => {
    const agora = new Date().toISOString()
    registrarTomadaMedicamento(id, agora)
  }, [registrarTomadaMedicamento])

  const resetForm = useCallback(() => {
    setNovoMedicamento({
      nome: '',
      dosagem: '',
      frequencia: 'Diária',
      horarios: ['08:00'],
      observacoes: '',
      dataInicio: new Date().toISOString().split('T')[0],
      intervalo: 240, // 4 horas por padrão
    })
    setEditandoId(null)
    setMostrarForm(false)
    setNovoHorario('08:00')
    setErro('')
  }, [])

  // Estatísticas sobre medicamentos
  const estatisticas = useMemo(() => {
    const total = medicamentos.length
    const tomadosHoje = medicamentos.filter(med => {
      if (!med.ultimaTomada) return false
      const dataUltimaTomada = med.ultimaTomada.split('T')[0]
      const hoje = new Date().toISOString().split('T')[0]
      return dataUltimaTomada === hoje
    }).length
    
    const percentualTomados = total > 0 ? Math.round((tomadosHoje / total) * 100) : 0
    
    return {
      total,
      tomadosHoje,
      percentualTomados
    }
  }, [medicamentos])

  // Próxima dose calculada
  const proximaDose = useMemo(() => {
    if (medicamentos.length === 0) return { texto: "N/A", descricao: "Sem medicamentos" };
    
    const agora = new Date();
    const medicamentosOrdenados = [...medicamentos].sort((a, b) => {
      // Encontrar o próximo horário para cada medicamento
      const horariosA = a.horarios.map(h => {
        const [hora, minuto] = h.split(':').map(Number);
        const dataHora = new Date(agora);
        dataHora.setHours(hora, minuto, 0, 0);
        // Se o horário já passou hoje, considerar para amanhã
        if (dataHora < agora) {
          dataHora.setDate(dataHora.getDate() + 1);
        }
        return dataHora;
      });
      
      const horariosB = b.horarios.map(h => {
        const [hora, minuto] = h.split(':').map(Number);
        const dataHora = new Date(agora);
        dataHora.setHours(hora, minuto, 0, 0);
        if (dataHora < agora) {
          dataHora.setDate(dataHora.getDate() + 1);
        }
        return dataHora;
      });
      
      // Pegar o próximo horário mais próximo para cada medicamento
      const proximoA = horariosA.sort((x, y) => x.getTime() - y.getTime())[0];
      const proximoB = horariosB.sort((x, y) => x.getTime() - y.getTime())[0];
      
      return proximoA.getTime() - proximoB.getTime();
    });
    
    // Pegar o primeiro medicamento (o com próxima dose mais próxima)
    const proximoMedicamento = medicamentosOrdenados[0];
    
    // Calcular quanto tempo falta
    const proximoHorario = proximoMedicamento.horarios
      .map(h => {
        const [hora, minuto] = h.split(':').map(Number);
        const dataHora = new Date(agora);
        dataHora.setHours(hora, minuto, 0, 0);
        if (dataHora < agora) {
          dataHora.setDate(dataHora.getDate() + 1);
        }
        return dataHora;
      })
      .sort((a, b) => a.getTime() - b.getTime())[0];
    
    const diffMs = proximoHorario.getTime() - agora.getTime();
    const diffHoras = Math.floor(diffMs / (1000 * 60 * 60));
    const diffMinutos = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    let textoTempo;
    if (diffHoras > 0) {
      textoTempo = `${diffHoras}h${diffMinutos > 0 ? ` ${diffMinutos}m` : ''}`;
    } else {
      textoTempo = `${diffMinutos}m`;
    }
    
    return {
      texto: textoTempo,
      descricao: proximoMedicamento.nome
    };
  }, [medicamentos])

  // Opções para frequência de medicamentos
  const opcoesFrequencia = [
    { value: 'Diária', label: 'Diária' },
    { value: 'Semanal', label: 'Semanal' },
    { value: 'Mensal', label: 'Mensal' },
    { value: 'Conforme necessário', label: 'Conforme necessário' },
  ]

  // Opções para intervalo entre doses
  const opcoesIntervalo = [
    { value: '60', label: '1 hora' },
    { value: '120', label: '2 horas' },
    { value: '180', label: '3 horas' },
    { value: '240', label: '4 horas' },
    { value: '360', label: '6 horas' },
    { value: '480', label: '8 horas' },
    { value: '720', label: '12 horas' },
    { value: '1440', label: '24 horas' },
  ]

  return (
    <div className="space-y-6">
      <div className="flex flex-col gap-4">
        <Card className="flex-1">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
              Registro de Medicamentos
            </h2>
            <Button
              onClick={() => {
                resetForm()
                setMostrarForm(true)
              }}
              icon={<Plus className="h-4 w-4" />}
              aria-label="Adicionar novo medicamento"
            >
              Novo Medicamento
            </Button>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <StatCard
              title="Total de Medicamentos"
              value={estatisticas.total}
              icon={<Pill className="h-5 w-5" />}
            />
            
            <StatCard
              title="Tomados Hoje"
              value={estatisticas.tomadosHoje}
              icon={<Check className="h-5 w-5" />}
              description={`${estatisticas.percentualTomados}% dos medicamentos`}
            />
            
            <StatCard
              title="Próxima Dose"
              value={proximaDose.texto}
              icon={<Clock className="h-5 w-5" />}
              description={proximaDose.descricao}
            />
          </div>
          
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
            Seus Medicamentos
          </h3>
          
          <MedicamentosList
            medicamentos={medicamentos}
            onEdit={iniciarEdicao}
            onDelete={removerMedicamento}
            onRegistrarTomada={handleRegistrarTomada}
          />
        </Card>
      </div>

      {/* Modal para adicionar/editar medicamento */}
      <Modal
        isOpen={mostrarForm}
        onClose={resetForm}
        title={editandoId ? "Editar Medicamento" : "Novo Medicamento"}
        footer={
          <div className="flex justify-end gap-2">
            <Button variant="outline" onClick={resetForm}>
              Cancelar
            </Button>
            <Button 
              onClick={editandoId ? salvarEdicao : handleAdicionarMedicamento}
            >
              {editandoId ? "Salvar Alterações" : "Adicionar Medicamento"}
            </Button>
          </div>
        }
      >
        {erro && (
          <Alert variant="error" className="mb-4">
            {erro}
          </Alert>
        )}
        
        <div className="space-y-4">
          <Input
            value={novoMedicamento.nome}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, nome: e.target.value })}
            label="Nome do Medicamento"
            placeholder="Ex: Ritalina, Fluoxetina"
            required
          />
          
          <Input
            value={novoMedicamento.dosagem}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, dosagem: e.target.value })}
            label="Dosagem"
            placeholder="Ex: 10mg, 1 comprimido"
          />
          
          <Select
            value={novoMedicamento.frequencia}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, frequencia: e.target.value })}
            label="Frequência"
            options={opcoesFrequencia}
          />
          
          <Select
            value={novoMedicamento.intervalo?.toString() || '240'}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, intervalo: parseInt(e.target.value) })}
            label="Intervalo entre doses"
            options={opcoesIntervalo}
            helpText="Tempo mínimo recomendado entre uma dose e outra"
          />
          
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Horários
            </label>
            <div className="flex gap-2 mb-2">
              <Input
                type="time"
                value={novoHorario}
                onChange={(e) => setNovoHorario(e.target.value)}
                className="flex-1"
              />
              <Button
                onClick={adicionarHorario}
                aria-label="Adicionar horário"
              >
                <Plus className="h-4 w-4" />
              </Button>
            </div>
            
            {novoMedicamento.horarios.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {novoMedicamento.horarios.map((horario) => (
                  <Badge key={horario} variant="primary" className="flex items-center gap-1">
                    <Clock className="h-3 w-3 mr-1" />
                    {horario}
                    <button
                      onClick={() => removerHorario(horario)}
                      className="ml-1 text-blue-700 hover:text-blue-900 dark:text-blue-300 dark:hover:text-blue-100"
                      aria-label={`Remover horário ${horario}`}
                    >
                      <X className="h-3 w-3" />
                    </button>
                  </Badge>
                ))}
              </div>
            )}
          </div>
          
          <Input
            type="date"
            value={novoMedicamento.dataInicio}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, dataInicio: e.target.value })}
            label="Data de Início"
          />
          
          <Textarea
            value={novoMedicamento.observacoes}
            onChange={(e) => setNovoMedicamento({ ...novoMedicamento, observacoes: e.target.value })}
            label="Observações (opcional)"
            placeholder="Adicione informações importantes sobre o medicamento..."
          />
        </div>
      </Modal>
    </div>
  )
}
</file>

<file path="app/components/saude/StatCard.tsx">
'use client'

import { ReactNode } from 'react'
import { cn } from '@/app/lib/utils'
import { Card } from '../ui/Card'

interface StatCardProps {
  title: string
  value: string | number
  icon?: ReactNode
  description?: string
  className?: string
  trend?: {
    value: number
    label: string
    positive?: boolean
  }
}

export function StatCard({
  title,
  value,
  icon,
  description,
  className,
  trend,
}: StatCardProps) {
  return (
    <Card className={cn('flex flex-col', className)}>
      <div className="flex items-center justify-between mb-2">
        <h3 className="text-sm font-medium text-gray-500 dark:text-gray-400">
          {title}
        </h3>
        {icon && <div className="text-saude-primary">{icon}</div>}
      </div>
      
      <div className="flex items-end">
        <div className="text-2xl font-semibold text-gray-900 dark:text-white">
          {value}
        </div>
        
        {trend && (
          <div className={cn(
            "ml-2 text-xs font-medium flex items-center",
            trend.positive 
              ? "text-green-600 dark:text-green-400" 
              : "text-red-600 dark:text-red-400"
          )}>
            <span className="mr-1">
              {trend.positive ? '↑' : '↓'}
            </span>
            {trend.value}% {trend.label}
          </div>
        )}
      </div>
      
      {description && (
        <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
          {description}
        </p>
      )}
    </Card>
  )
}
</file>

<file path="app/components/sono/ConfiguracaoLembretes.tsx">
'use client'

import { useState } from 'react'
import { useSonoStore } from '../../stores/sonoStore'
import { Bell, Trash2, Moon, Sun, Clock, Eye, EyeOff, Edit2 } from 'lucide-react'

// Dias da semana para seleção
const diasSemana = [
  { valor: 0, nome: 'Dom', abrev: 'D' },
  { valor: 1, nome: 'Seg', abrev: 'S' },
  { valor: 2, nome: 'Ter', abrev: 'T' },
  { valor: 3, nome: 'Qua', abrev: 'Q' },
  { valor: 4, nome: 'Qui', abrev: 'Q' },
  { valor: 5, nome: 'Sex', abrev: 'S' },
  { valor: 6, nome: 'Sáb', abrev: 'S' },
]

export function ConfiguracaoLembretes() {
  const { 
    lembretes, 
    adicionarLembrete, 
    atualizarLembrete, 
    removerLembrete, 
    alternarAtivoLembrete 
  } = useSonoStore()
  
  // Estado do formulário
  const [tipo, setTipo] = useState<'dormir' | 'acordar'>('dormir')
  const [horario, setHorario] = useState('22:00')
  const [diasSelecionados, setDiasSelecionados] = useState<number[]>([0, 1, 2, 3, 4, 5, 6])
  const [modoEdicao, setModoEdicao] = useState(false)
  const [idEdicao, setIdEdicao] = useState<string | null>(null)

  // Alternar seleção de dia
  const toggleDia = (dia: number) => {
    if (diasSelecionados.includes(dia)) {
      setDiasSelecionados(diasSelecionados.filter(d => d !== dia))
    } else {
      setDiasSelecionados([...diasSelecionados, dia])
    }
  }
  
  // Selecionar todos os dias
  const selecionarTodosDias = () => {
    setDiasSelecionados([0, 1, 2, 3, 4, 5, 6])
  }
  
  // Selecionar apenas dias de semana
  const selecionarDiasSemana = () => {
    setDiasSelecionados([1, 2, 3, 4, 5])
  }
  
  // Selecionar apenas fim de semana
  const selecionarFimDeSemana = () => {
    setDiasSelecionados([0, 6])
  }
  
  // Limpar seleção de dias
  const limparDias = () => {
    setDiasSelecionados([])
  }
  
  // Iniciar edição de um lembrete
  const iniciarEdicao = (lembrete: any) => {
    setTipo(lembrete.tipo)
    setHorario(lembrete.horario)
    setDiasSelecionados(lembrete.diasSemana)
    setModoEdicao(true)
    setIdEdicao(lembrete.id)
  }
  
  // Cancelar edição
  const cancelarEdicao = () => {
    resetForm()
    setModoEdicao(false)
    setIdEdicao(null)
  }
  
  // Resetar formulário
  const resetForm = () => {
    setTipo('dormir')
    setHorario('22:00')
    setDiasSelecionados([0, 1, 2, 3, 4, 5, 6])
  }
  
  // Lidar com envio do formulário
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    
    if (diasSelecionados.length === 0) {
      alert('Selecione pelo menos um dia da semana')
      return
    }
    
    if (modoEdicao && idEdicao) {
      atualizarLembrete(idEdicao, {
        tipo,
        horario,
        diasSemana: diasSelecionados
      })
      
      // Limpar modo de edição
      setModoEdicao(false)
      setIdEdicao(null)
    } else {
      adicionarLembrete(tipo, horario, diasSelecionados)
    }
    
    // Resetar formulário
    resetForm()
  }
  
  // Formatar exibição dos dias da semana
  const formatarDiasSemana = (dias: number[]) => {
    if (dias.length === 7) return 'Todos os dias'
    if (dias.length === 0) return 'Nenhum dia selecionado'
    if (arrayEquals(dias, [1, 2, 3, 4, 5])) return 'Segunda a Sexta'
    if (arrayEquals(dias, [0, 6])) return 'Fim de semana'
    
    return dias
      .sort((a, b) => a - b)
      .map(dia => diasSemana.find(d => d.valor === dia)?.nome)
      .join(', ')
  }
  
  // Verificar se dois arrays são iguais
  const arrayEquals = (a: any[], b: any[]) => {
    return a.length === b.length && 
      a.sort().every((val, index) => val === b.sort()[index])
  }
  
  // Agrupar lembretes por tipo
  const lembretesDormir = lembretes.filter(l => l.tipo === 'dormir')
  const lembretesAcordar = lembretes.filter(l => l.tipo === 'acordar')
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-6">
        Configuração de Lembretes
      </h2>
      
      <form onSubmit={handleSubmit} className="mb-8">
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
          {/* Tipo de lembrete */}
          <div>
            <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3">
              Tipo de Lembrete
            </h3>
            
            <div className="flex space-x-4">
              <label className="flex items-center">
                <input
                  type="radio"
                  name="tipo"
                  checked={tipo === 'dormir'}
                  onChange={() => setTipo('dormir')}
                  className="h-4 w-4 text-sono-primary focus:ring-sono-primary border-gray-300"
                />
                <span className="ml-2 flex items-center text-gray-700 dark:text-gray-300">
                  <Moon className="h-4 w-4 mr-1 rotate-180" />
                  Hora de dormir
                </span>
              </label>
              
              <label className="flex items-center">
                <input
                  type="radio"
                  name="tipo"
                  checked={tipo === 'acordar'}
                  onChange={() => setTipo('acordar')}
                  className="h-4 w-4 text-sono-primary focus:ring-sono-primary border-gray-300"
                />
                <span className="ml-2 flex items-center text-gray-700 dark:text-gray-300">
                  <Sun className="h-4 w-4 mr-1" />
                  Hora de acordar
                </span>
              </label>
            </div>
          </div>
          
          {/* Horário */}
          <div>
            <label htmlFor="horario" className="block font-medium text-gray-700 dark:text-gray-300 mb-3">
              Horário
            </label>
            <input
              type="time"
              id="horario"
              value={horario}
              onChange={(e) => setHorario(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
              required
            />
          </div>
        </div>
        
        {/* Dias da semana */}
        <div className="mt-6">
          <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3">
            Dias da Semana
          </h3>
          
          <div className="flex mb-3 space-x-2">
            <button
              type="button"
              onClick={selecionarTodosDias}
              className="px-2 py-1 text-xs text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600"
            >
              Todos
            </button>
            <button
              type="button"
              onClick={selecionarDiasSemana}
              className="px-2 py-1 text-xs text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600"
            >
              Seg-Sex
            </button>
            <button
              type="button"
              onClick={selecionarFimDeSemana}
              className="px-2 py-1 text-xs text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600"
            >
              Fim de semana
            </button>
            <button
              type="button"
              onClick={limparDias}
              className="px-2 py-1 text-xs text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600"
            >
              Limpar
            </button>
          </div>
          
          <div className="flex space-x-2 flex-wrap">
            {diasSemana.map((dia) => (
              <button
                key={dia.valor}
                type="button"
                onClick={() => toggleDia(dia.valor)}
                className={`
                  w-9 h-9 rounded-full flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-sono-primary
                  ${diasSelecionados.includes(dia.valor)
                    ? 'bg-sono-primary text-white'
                    : 'bg-gray-100 text-gray-600 dark:bg-gray-700 dark:text-gray-300'}
                `}
                aria-label={`${diasSelecionados.includes(dia.valor) ? 'Remover' : 'Adicionar'} ${dia.nome}`}
                aria-pressed={diasSelecionados.includes(dia.valor)}
              >
                {dia.abrev}
              </button>
            ))}
          </div>
          
          <p className="mt-2 text-sm text-gray-500 dark:text-gray-400">
            {formatarDiasSemana(diasSelecionados)}
          </p>
        </div>
        
        {/* Botões */}
        <div className="mt-6 flex space-x-3">
          <button
            type="submit"
            className="px-4 py-2 bg-sono-primary text-white rounded-md hover:bg-sono-secondary focus:outline-none focus:ring-2 focus:ring-sono-primary focus:ring-offset-2"
          >
            {modoEdicao ? 'Atualizar Lembrete' : 'Adicionar Lembrete'}
          </button>
          
          {modoEdicao && (
            <button
              type="button"
              onClick={cancelarEdicao}
              className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600"
            >
              Cancelar
            </button>
          )}
        </div>
      </form>
      
      {/* Lista de lembretes */}
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
        {/* Lembretes para dormir */}
        <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
          <h3 className="font-medium text-gray-800 dark:text-white mb-3 flex items-center">
            <Moon className="h-4 w-4 mr-2 rotate-180" />
            Lembretes para Dormir
          </h3>
          
          {lembretesDormir.length === 0 ? (
            <div className="text-gray-500 dark:text-gray-400 text-center py-2">
              Nenhum lembrete configurado
            </div>
          ) : (
            <div className="space-y-3">
              {lembretesDormir.map((lembrete) => (
                <div 
                  key={lembrete.id}
                  className="flex justify-between items-center p-3 bg-white dark:bg-gray-800 rounded-md shadow-sm"
                >
                  <div>
                    <div className="font-medium text-gray-800 dark:text-white">
                      {lembrete.horario}
                    </div>
                    <div className="text-xs text-gray-500 dark:text-gray-400">
                      {formatarDiasSemana(lembrete.diasSemana)}
                    </div>
                  </div>
                  
                  <div className="flex space-x-2">
                    <button
                      onClick={() => alternarAtivoLembrete(lembrete.id)}
                      className={`p-1 rounded-md ${lembrete.ativo ? 'text-sono-primary' : 'text-gray-400'}`}
                      aria-label={lembrete.ativo ? 'Desativar lembrete' : 'Ativar lembrete'}
                    >
                      {lembrete.ativo ? <Eye className="h-4 w-4" /> : <EyeOff className="h-4 w-4" />}
                    </button>
                    
                    <button
                      onClick={() => iniciarEdicao(lembrete)}
                      className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                      aria-label="Editar lembrete"
                    >
                      <Edit2 className="h-4 w-4" />
                    </button>
                    
                    <button
                      onClick={() => removerLembrete(lembrete.id)}
                      className="p-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                      aria-label="Remover lembrete"
                    >
                      <Trash2 className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
        
        {/* Lembretes para acordar */}
        <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
          <h3 className="font-medium text-gray-800 dark:text-white mb-3 flex items-center">
            <Sun className="h-4 w-4 mr-2" />
            Lembretes para Acordar
          </h3>
          
          {lembretesAcordar.length === 0 ? (
            <div className="text-gray-500 dark:text-gray-400 text-center py-2">
              Nenhum lembrete configurado
            </div>
          ) : (
            <div className="space-y-3">
              {lembretesAcordar.map((lembrete) => (
                <div 
                  key={lembrete.id}
                  className="flex justify-between items-center p-3 bg-white dark:bg-gray-800 rounded-md shadow-sm"
                >
                  <div>
                    <div className="font-medium text-gray-800 dark:text-white">
                      {lembrete.horario}
                    </div>
                    <div className="text-xs text-gray-500 dark:text-gray-400">
                      {formatarDiasSemana(lembrete.diasSemana)}
                    </div>
                  </div>
                  
                  <div className="flex space-x-2">
                    <button
                      onClick={() => alternarAtivoLembrete(lembrete.id)}
                      className={`p-1 rounded-md ${lembrete.ativo ? 'text-sono-primary' : 'text-gray-400'}`}
                      aria-label={lembrete.ativo ? 'Desativar lembrete' : 'Ativar lembrete'}
                    >
                      {lembrete.ativo ? <Eye className="h-4 w-4" /> : <EyeOff className="h-4 w-4" />}
                    </button>
                    
                    <button
                      onClick={() => iniciarEdicao(lembrete)}
                      className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                      aria-label="Editar lembrete"
                    >
                      <Edit2 className="h-4 w-4" />
                    </button>
                    
                    <button
                      onClick={() => removerLembrete(lembrete.id)}
                      className="p-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                      aria-label="Remover lembrete"
                    >
                      <Trash2 className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
      
      {/* Nota sobre os lembretes */}
      <div className="mt-6 p-4 bg-blue-50 text-blue-800 dark:bg-blue-900 dark:text-blue-100 rounded-md">
        <h3 className="font-medium mb-2 flex items-center">
          <Bell className="h-5 w-5 mr-2" />
          Sobre os lembretes
        </h3>
        <p className="text-sm">
          Os lembretes são apenas visuais e exibidos quando você estiver usando o aplicativo. 
          Para receber notificações em seu dispositivo, configure os alarmes no aplicativo de relógio do seu sistema.
        </p>
      </div>
    </div>
  )
}
</file>

<file path="app/components/sono/RegistroSono.tsx">
'use client'

import { useState } from 'react'
import { useSonoStore } from '../../stores/sonoStore'
import { formatDistanceToNow, format, isToday, isYesterday, parseISO } from 'date-fns'
import { ptBR } from 'date-fns/locale'
import { Clock, Moon, Trash2, Star, Edit2 } from 'lucide-react'

export function RegistroSono() {
  const { registros, adicionarRegistroSono, atualizarRegistroSono, removerRegistroSono } = useSonoStore()
  
  const [dataInicio, setDataInicio] = useState('')
  const [horaInicio, setHoraInicio] = useState('')
  const [dataFim, setDataFim] = useState('')
  const [horaFim, setHoraFim] = useState('')
  const [notas, setNotas] = useState('')
  const [qualidade, setQualidade] = useState<number | null>(null)
  const [modoEdicao, setModoEdicao] = useState(false)
  const [idEdicao, setIdEdicao] = useState<string | null>(null)
  
  // Formatar data para exibição
  const formatarData = (dataISO: string) => {
    const data = parseISO(dataISO)
    if (isToday(data)) {
      return `Hoje às ${format(data, 'HH:mm')}`
    } else if (isYesterday(data)) {
      return `Ontem às ${format(data, 'HH:mm')}`
    }
    return format(data, "dd 'de' MMMM 'às' HH:mm", { locale: ptBR })
  }
  
  // Calcular duração do sono
  const calcularDuracao = (inicio: string, fim: string | null) => {
    if (!fim) return null
    
    const dataInicio = parseISO(inicio)
    const dataFim = parseISO(fim)
    
    // Diferença em milissegundos
    const diff = dataFim.getTime() - dataInicio.getTime()
    
    // Converter para horas e minutos
    const horas = Math.floor(diff / (1000 * 60 * 60))
    const minutos = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60))
    
    return `${horas}h ${minutos}min`
  }
  
  // Formatação da qualidade do sono em estrelas
  const renderEstrelas = (qualidade: number | null) => {
    if (qualidade === null) return null
    
    return Array.from({ length: 5 }).map((_, i) => (
      <Star 
        key={i} 
        className={`h-4 w-4 ${i < qualidade ? 'text-yellow-400 fill-yellow-400' : 'text-gray-300'}`} 
      />
    ))
  }
  
  // Lidar com o envio do formulário
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!dataInicio || !horaInicio) return
    
    const inicioISO = new Date(`${dataInicio}T${horaInicio}:00`).toISOString()
    const fimISO = dataFim && horaFim 
      ? new Date(`${dataFim}T${horaFim}:00`).toISOString() 
      : null
    
    if (modoEdicao && idEdicao) {
      atualizarRegistroSono(idEdicao, {
        inicio: inicioISO,
        fim: fimISO,
        qualidade,
        notas
      })
      
      // Limpar modo de edição
      setModoEdicao(false)
      setIdEdicao(null)
    } else {
      adicionarRegistroSono(inicioISO, fimISO, qualidade, notas)
    }
    
    // Limpar o formulário
    resetForm()
  }
  
  // Resetar formulário
  const resetForm = () => {
    setDataInicio('')
    setHoraInicio('')
    setDataFim('')
    setHoraFim('')
    setNotas('')
    setQualidade(null)
  }
  
  // Iniciar edição de um registro
  const iniciarEdicao = (registro: any) => {
    const dataInicioObj = parseISO(registro.inicio)
    const dataInicio = format(dataInicioObj, 'yyyy-MM-dd')
    const horaInicio = format(dataInicioObj, 'HH:mm')
    
    let dataFim = ''
    let horaFim = ''
    
    if (registro.fim) {
      const dataFimObj = parseISO(registro.fim)
      dataFim = format(dataFimObj, 'yyyy-MM-dd')
      horaFim = format(dataFimObj, 'HH:mm')
    }
    
    setDataInicio(dataInicio)
    setHoraInicio(horaInicio)
    setDataFim(dataFim)
    setHoraFim(horaFim)
    setNotas(registro.notas || '')
    setQualidade(registro.qualidade)
    
    setModoEdicao(true)
    setIdEdicao(registro.id)
  }
  
  // Cancelar edição
  const cancelarEdicao = () => {
    resetForm()
    setModoEdicao(false)
    setIdEdicao(null)
  }
  
  // Registrar sono atual
  const registrarSonoAtual = () => {
    const agora = new Date()
    setDataInicio(format(agora, 'yyyy-MM-dd'))
    setHoraInicio(format(agora, 'HH:mm'))
  }
  
  // Registrar acordar agora
  const registrarAcordarAgora = (id: string) => {
    const agora = new Date().toISOString()
    atualizarRegistroSono(id, { fim: agora })
  }
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-6">
        Registro de Sono
      </h2>
      
      <form onSubmit={handleSubmit} className="mb-8">
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-6 mb-6">
          {/* Início do sono */}
          <div>
            <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3 flex items-center">
              <Moon className="h-4 w-4 mr-2 rotate-180" />
              Horário de dormir
            </h3>
            
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label htmlFor="data-inicio" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                  Data
                </label>
                <input
                  type="date"
                  id="data-inicio"
                  value={dataInicio}
                  onChange={(e) => setDataInicio(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  required
                />
              </div>
              
              <div>
                <label htmlFor="hora-inicio" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                  Hora
                </label>
                <input
                  type="time"
                  id="hora-inicio"
                  value={horaInicio}
                  onChange={(e) => setHoraInicio(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                  required
                />
              </div>
            </div>
            
            <button
              type="button"
              onClick={registrarSonoAtual}
              className="mt-2 text-sm text-sono-primary hover:text-sono-secondary dark:text-sono-secondary dark:hover:text-sono-primary"
            >
              Registrar agora
            </button>
          </div>
          
          {/* Fim do sono */}
          <div>
            <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3 flex items-center">
              <Clock className="h-4 w-4 mr-2" />
              Horário de acordar
            </h3>
            
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label htmlFor="data-fim" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                  Data
                </label>
                <input
                  type="date"
                  id="data-fim"
                  value={dataFim}
                  onChange={(e) => setDataFim(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
              
              <div>
                <label htmlFor="hora-fim" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">
                  Hora
                </label>
                <input
                  type="time"
                  id="hora-fim"
                  value={horaFim}
                  onChange={(e) => setHoraFim(e.target.value)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                />
              </div>
            </div>
            
            <div className="text-sm text-gray-500 dark:text-gray-400 mt-2">
              Deixe em branco se ainda não acordou
            </div>
          </div>
        </div>
        
        {/* Qualidade do sono */}
        <div className="mb-6">
          <label className="block font-medium text-gray-700 dark:text-gray-300 mb-2">
            Qualidade do sono
          </label>
          
          <div className="flex space-x-2">
            {[1, 2, 3, 4, 5].map((valor) => (
              <button
                key={valor}
                type="button"
                onClick={() => setQualidade(valor)}
                className="p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-sono-primary"
                aria-label={`Qualidade ${valor} de 5`}
              >
                <Star 
                  className={`h-6 w-6 ${qualidade !== null && valor <= qualidade ? 'text-yellow-400 fill-yellow-400' : 'text-gray-300'}`} 
                />
              </button>
            ))}
          </div>
          
          <div className="text-sm text-gray-500 dark:text-gray-400 mt-1">
            {qualidade === null ? 'Selecione a qualidade do sono' : `Qualidade: ${qualidade}/5`}
          </div>
        </div>
        
        {/* Notas */}
        <div className="mb-6">
          <label htmlFor="notas" className="block font-medium text-gray-700 dark:text-gray-300 mb-2">
            Notas (opcional)
          </label>
          <textarea
            id="notas"
            value={notas}
            onChange={(e) => setNotas(e.target.value)}
            rows={3}
            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-sono-primary focus:border-sono-primary dark:bg-gray-700 dark:border-gray-600 dark:text-white"
            placeholder="Exemplo: Acordei várias vezes, tive sonhos vívidos, etc."
          />
        </div>
        
        {/* Botões */}
        <div className="flex space-x-3">
          <button
            type="submit"
            className="px-4 py-2 bg-sono-primary text-white rounded-md hover:bg-sono-secondary focus:outline-none focus:ring-2 focus:ring-sono-primary focus:ring-offset-2"
          >
            {modoEdicao ? 'Atualizar Registro' : 'Registrar Sono'}
          </button>
          
          {modoEdicao && (
            <button
              type="button"
              onClick={cancelarEdicao}
              className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600"
            >
              Cancelar
            </button>
          )}
        </div>
      </form>
      
      {/* Lista de registros recentes */}
      <div>
        <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3">
          Registros Recentes
        </h3>
        
        <div className="space-y-4">
          {registros.length === 0 ? (
            <div className="text-gray-500 dark:text-gray-400 text-center py-4">
              Nenhum registro de sono encontrado
            </div>
          ) : (
            registros
              .sort((a, b) => new Date(b.inicio).getTime() - new Date(a.inicio).getTime())
              .slice(0, 5)
              .map((registro) => (
                <div 
                  key={registro.id}
                  className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg border border-gray-200 dark:border-gray-600"
                >
                  <div className="flex justify-between items-start">
                    <div>
                      <div className="font-medium text-gray-800 dark:text-white">
                        {formatarData(registro.inicio)}
                      </div>
                      
                      {registro.fim ? (
                        <div className="text-gray-600 dark:text-gray-300 text-sm">
                          Até {formatarData(registro.fim)}
                        </div>
                      ) : (
                        <div className="text-sono-primary dark:text-sono-secondary text-sm font-medium">
                          Ainda dormindo
                        </div>
                      )}
                      
                      {registro.fim && (
                        <div className="flex items-center mt-1">
                          <Clock className="h-4 w-4 text-gray-500 dark:text-gray-400 mr-1" />
                          <span className="text-sm text-gray-700 dark:text-gray-300">
                            {calcularDuracao(registro.inicio, registro.fim)}
                          </span>
                        </div>
                      )}
                      
                      {registro.qualidade !== null && (
                        <div className="flex mt-1">
                          {renderEstrelas(registro.qualidade)}
                        </div>
                      )}
                      
                      {registro.notas && (
                        <div className="mt-2 text-sm text-gray-600 dark:text-gray-400">
                          "{registro.notas}"
                        </div>
                      )}
                    </div>
                    
                    <div className="flex space-x-2">
                      <button
                        onClick={() => iniciarEdicao(registro)}
                        className="p-1 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"
                        aria-label="Editar registro"
                      >
                        <Edit2 className="h-4 w-4" />
                      </button>
                      
                      <button
                        onClick={() => removerRegistroSono(registro.id)}
                        className="p-1 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                        aria-label="Remover registro"
                      >
                        <Trash2 className="h-4 w-4" />
                      </button>
                    </div>
                  </div>
                  
                  {!registro.fim && (
                    <button
                      onClick={() => registrarAcordarAgora(registro.id)}
                      className="mt-2 px-3 py-1 text-sm bg-sono-light text-sono-primary rounded-md hover:bg-opacity-70"
                    >
                      Registrar acordar agora
                    </button>
                  )}
                </div>
              ))
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/sono/VisualizadorSemanal.tsx">
'use client'

import { useState, useMemo } from 'react'
import { useSonoStore } from '../../stores/sonoStore'
import { 
  startOfWeek, endOfWeek, eachDayOfInterval, 
  format, parseISO, isSameDay, isWithinInterval,
  differenceInMinutes, addDays, subWeeks
} from 'date-fns'
import { ptBR } from 'date-fns/locale'
import { ArrowLeft, ArrowRight, Moon, Sun, Clock } from 'lucide-react'

export function VisualizadorSemanal() {
  const { registros } = useSonoStore()
  const [semanaAtual, setSemanaAtual] = useState(new Date())
  
  // Navegar entre semanas
  const irParaSemanaAnterior = () => {
    setSemanaAtual(prevData => subWeeks(prevData, 1))
  }
  
  const irParaProximaSemana = () => {
    setSemanaAtual(prevData => addDays(prevData, 7))
  }
  
  // Calcular o intervalo da semana atual
  const intervaloSemana = useMemo(() => {
    const inicioDaSemana = startOfWeek(semanaAtual, { weekStartsOn: 0 }) // Domingo como início da semana
    const fimDaSemana = endOfWeek(semanaAtual, { weekStartsOn: 0 })
    return {
      inicio: inicioDaSemana,
      fim: fimDaSemana,
      diasDaSemana: eachDayOfInterval({ start: inicioDaSemana, end: fimDaSemana })
    }
  }, [semanaAtual])
  
  // Formatar os dias da semana para exibição
  const diasFormatados = useMemo(() => {
    return intervaloSemana.diasDaSemana.map(dia => {
      const diaSemanaAbreviado = format(dia, 'EEE', { locale: ptBR })
      const diaMes = format(dia, 'dd/MM')
      return {
        data: dia,
        diaSemana: diaSemanaAbreviado.charAt(0).toUpperCase() + diaSemanaAbreviado.slice(1),
        diaMes
      }
    })
  }, [intervaloSemana])
  
  // Filtrar e processar os registros da semana
  const dadosSemanal = useMemo(() => {
    return diasFormatados.map(dia => {
      // Encontrar registros que começam ou terminam neste dia
      const registrosDoDia = registros.filter(registro => {
        const dataInicio = parseISO(registro.inicio)
        const dataFim = registro.fim ? parseISO(registro.fim) : new Date()
        
        // Verificar se o início ou fim do sono está neste dia
        // Ou se o sono abrange completamente este dia
        return (
          isSameDay(dataInicio, dia.data) || 
          isSameDay(dataFim, dia.data) ||
          isWithinInterval(dia.data, { start: dataInicio, end: dataFim })
        )
      })
      
      // Calcular tempo total de sono para este dia (em minutos)
      let minutosTotais = 0
      
      registrosDoDia.forEach(registro => {
        const dataInicio = parseISO(registro.inicio)
        const dataFim = registro.fim ? parseISO(registro.fim) : new Date()
        
        // Início e fim do dia
        const inicioDia = new Date(dia.data)
        inicioDia.setHours(0, 0, 0, 0)
        
        const fimDia = new Date(dia.data)
        fimDia.setHours(23, 59, 59, 999)
        
        // Determinar o intervalo de sono dentro deste dia específico
        const inicioIntervalo = dataInicio < inicioDia ? inicioDia : dataInicio
        const fimIntervalo = dataFim > fimDia ? fimDia : dataFim
        
        // Calcular minutos de sono neste dia
        if (fimIntervalo > inicioIntervalo) {
          minutosTotais += differenceInMinutes(fimIntervalo, inicioIntervalo)
        }
      })
      
      // Converter para horas (arredondar para 1 casa decimal)
      const horasDeSono = Math.round(minutosTotais / 6) / 10
      
      // Qualidade média do sono
      const registrosComQualidade = registrosDoDia.filter(r => r.qualidade !== null)
      const qualidadeMedia = registrosComQualidade.length > 0
        ? registrosComQualidade.reduce((sum, r) => sum + (r.qualidade || 0), 0) / registrosComQualidade.length
        : null
      
      return {
        ...dia,
        horasDeSono,
        qualidadeMedia,
        registros: registrosDoDia
      }
    })
  }, [diasFormatados, registros])
  
  // Calcular estatísticas da semana
  const estatisticasSemana = useMemo(() => {
    const diasComSono = dadosSemanal.filter(d => d.horasDeSono > 0)
    
    if (diasComSono.length === 0) {
      return {
        mediaHoras: 0,
        mediaQualidade: 0,
        melhorDia: null,
        piorDia: null
      }
    }
    
    const totalHoras = diasComSono.reduce((sum, dia) => sum + dia.horasDeSono, 0)
    const mediaHoras = Math.round((totalHoras / diasComSono.length) * 10) / 10
    
    const diasComQualidade = diasComSono.filter(d => d.qualidadeMedia !== null)
    const mediaQualidade = diasComQualidade.length > 0
      ? Math.round((diasComQualidade.reduce((sum, dia) => sum + (dia.qualidadeMedia || 0), 0) / diasComQualidade.length) * 10) / 10
      : 0
    
    // Melhor e pior dia baseado em horas de sono (mais próximo de 8h é melhor)
    const melhorDia = [...diasComSono].sort((a, b) => {
      const distA = Math.abs(a.horasDeSono - 8)
      const distB = Math.abs(b.horasDeSono - 8)
      return distA - distB
    })[0]
    
    const piorDia = [...diasComSono].sort((a, b) => {
      const distA = Math.abs(a.horasDeSono - 8)
      const distB = Math.abs(b.horasDeSono - 8)
      return distB - distA
    })[0]
    
    return {
      mediaHoras,
      mediaQualidade,
      melhorDia,
      piorDia
    }
  }, [dadosSemanal])
  
  // Calcular altura máxima da barra (12 horas)
  const calcularAlturaBarra = (horas: number) => {
    const maxHoras = 12
    const alturaPorcentagem = Math.min((horas / maxHoras) * 100, 100)
    return `${alturaPorcentagem}%`
  }
  
  // Calcular cor da barra com base nas horas (verde = ideal, amarelo = médio, vermelho = pouco)
  const calcularCorBarra = (horas: number) => {
    if (horas >= 7 && horas <= 9) return 'bg-green-500'
    if (horas >= 5 && horas < 7) return 'bg-yellow-500'
    if (horas > 9 && horas <= 11) return 'bg-yellow-500'
    return 'bg-red-500'
  }
  
  return (
    <div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-white mb-6">
        Visualizador Semanal de Sono
      </h2>
      
      {/* Navegação de semanas */}
      <div className="flex items-center justify-between mb-6">
        <button
          onClick={irParaSemanaAnterior}
          className="p-2 rounded-full text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-sono-primary"
          aria-label="Semana anterior"
        >
          <ArrowLeft className="h-5 w-5" />
        </button>
        
        <div className="text-center">
          <h3 className="font-medium text-gray-800 dark:text-white">
            {format(intervaloSemana.inicio, "dd 'de' MMMM", { locale: ptBR })} - {format(intervaloSemana.fim, "dd 'de' MMMM", { locale: ptBR })}
          </h3>
          <p className="text-sm text-gray-500 dark:text-gray-400">
            {format(intervaloSemana.inicio, "yyyy")}
          </p>
        </div>
        
        <button
          onClick={irParaProximaSemana}
          className="p-2 rounded-full text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 focus:outline-none focus:ring-2 focus:ring-sono-primary"
          aria-label="Próxima semana"
          disabled={isWithinInterval(new Date(), { start: intervaloSemana.inicio, end: intervaloSemana.fim })}
        >
          <ArrowRight className="h-5 w-5" />
        </button>
      </div>
      
      {/* Visualização de gráfico */}
      <div className="mb-8">
        <div className="flex items-end justify-between h-64 bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
          {dadosSemanal.map((dia, index) => (
            <div key={index} className="flex flex-col items-center w-1/7">
              <div className="relative h-48 w-full flex items-end justify-center mb-2">
                {dia.horasDeSono > 0 ? (
                  <div 
                    className={`w-8 rounded-t-lg ${calcularCorBarra(dia.horasDeSono)}`} 
                    style={{ height: calcularAlturaBarra(dia.horasDeSono) }}
                    title={`${dia.horasDeSono} horas de sono`}
                  />
                ) : (
                  <div className="text-gray-400 dark:text-gray-500">
                    —
                  </div>
                )}
              </div>
              <div className="text-center">
                <div className="font-medium text-sono-primary dark:text-sono-secondary text-sm">
                  {dia.diaSemana}
                </div>
                <div className="text-xs text-gray-500 dark:text-gray-400">
                  {dia.diaMes}
                </div>
              </div>
            </div>
          ))}
        </div>
        
        <div className="flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-2">
          <div className="flex items-center">
            <div className="w-3 h-3 rounded-full bg-green-500 mr-1"></div>
            <span>7-9h (ideal)</span>
          </div>
          <div className="flex items-center">
            <div className="w-3 h-3 rounded-full bg-yellow-500 mr-1"></div>
            <span>5-7h / 9-11h</span>
          </div>
          <div className="flex items-center">
            <div className="w-3 h-3 rounded-full bg-red-500 mr-1"></div>
            <span>&lt;5h / &gt;11h</span>
          </div>
        </div>
      </div>
      
      {/* Estatísticas da semana */}
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
        <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
          <h3 className="font-medium text-gray-800 dark:text-white mb-2 flex items-center">
            <Clock className="h-4 w-4 mr-2" />
            Média da Semana
          </h3>
          
          <div className="flex justify-between">
            <div>
              <div className="text-sm text-gray-600 dark:text-gray-300">Horas de sono</div>
              <div className="text-2xl font-bold text-sono-primary">{estatisticasSemana.mediaHoras}h</div>
            </div>
            
            <div>
              <div className="text-sm text-gray-600 dark:text-gray-300">Qualidade média</div>
              <div className="text-2xl font-bold text-sono-primary">
                {estatisticasSemana.mediaQualidade ? estatisticasSemana.mediaQualidade.toFixed(1) : '—'}/5
              </div>
            </div>
          </div>
        </div>
        
        <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
          <h3 className="font-medium text-gray-800 dark:text-white mb-2 flex items-center">
            <Sun className="h-4 w-4 mr-2" />
            Melhor e Pior Dia
          </h3>
          
          {estatisticasSemana.melhorDia ? (
            <div className="flex justify-between">
              <div>
                <div className="text-sm text-gray-600 dark:text-gray-300">Melhor dia</div>
                <div className="font-medium text-green-600 dark:text-green-400">
                  {estatisticasSemana.melhorDia.diaSemana} • {estatisticasSemana.melhorDia.horasDeSono}h
                </div>
              </div>
              
              {estatisticasSemana.piorDia && (
                <div>
                  <div className="text-sm text-gray-600 dark:text-gray-300">Pior dia</div>
                  <div className="font-medium text-red-600 dark:text-red-400">
                    {estatisticasSemana.piorDia.diaSemana} • {estatisticasSemana.piorDia.horasDeSono}h
                  </div>
                </div>
              )}
            </div>
          ) : (
            <div className="text-gray-500 dark:text-gray-400">
              Sem dados suficientes para esta semana
            </div>
          )}
        </div>
      </div>
      
      {/* Lista de registros da semana */}
      <div>
        <h3 className="font-medium text-gray-700 dark:text-gray-300 mb-3">
          Detalhes da Semana
        </h3>
        
        {dadosSemanal.some(d => d.registros.length > 0) ? (
          <div className="space-y-2">
            {dadosSemanal.map((dia, index) => (
              dia.registros.length > 0 && (
                <div key={index} className="border-l-2 border-sono-primary pl-3 py-1">
                  <div className="font-medium text-gray-800 dark:text-white">
                    {dia.diaSemana}, {dia.diaMes}
                  </div>
                  <div className="flex items-center text-sm text-gray-600 dark:text-gray-300">
                    <Clock className="h-4 w-4 mr-1" />
                    <span>{dia.horasDeSono} horas de sono</span>
                  </div>
                </div>
              )
            ))}
          </div>
        ) : (
          <div className="text-center py-6 text-gray-500 dark:text-gray-400">
            Nenhum registro encontrado para esta semana
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/components/ui/Alert.tsx">
'use client'

import { ReactNode } from 'react'
import { cn } from '@/app/lib/utils'
import { AlertCircle, CheckCircle, Info, XCircle } from 'lucide-react'

type AlertVariant = 'info' | 'success' | 'warning' | 'error'

interface AlertProps {
  variant?: AlertVariant
  title?: string
  children: ReactNode
  className?: string
}

const variantStyles = {
  info: {
    container: 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800',
    icon: <Info className="h-5 w-5 text-blue-500 dark:text-blue-400" />,
    title: 'text-blue-800 dark:text-blue-300',
    content: 'text-blue-700 dark:text-blue-200',
  },
  success: {
    container: 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800',
    icon: <CheckCircle className="h-5 w-5 text-green-500 dark:text-green-400" />,
    title: 'text-green-800 dark:text-green-300',
    content: 'text-green-700 dark:text-green-200',
  },
  warning: {
    container: 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800',
    icon: <AlertCircle className="h-5 w-5 text-yellow-500 dark:text-yellow-400" />,
    title: 'text-yellow-800 dark:text-yellow-300',
    content: 'text-yellow-700 dark:text-yellow-200',
  },
  error: {
    container: 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800',
    icon: <XCircle className="h-5 w-5 text-red-500 dark:text-red-400" />,
    title: 'text-red-800 dark:text-red-300',
    content: 'text-red-700 dark:text-red-200',
  },
}

export function Alert({ 
  variant = 'info', 
  title, 
  children, 
  className 
}: AlertProps) {
  const styles = variantStyles[variant]
  
  return (
    <div
      className={cn(
        'border rounded-md p-4 flex gap-3',
        styles.container,
        className
      )}
      role="alert"
    >
      <div className="flex-shrink-0">{styles.icon}</div>
      <div>
        {title && (
          <h3 className={cn('text-sm font-medium mb-1', styles.title)}>
            {title}
          </h3>
        )}
        <div className={cn('text-sm', styles.content)}>{children}</div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/ui/Badge.tsx">
'use client'

import { ReactNode } from 'react'
import { cva, type VariantProps } from 'class-variance-authority'
import { cn } from '@/app/lib/utils'

const badgeVariants = cva(
  'inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium',
  {
    variants: {
      variant: {
        default: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300',
        primary: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-300',
        secondary: 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-300',
        success: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300',
        warning: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300',
        danger: 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300',
        outline: 'bg-transparent border border-gray-300 text-gray-700 dark:border-gray-600 dark:text-gray-300',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
)

export interface BadgeProps extends VariantProps<typeof badgeVariants> {
  children: ReactNode
  className?: string
}

export function Badge({ className, variant, children }: BadgeProps) {
  return (
    <span className={cn(badgeVariants({ variant, className }))}>
      {children}
    </span>
  )
}
</file>

<file path="app/components/ui/Button.tsx">
'use client'

import { ButtonHTMLAttributes, ReactNode, forwardRef, ElementRef, ComponentPropsWithoutRef } from 'react'
import { cva, type VariantProps } from 'class-variance-authority'
import { cn } from '@/app/lib/utils'

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none',
  {
    variants: {
      variant: {
        default: 'bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-600',
        destructive: 'bg-red-600 text-white hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-600',
        outline: 'border border-gray-300 dark:border-gray-700 bg-transparent hover:bg-gray-100 dark:hover:bg-gray-800',
        subtle: 'bg-gray-100 text-gray-900 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-100 dark:hover:bg-gray-700',
        ghost: 'bg-transparent hover:bg-gray-100 dark:hover:bg-gray-800 text-gray-700 dark:text-gray-300',
        link: 'bg-transparent underline-offset-4 hover:underline text-blue-600 dark:text-blue-400 hover:bg-transparent',
        primary: 'bg-blue-600 text-white hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-600',
        success: 'bg-green-600 text-white hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-600',
        warning: 'bg-yellow-600 text-white hover:bg-yellow-700 dark:bg-yellow-700 dark:hover:bg-yellow-600',
        danger: 'bg-red-600 text-white hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-600',
        secondary: 'bg-gray-600 text-white hover:bg-gray-700 dark:bg-gray-700 dark:hover:bg-gray-600',
      },
      size: {
        default: 'h-10 py-2 px-4',
        sm: 'h-8 px-3 text-xs',
        lg: 'h-12 px-6 text-base',
        icon: 'h-9 w-9 p-1',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

export interface ButtonProps
  extends ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  icon?: ReactNode
  asChild?: boolean
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, children, icon, asChild, ...props }, ref) => {
    if (asChild) {
      // Se asChild for true, aplicamos as classes ao primeiro filho
      // mas não renderizamos um <button> diretamente
      return (
        <div className={cn(buttonVariants({ variant, size, className }))}>
          {icon && <span className="mr-2">{icon}</span>}
          {children}
        </div>
      );
    }
    
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      >
        {icon && <span className="mr-2">{icon}</span>}
        {children}
      </button>
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="app/components/ui/Card.tsx">
'use client'

import { cn } from '@/app/lib/utils'

interface CardProps {
  children: React.ReactNode
  title?: string
  className?: string
}

export function Card({ children, title, className }: CardProps) {
  return (
    <div className={cn(
      "bg-white dark:bg-gray-800 rounded-xl shadow-md overflow-hidden",
      className
    )}>
      {title && (
        <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-lg font-medium text-gray-900 dark:text-white">{title}</h2>
        </div>
      )}
      <div className="p-4">{children}</div>
    </div>
  )
}
</file>

<file path="app/components/ui/Checkbox.tsx">
'use client'

import { InputHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/app/lib/utils'

export interface CheckboxProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'type'> {
  label?: string
}

export const Checkbox = forwardRef<HTMLInputElement, CheckboxProps>(
  ({ className, label, id, ...props }, ref) => {
    const checkboxId = id || `checkbox-${Math.random().toString(36).substring(2, 9)}`
    
    return (
      <div className="flex items-center">
        <input
          id={checkboxId}
          type="checkbox"
          className={cn(
            "h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500 dark:border-gray-700 dark:bg-gray-800",
            className
          )}
          ref={ref}
          {...props}
        />
        {label && (
          <label
            htmlFor={checkboxId}
            className="ml-2 block text-sm text-gray-700 dark:text-gray-300"
          >
            {label}
          </label>
        )}
      </div>
    )
  }
)
</file>

<file path="app/components/ui/Container.tsx">
'use client'

import { cn } from '@/app/lib/utils'

interface ContainerProps {
  children: React.ReactNode
  className?: string
}

export function Container({ children, className }: ContainerProps) {
  return (
    <div className={cn(
      "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
      className
    )}>
      {children}
    </div>
  )
}
</file>

<file path="app/components/ui/DashboardCard.tsx">
'use client'

import { DashboardCardProps } from '@/app/types'
import { cn } from '@/app/lib/utils'

export function DashboardCard({ children, title, className, isLoading = false }: DashboardCardProps) {
  return (
    <div 
      className={cn(
        "bg-white dark:bg-gray-800 rounded-xl shadow-md overflow-hidden",
        isLoading && "animate-pulse",
        className
      )}
    >
      {title && (
        <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700">
          {isLoading ? (
            <div className="h-6 bg-gray-200 dark:bg-gray-700 rounded w-1/3"></div>
          ) : (
            <h2 className="text-lg font-medium text-gray-900 dark:text-white">{title}</h2>
          )}
        </div>
      )}
      <div className="p-4">
        {isLoading ? (
          <div className="space-y-4">
            <div className="h-24 bg-gray-200 dark:bg-gray-700 rounded"></div>
            <div className="h-32 bg-gray-200 dark:bg-gray-700 rounded"></div>
          </div>
        ) : (
          children
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/components/ui/DashboardHeader.tsx">
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { ChevronRight, Home } from 'lucide-react'
import { cn } from '@/app/lib/utils'

type BreadcrumbItem = {
  label: string
  href: string
  active?: boolean
}

type DashboardHeaderProps = {
  title: string
  description?: string
  userName?: string
  breadcrumbs?: BreadcrumbItem[]
  actions?: React.ReactNode
  showGreeting?: boolean
  className?: string
}

export function DashboardHeader({
  title,
  description,
  userName = 'Usuário',
  breadcrumbs,
  actions,
  showGreeting = true,
  className
}: DashboardHeaderProps) {
  const pathname = usePathname()
  
  // Obter a hora do dia para personalizar a saudação
  const getGreeting = () => {
    const hour = new Date().getHours()
    if (hour < 12) return 'Bom dia'
    if (hour < 18) return 'Boa tarde'
    return 'Boa noite'
  }

  return (
    <header className={cn("mb-6", className)}>
      {/* Trilha de navegação (breadcrumbs) */}
      {breadcrumbs && breadcrumbs.length > 0 && (
        <nav className="flex mb-2" aria-label="Trilha de navegação">
          <ol className="inline-flex items-center space-x-1 text-sm text-gray-500 dark:text-gray-400">
            <li>
              <Link 
                href="/" 
                className="inline-flex items-center hover:text-gray-700 dark:hover:text-gray-300"
              >
                <Home className="h-4 w-4 mr-1" />
                <span>Início</span>
              </Link>
            </li>
            
            {breadcrumbs.map((item, index) => (
              <li key={item.href} className="inline-flex items-center">
                <ChevronRight className="h-4 w-4 mx-1" aria-hidden="true" />
                {index === breadcrumbs.length - 1 || item.active ? (
                  <span className="text-gray-800 dark:text-gray-200 font-medium" aria-current="page">
                    {item.label}
                  </span>
                ) : (
                  <Link
                    href={item.href}
                    className="hover:text-gray-700 dark:hover:text-gray-300"
                  >
                    {item.label}
                  </Link>
                )}
              </li>
            ))}
          </ol>
        </nav>
      )}

      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between">
        <div>
          {/* Título e descrição */}
          <div className="flex items-center">
            <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
              {title}
            </h1>
          </div>
          
          {/* Saudação personalizada */}
          {showGreeting && (
            <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
              {getGreeting()}, <span className="font-medium">{userName}</span>. {description}
            </p>
          )}
        </div>
        
        {/* Área para botões ou ações */}
        {actions && (
          <div className="mt-4 sm:mt-0">
            {actions}
          </div>
        )}
      </div>
    </header>
  )
}
</file>

<file path="app/components/ui/DashboardSection.tsx">
'use client'

import { DashboardSectionProps } from '@/app/types'
import { cn } from '@/app/lib/utils'

export function DashboardSection({ id, title, children, className }: DashboardSectionProps) {
  const titleId = id || title?.toLowerCase().replace(/\s+/g, '-') || undefined
  
  return (
    <section 
      aria-labelledby={titleId}
      className={cn("mt-6", className)}
    >
      {title && (
        <h2 
          id={titleId} 
          className="text-xl font-semibold text-gray-900 dark:text-white mb-4"
        >
          {title}
        </h2>
      )}
      {children}
    </section>
  )
}
</file>

<file path="app/components/ui/DashboardSummary.tsx">
'use client'

import { CheckCircle, Clock, CalendarClock } from 'lucide-react'
import { cn } from '@/app/lib/utils'

type StatItemProps = {
  title: string
  value: string | number
  icon: React.ReactNode
  description?: string
  className?: string
}

const StatItem = ({ title, value, icon, description, className }: StatItemProps) => (
  <div className={cn(
    "bg-white dark:bg-gray-800 rounded-lg p-4 shadow-sm",
    className
  )}>
    <div className="flex justify-between items-start">
      <div>
        <p className="text-sm font-medium text-gray-500 dark:text-gray-400">{title}</p>
        <p className="text-2xl font-bold mt-1 text-gray-900 dark:text-white">{value}</p>
        {description && (
          <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">{description}</p>
        )}
      </div>
      <div className="p-2 rounded-md bg-blue-50 dark:bg-blue-900/20 text-blue-500 dark:text-blue-400">
        {icon}
      </div>
    </div>
  </div>
)

type DashboardSummaryProps = {
  prioridadesPendentes: number
  prioridadesConcluidas: number
  proximosCompromissos: number
  className?: string
}

export function DashboardSummary({
  prioridadesPendentes = 0,
  prioridadesConcluidas = 0,
  proximosCompromissos = 0,
  className
}: DashboardSummaryProps) {
  // Garantir que os valores são números válidos
  const pendentes = typeof prioridadesPendentes === 'number' ? prioridadesPendentes : 0
  const concluidas = typeof prioridadesConcluidas === 'number' ? prioridadesConcluidas : 0 
  const compromissos = typeof proximosCompromissos === 'number' ? proximosCompromissos : 0

  const totalPrioridades = pendentes + concluidas
  const porcentagemConcluidas = totalPrioridades > 0 
    ? Math.round((concluidas / totalPrioridades) * 100) 
    : 0
    
  return (
    <div className={cn("grid grid-cols-1 md:grid-cols-3 gap-4", className)}>
      <StatItem
        title="Prioridades Concluídas"
        value={`${concluidas}/${totalPrioridades}`}
        description={`${porcentagemConcluidas}% das tarefas concluídas`}
        icon={<CheckCircle className="h-5 w-5" />}
        className="border-l-4 border-green-500 dark:border-green-600"
      />
      
      <StatItem
        title="Próximos Compromissos"
        value={compromissos}
        description="Atividades programadas para hoje"
        icon={<CalendarClock className="h-5 w-5" />}
        className="border-l-4 border-blue-500 dark:border-blue-600"
      />
      
      <StatItem
        title="Tempo Restante"
        value={new Date().getHours() >= 18 ? "Finalizando o dia" : "Dia em andamento"}
        description="Aproveite seu tempo com sabedoria"
        icon={<Clock className="h-5 w-5" />}
        className="border-l-4 border-purple-500 dark:border-purple-600"
      />
    </div>
  )
}
</file>

<file path="app/components/ui/Input.tsx">
'use client'

import { InputHTMLAttributes, forwardRef, useId } from 'react'
import { cn } from '@/app/lib/utils'

export interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  label?: string
  error?: string
}

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ className, label, error, id, ...props }, ref) => {
    const generatedId = useId()
    const inputId = id || `input-${generatedId}`
    
    return (
      <div className="w-full">
        {label && (
          <label
            htmlFor={inputId}
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            {label}
          </label>
        )}
        <input
          id={inputId}
          className={cn(
            "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white text-sm",
            error && "border-red-500 focus:ring-red-500 focus:border-red-500",
            className
          )}
          ref={ref}
          aria-invalid={error ? 'true' : 'false'}
          aria-describedby={error ? `${inputId}-error` : undefined}
          {...props}
        />
        {error && (
          <p
            id={`${inputId}-error`}
            className="mt-1 text-xs text-red-600 dark:text-red-400"
          >
            {error}
          </p>
        )}
      </div>
    )
  }
)

Input.displayName = 'Input'
</file>

<file path="app/components/ui/Modal.tsx">
'use client'

import { Fragment, ReactNode } from 'react'
import { Dialog, Transition } from '@headlessui/react'
import { X } from 'lucide-react'
import { cn } from '@/app/lib/utils'
import { Button } from './Button'

interface ModalProps {
  isOpen: boolean
  onClose: () => void
  title: string
  children: ReactNode
  footer?: ReactNode
  size?: 'sm' | 'md' | 'lg' | 'xl'
  className?: string
}

export function Modal({
  isOpen,
  onClose,
  title,
  children,
  footer,
  size = 'md',
  className,
}: ModalProps) {
  const sizeClasses = {
    sm: 'max-w-sm',
    md: 'max-w-md',
    lg: 'max-w-lg',
    xl: 'max-w-xl',
  }
  
  return (
    <Transition appear show={isOpen} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25 dark:bg-opacity-50" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel
                className={cn(
                  'w-full transform overflow-hidden rounded-lg bg-white dark:bg-gray-800 p-6 text-left align-middle shadow-xl transition-all',
                  sizeClasses[size],
                  className
                )}
              >
                <div className="flex items-center justify-between mb-4">
                  <Dialog.Title
                    as="h3"
                    className="text-lg font-medium leading-6 text-gray-900 dark:text-white"
                  >
                    {title}
                  </Dialog.Title>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={onClose}
                    aria-label="Fechar"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
                
                <div className="mt-2">{children}</div>
                
                {footer && (
                  <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                    {footer}
                  </div>
                )}
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  )
}
</file>

<file path="app/components/ui/Pesquisa.tsx">
import React from 'react';
import { Input } from './Input'; // Assuming Input component exists in the same directory

interface PesquisaProps {
  placeholder?: string;
  valor: string;
  aoMudar: (valor: string) => void;
  className?: string;
}

export function Pesquisa({
  placeholder = 'Pesquisar...',
  valor,
  aoMudar,
  className = '',
}: PesquisaProps) {
  return (
    <div className={`relative ${className}`}>
      <Input
        type="search"
        placeholder={placeholder}
        value={valor}
        onChange={(e) => aoMudar(e.target.value)}
        className="pl-10 pr-4 py-2 w-full" // Add padding for icon if needed
      />
      {/* Optional: Add a search icon */}
      {/* <span className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400">
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
        </svg>
      </span> */}
    </div>
  );
}
</file>

<file path="app/components/ui/PreferencesButton.tsx">
'use client'

import { useState, useEffect } from 'react'
import { Settings, Eye, EyeOff, Type, Moon, Sun, BellRing, BellOff, Clock } from 'lucide-react'
import { Button } from '@/app/components/ui/Button'
import { Modal } from '@/app/components/ui/Modal'
import { usePerfilStore } from '@/app/stores/perfilStore'

export function PreferencesButton() {
  const [isOpen, setIsOpen] = useState(false)
  const {
    preferenciasVisuais,
    atualizarPreferenciasVisuais,
    notificacoesAtivas,
    alternarNotificacoes,
    pausasAtivas,
    alternarPausas
  } = usePerfilStore()

  function toggleModal() {
    setIsOpen(!isOpen)
  }

  return (
    <>
      <Button
        variant="outline"
        size="sm"
        onClick={toggleModal}
        className="flex items-center gap-2"
        aria-label="Preferências de visualização"
      >
        <Settings className="h-4 w-4" />
        <span className="hidden sm:inline">Preferências</span>
      </Button>

      {isOpen && (
        <Modal
          isOpen={isOpen}
          title="Preferências de Interface"
          onClose={toggleModal}
          className="max-w-md"
        >
          <div className="space-y-6 py-4">
            <div className="space-y-4">
              <h3 className="text-sm font-medium text-gray-900 dark:text-gray-100">
                Acessibilidade Visual
              </h3>
              
              <div className="grid grid-cols-1 gap-3">
                <button
                  onClick={() => atualizarPreferenciasVisuais({ 
                    altoContraste: !preferenciasVisuais.altoContraste 
                  })}
                  className={`flex items-center justify-between p-3 rounded-lg border ${
                    preferenciasVisuais.altoContraste
                      ? 'bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-800'
                      : 'bg-white border-gray-200 dark:bg-gray-800 dark:border-gray-700'
                  }`}
                  aria-pressed={preferenciasVisuais.altoContraste}
                  tabIndex={0}
                >
                  <div className="flex items-center">
                    <div className={`p-2 rounded-md ${
                      preferenciasVisuais.altoContraste
                        ? 'bg-blue-100 text-blue-600 dark:bg-blue-800 dark:text-blue-200'
                        : 'bg-gray-100 text-gray-500 dark:bg-gray-700 dark:text-gray-400'
                    }`}>
                      <Eye className="h-5 w-5" />
                    </div>
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-900 dark:text-white">
                        Alto Contraste
                      </p>
                      <p className="text-xs text-gray-500 dark:text-gray-400">
                        Aumenta o contraste entre elementos
                      </p>
                    </div>
                  </div>
                  <div className={`h-5 w-5 rounded-full ${
                    preferenciasVisuais.altoContraste
                      ? 'bg-blue-500'
                      : 'bg-gray-200 dark:bg-gray-600'
                  }`}>
                    {preferenciasVisuais.altoContraste && (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                      </svg>
                    )}
                  </div>
                </button>

                <button
                  onClick={() => atualizarPreferenciasVisuais({ 
                    reducaoEstimulos: !preferenciasVisuais.reducaoEstimulos 
                  })}
                  className={`flex items-center justify-between p-3 rounded-lg border ${
                    preferenciasVisuais.reducaoEstimulos
                      ? 'bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-800'
                      : 'bg-white border-gray-200 dark:bg-gray-800 dark:border-gray-700'
                  }`}
                  aria-pressed={preferenciasVisuais.reducaoEstimulos}
                  tabIndex={0}
                >
                  <div className="flex items-center">
                    <div className={`p-2 rounded-md ${
                      preferenciasVisuais.reducaoEstimulos
                        ? 'bg-blue-100 text-blue-600 dark:bg-blue-800 dark:text-blue-200'
                        : 'bg-gray-100 text-gray-500 dark:bg-gray-700 dark:text-gray-400'
                    }`}>
                      <EyeOff className="h-5 w-5" />
                    </div>
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-900 dark:text-white">
                        Redução de Estímulos
                      </p>
                      <p className="text-xs text-gray-500 dark:text-gray-400">
                        Remove animações e reduz elementos visuais
                      </p>
                    </div>
                  </div>
                  <div className={`h-5 w-5 rounded-full ${
                    preferenciasVisuais.reducaoEstimulos
                      ? 'bg-blue-500'
                      : 'bg-gray-200 dark:bg-gray-600'
                  }`}>
                    {preferenciasVisuais.reducaoEstimulos && (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                      </svg>
                    )}
                  </div>
                </button>

                <button
                  onClick={() => atualizarPreferenciasVisuais({ 
                    textoGrande: !preferenciasVisuais.textoGrande 
                  })}
                  className={`flex items-center justify-between p-3 rounded-lg border ${
                    preferenciasVisuais.textoGrande
                      ? 'bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-800'
                      : 'bg-white border-gray-200 dark:bg-gray-800 dark:border-gray-700'
                  }`}
                  aria-pressed={preferenciasVisuais.textoGrande}
                  tabIndex={0}
                >
                  <div className="flex items-center">
                    <div className={`p-2 rounded-md ${
                      preferenciasVisuais.textoGrande
                        ? 'bg-blue-100 text-blue-600 dark:bg-blue-800 dark:text-blue-200'
                        : 'bg-gray-100 text-gray-500 dark:bg-gray-700 dark:text-gray-400'
                    }`}>
                      <Type className="h-5 w-5" />
                    </div>
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-900 dark:text-white">
                        Texto Grande
                      </p>
                      <p className="text-xs text-gray-500 dark:text-gray-400">
                        Aumenta o tamanho do texto para melhor legibilidade
                      </p>
                    </div>
                  </div>
                  <div className={`h-5 w-5 rounded-full ${
                    preferenciasVisuais.textoGrande
                      ? 'bg-blue-500'
                      : 'bg-gray-200 dark:bg-gray-600'
                  }`}>
                    {preferenciasVisuais.textoGrande && (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                      </svg>
                    )}
                  </div>
                </button>
              </div>
            </div>

            <div className="space-y-4">
              <h3 className="text-sm font-medium text-gray-900 dark:text-gray-100">
                Notificações e Lembretes
              </h3>
              
              <div className="grid grid-cols-1 gap-3">
                <button
                  onClick={alternarNotificacoes}
                  className={`flex items-center justify-between p-3 rounded-lg border ${
                    notificacoesAtivas
                      ? 'bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-800'
                      : 'bg-white border-gray-200 dark:bg-gray-800 dark:border-gray-700'
                  }`}
                  aria-pressed={notificacoesAtivas}
                  tabIndex={0}
                >
                  <div className="flex items-center">
                    <div className={`p-2 rounded-md ${
                      notificacoesAtivas
                        ? 'bg-blue-100 text-blue-600 dark:bg-blue-800 dark:text-blue-200'
                        : 'bg-gray-100 text-gray-500 dark:bg-gray-700 dark:text-gray-400'
                    }`}>
                      {notificacoesAtivas ? <BellRing className="h-5 w-5" /> : <BellOff className="h-5 w-5" />}
                    </div>
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-900 dark:text-white">
                        Notificações
                      </p>
                      <p className="text-xs text-gray-500 dark:text-gray-400">
                        {notificacoesAtivas ? 'Notificações ativadas' : 'Notificações desativadas'}
                      </p>
                    </div>
                  </div>
                  <div className={`h-5 w-5 rounded-full ${
                    notificacoesAtivas
                      ? 'bg-blue-500'
                      : 'bg-gray-200 dark:bg-gray-600'
                  }`}>
                    {notificacoesAtivas && (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                      </svg>
                    )}
                  </div>
                </button>

                <button
                  onClick={alternarPausas}
                  className={`flex items-center justify-between p-3 rounded-lg border ${
                    pausasAtivas
                      ? 'bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-800'
                      : 'bg-white border-gray-200 dark:bg-gray-800 dark:border-gray-700'
                  }`}
                  aria-pressed={pausasAtivas}
                  tabIndex={0}
                >
                  <div className="flex items-center">
                    <div className={`p-2 rounded-md ${
                      pausasAtivas
                        ? 'bg-blue-100 text-blue-600 dark:bg-blue-800 dark:text-blue-200'
                        : 'bg-gray-100 text-gray-500 dark:bg-gray-700 dark:text-gray-400'
                    }`}>
                      <Clock className="h-5 w-5" />
                    </div>
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-900 dark:text-white">
                        Lembretes de Pausas
                      </p>
                      <p className="text-xs text-gray-500 dark:text-gray-400">
                        {pausasAtivas ? 'Lembretes ativados' : 'Lembretes desativados'}
                      </p>
                    </div>
                  </div>
                  <div className={`h-5 w-5 rounded-full ${
                    pausasAtivas
                      ? 'bg-blue-500'
                      : 'bg-gray-200 dark:bg-gray-600'
                  }`}>
                    {pausasAtivas && (
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                      </svg>
                    )}
                  </div>
                </button>
              </div>
            </div>
          </div>
          
          <div className="pt-4 border-t border-gray-200 dark:border-gray-700">
            <Button 
              onClick={toggleModal}
              className="w-full"
            >
              Salvar e Fechar
            </Button>
          </div>
        </Modal>
      )}
    </>
  )
}
</file>

<file path="app/components/ui/Section.tsx">
'use client'

import { cn } from '@/app/lib/utils'

interface SectionProps {
  children: React.ReactNode
  title: string
  description?: string
  className?: string
}

export function Section({ children, title, description, className }: SectionProps) {
  return (
    <section className={cn("py-6", className)}>
      <div className="mb-6">
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-2">{title}</h1>
        {description && (
          <p className="text-gray-600 dark:text-gray-400">{description}</p>
        )}
      </div>
      <div className="space-y-6">
        {children}
      </div>
    </section>
  )
}
</file>

<file path="app/components/ui/Select.tsx">
'use client'

import { SelectHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/app/lib/utils'

export interface SelectOption {
  value: string
  label: string
}

export interface SelectProps extends SelectHTMLAttributes<HTMLSelectElement> {
  label?: string
  options: SelectOption[]
  error?: string
  helpText?: string
}

export const Select = forwardRef<HTMLSelectElement, SelectProps>(
  ({ className, label, options, error, helpText, id, ...props }, ref) => {
    const selectId = id || `select-${Math.random().toString(36).substring(2, 9)}`
    
    return (
      <div className="w-full">
        {label && (
          <label
            htmlFor={selectId}
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            {label}
          </label>
        )}
        {helpText && (
          <p className="text-xs text-gray-500 dark:text-gray-400 mb-1">
            {helpText}
          </p>
        )}
        <select
          id={selectId}
          className={cn(
            "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white text-sm",
            error && "border-red-500 focus:ring-red-500 focus:border-red-500",
            className
          )}
          ref={ref}
          aria-invalid={error ? 'true' : 'false'}
          aria-describedby={error ? `${selectId}-error` : undefined}
          {...props}
        >
          {options.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
        {error && (
          <p
            id={`${selectId}-error`}
            className="mt-1 text-xs text-red-600 dark:text-red-400"
          >
            {error}
          </p>
        )}
      </div>
    )
  }
)
</file>

<file path="app/components/ui/Slider.tsx">
'use client'

import React from 'react'

interface SliderProps {
  min: number
  max: number
  step?: number
  value: number
  onChange: (value: number) => void
  disabled?: boolean
}

export function Slider({ min, max, step = 1, value, onChange, disabled = false }: SliderProps) {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange(Number(e.target.value))
  }
  
  // Calcular a porcentagem para o background gradient
  const percentage = ((value - min) / (max - min)) * 100
  
  return (
    <div className="relative w-full">
      <input
        type="range"
        min={min}
        max={max}
        step={step}
        value={value}
        onChange={handleChange}
        disabled={disabled}
        className={`
          w-full h-2 rounded-lg appearance-none cursor-pointer
          bg-gradient-to-r from-lazer-primary to-lazer-primary via-lazer-primary
          bg-no-repeat
          dark:bg-gray-700
          ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
        `}
        style={{
          backgroundSize: `${percentage}% 100%`,
          backgroundImage: 'linear-gradient(to right, var(--lazer-primary), var(--lazer-primary))'
        }}
        aria-valuemin={min}
        aria-valuemax={max}
        aria-valuenow={value}
      />
    </div>
  )
}
</file>

<file path="app/components/ui/StatCard.tsx">
import React, { ReactNode } from 'react'

interface StatCardProps {
  title: string
  value: string
  icon?: ReactNode
  description?: string
  className?: string
}

export function StatCard({ title, value, icon, description, className = '' }: StatCardProps) {
  return (
    <div className={`bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 ${className}`}>
      <div className="flex items-start">
        {icon && (
          <div className="mr-3 p-2 bg-gray-100 dark:bg-gray-700 rounded-full">
            {icon}
          </div>
        )}
        <div>
          <h3 className="text-sm font-medium text-gray-500 dark:text-gray-400">{title}</h3>
          <p className="text-2xl font-bold text-gray-900 dark:text-white mt-1">{value}</p>
          {description && (
            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">{description}</p>
          )}
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/components/ui/SuspenseWrapper.tsx">
'use client'

import { Suspense } from 'react'
import { SuspenseWrapperProps } from '@/app/types'

export function SuspenseWrapper({ children, fallback }: SuspenseWrapperProps) {
  return (
    <Suspense fallback={fallback}>
      {children}
    </Suspense>
  )
}
</file>

<file path="app/components/ui/Tag.tsx">
import React from 'react';

interface TagProps {
  children: React.ReactNode;
  className?: string;
}

export function Tag({ children, className = '' }: TagProps) {
  return (
    <span
      className={`inline-block bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded dark:bg-blue-900 dark:text-blue-300 ${className}`}
    >
      {children}
    </span>
  );
}
</file>

<file path="app/components/ui/TagInput.tsx">
'use client';

import React, { useState, KeyboardEvent } from 'react';
import { Input } from './Input';
import { Tag } from './Tag';
import { Button } from './Button'; // Assuming Button component exists

interface TagInputProps {
  tags: string[];
  onChange: (tags: string[]) => void;
  placeholder?: string;
  suggestions?: string[];
  className?: string;
}

export function TagInput({
  tags,
  onChange,
  placeholder = 'Adicionar tag...',
  suggestions = [],
  className = '',
}: TagInputProps) {
  const [inputValue, setInputValue] = useState('');
  const [filteredSuggestions, setFilteredSuggestions] = useState<string[]>([]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setInputValue(value);
    if (value && suggestions.length > 0) {
      setFilteredSuggestions(
        suggestions.filter(
          (suggestion) =>
            suggestion.toLowerCase().includes(value.toLowerCase()) &&
            !tags.includes(suggestion) // Don't suggest already added tags
        )
      );
    } else {
      setFilteredSuggestions([]);
    }
  };

  const addTag = (tagToAdd: string) => {
    const trimmedTag = tagToAdd.trim();
    if (trimmedTag && !tags.includes(trimmedTag)) {
      onChange([...tags, trimmedTag]);
    }
    setInputValue('');
    setFilteredSuggestions([]);
  };

  const removeTag = (tagToRemove: string) => {
    onChange(tags.filter((tag) => tag !== tagToRemove));
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' || e.key === ',') {
      e.preventDefault(); // Prevent form submission or comma input
      addTag(inputValue);
    } else if (e.key === 'Backspace' && !inputValue && tags.length > 0) {
      // Remove last tag on backspace if input is empty
      removeTag(tags[tags.length - 1]);
    }
  };

  return (
    <div className={className}>
      <div className="flex flex-wrap gap-2 mb-2">
        {tags.map((tag) => (
          <Tag key={tag} className="flex items-center gap-1">
            {tag}
            <button
              type="button"
              onClick={() => removeTag(tag)}
              className="ml-1 text-blue-600 hover:text-blue-800 focus:outline-none"
              aria-label={`Remover tag ${tag}`}
            >
              &times; {/* Multiplication sign as 'x' */}
            </button>
          </Tag>
        ))}
      </div>
      <div className="relative">
        <Input
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          className="w-full"
        />
        {filteredSuggestions.length > 0 && (
          <ul className="absolute z-10 w-full mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-lg max-h-40 overflow-y-auto">
            {filteredSuggestions.map((suggestion) => (
              <li
                key={suggestion}
                onClick={() => addTag(suggestion)}
                className="px-3 py-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700"
              >
                {suggestion}
              </li>
            ))}
          </ul>
        )}
      </div>
       {/* Optional: Display all suggestions if input is focused but empty */}
       {/* {inputValue === '' && suggestions.length > 0 && ( ... )} */}
    </div>
  );
}
</file>

<file path="app/components/ui/Textarea.tsx">
'use client'

import { TextareaHTMLAttributes, forwardRef } from 'react'
import { cn } from '@/app/lib/utils'

export interface TextareaProps extends TextareaHTMLAttributes<HTMLTextAreaElement> {
  label?: string
  error?: string
}

export const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, label, error, id, ...props }, ref) => {
    const textareaId = id || `textarea-${Math.random().toString(36).substring(2, 9)}`
    
    return (
      <div className="w-full">
        {label && (
          <label
            htmlFor={textareaId}
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            {label}
          </label>
        )}
        <textarea
          id={textareaId}
          className={cn(
            "w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-800 dark:text-white text-sm min-h-[80px]",
            error && "border-red-500 focus:ring-red-500 focus:border-red-500",
            className
          )}
          ref={ref}
          aria-invalid={error ? 'true' : 'false'}
          aria-describedby={error ? `${textareaId}-error` : undefined}
          {...props}
        />
        {error && (
          <p
            id={`${textareaId}-error`}
            className="mt-1 text-xs text-red-600 dark:text-red-400"
          >
            {error}
          </p>
        )}
      </div>
    )
  }
)
</file>

<file path="app/components/ui/Tooltip.tsx">
'use client'

import { ReactNode, useState } from 'react'
import { cn } from '@/app/lib/utils'

interface TooltipProps {
  children: ReactNode
  content: string
  position?: 'top' | 'bottom' | 'left' | 'right'
  className?: string
}

export function Tooltip({
  children,
  content,
  position = 'top',
  className,
}: TooltipProps) {
  const [isVisible, setIsVisible] = useState(false)

  const positionClasses = {
    top: 'bottom-full left-1/2 transform -translate-x-1/2 mb-2',
    bottom: 'top-full left-1/2 transform -translate-x-1/2 mt-2',
    left: 'right-full top-1/2 transform -translate-y-1/2 mr-2',
    right: 'left-full top-1/2 transform -translate-y-1/2 ml-2',
  }

  return (
    <div
      className="relative inline-block"
      onMouseEnter={() => setIsVisible(true)}
      onMouseLeave={() => setIsVisible(false)}
      onFocus={() => setIsVisible(true)}
      onBlur={() => setIsVisible(false)}
    >
      {isVisible && (
        <div
          className={cn(
            'absolute z-10 px-2 py-1 text-xs font-medium text-white bg-gray-800 rounded shadow-sm dark:bg-gray-700 max-w-xs',
            positionClasses[position],
            className
          )}
          role="tooltip"
        >
          {content}
          <div
            className={cn(
              'absolute w-2 h-2 bg-gray-800 dark:bg-gray-700 transform rotate-45',
              position === 'top' && 'bottom-0 left-1/2 -translate-x-1/2 translate-y-1/2',
              position === 'bottom' && 'top-0 left-1/2 -translate-x-1/2 -translate-y-1/2',
              position === 'left' && 'right-0 top-1/2 translate-x-1/2 -translate-y-1/2',
              position === 'right' && 'left-0 top-1/2 -translate-x-1/2 -translate-y-1/2'
            )}
          />
        </div>
      )}
      {children}
    </div>
  )
}
</file>

<file path="app/components/ExportarImportarDados.tsx">
'use client';

import { useState, useRef, useEffect, useCallback } from 'react';
// Import updated/new functions from dataService
import { 
  exportarDadosParaArquivo, 
  importarDadosDeArquivo, 
  obterDadosParaExportar,
  importarDadosFromObject 
} from '../lib/dataService'; 
import { useDataTransferStore } from '../stores/dataTransferStore';
// Import new icons
import { Download, Upload, AlertCircle, CheckCircle, Info, Clock, HelpCircle, LogIn, LogOut, Save, FolderOpen, Loader2 } from 'lucide-react'; 
import Link from 'next/link';
import { Button } from './ui/Button'; // Assuming Button component exists
import { Modal } from './ui/Modal'; // Assuming Modal component exists

// Define the type for Google Drive files listed
interface DriveFile {
  id: string;
  name: string;
  modifiedTime: string;
  createdTime: string;
}

/**
 * Componente para exportar e importar dados do aplicativo localmente ou via Google Drive.
 */
export const ExportarImportarDados = () => {
  const [status, setStatus] = useState<'idle' | 'exporting' | 'importing' | 'success' | 'error'>('idle');
  const [mensagem, setMensagem] = useState('');
  const [tipoMensagem, setTipoMensagem] = useState<'success' | 'error' | 'info'>('info');
  
  // Local file handling state
  const [mostrarConfirmacaoLocal, setMostrarConfirmacaoLocal] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [arquivoSelecionadoLocal, setArquivoSelecionadoLocal] = useState<File | null>(null);

  // Google Drive state
  const [isDriveAuthenticated, setIsDriveAuthenticated] = useState(false);
  const [isLoadingAuthCheck, setIsLoadingAuthCheck] = useState(true);
  const [isLoadingDriveAction, setIsLoadingDriveAction] = useState(false);
  const [driveFiles, setDriveFiles] = useState<DriveFile[]>([]);
  const [showDriveFilesModal, setShowDriveFilesModal] = useState(false);
  const [mostrarConfirmacaoDrive, setMostrarConfirmacaoDrive] = useState(false);
  const [dadosParaImportarDrive, setDadosParaImportarDrive] = useState<any>(null);
  const [timestampImportacaoDrive, setTimestampImportacaoDrive] = useState<string | undefined>(undefined);
  
  // Zustand store access
  const { 
    ultimaExportacao, 
    ultimaImportacao, 
    registrarExportacao, 
    registrarImportacao 
  } = useDataTransferStore();
  
  // --- Utility Functions ---

  const formatarData = (dataIso: string | null): string | null => {
    if (!dataIso) return null;
    try {
      const data = new Date(dataIso);
      return data.toLocaleDateString('pt-BR', {
        day: '2-digit', month: '2-digit', year: 'numeric',
        hour: '2-digit', minute: '2-digit'
      });
    } catch (e) {
      console.error("Error formatting date:", dataIso, e);
      return dataIso; // Return original string if formatting fails
    }
  };

  const clearMessage = useCallback(() => {
    setTimeout(() => {
      if (status !== 'exporting' && status !== 'importing' && !isLoadingDriveAction && !isLoadingAuthCheck) {
         setStatus('idle');
         setMensagem('');
         setTipoMensagem('info');
      }
    }, 5000); // Increased timeout
  }, [status, isLoadingDriveAction, isLoadingAuthCheck]);

  const showStatusMessage = (msg: string, type: 'success' | 'error' | 'info', currentStatus: 'idle' | 'exporting' | 'importing' | 'success' | 'error') => {
    setMensagem(msg);
    setTipoMensagem(type);
    setStatus(currentStatus);
    clearMessage();
  };

  // --- Google Drive Auth Check ---
  const checkDriveAuth = useCallback(async () => {
    setIsLoadingAuthCheck(true);
    try {
      const response = await fetch('/api/drive/checkAuth');
      if (!response.ok) throw new Error('Failed to check auth status');
      const data = await response.json();
      setIsDriveAuthenticated(data.isAuthenticated);
    } catch (error) {
      console.error('Erro ao verificar autenticação do Drive:', error);
      setIsDriveAuthenticated(false);
      showStatusMessage('Erro ao verificar conexão com Google Drive.', 'error', 'error');
    } finally {
      setIsLoadingAuthCheck(false);
    }
  }, []); // Dependencies are stable

  useEffect(() => {
    checkDriveAuth();
  }, [checkDriveAuth]);
  
  // --- Local File Handlers ---

  const handleExportarLocal = () => {
    setStatus('exporting');
    showStatusMessage('Exportando dados para arquivo local...', 'info', 'exporting');
    try {
      const resultado = exportarDadosParaArquivo(); 
      if (resultado.sucesso) {
        showStatusMessage(resultado.mensagem || 'Dados exportados com sucesso!', 'success', 'success');
        registrarExportacao(); 
      } else {
        throw new Error(resultado.erro || 'Erro desconhecido na exportação');
      }
    } catch (error: any) {
      showStatusMessage(`Erro ao exportar localmente: ${error.message}`, 'error', 'error');
    }
  };

  const handleSelecionarArquivoLocal = (evento: React.ChangeEvent<HTMLInputElement>) => {
    const arquivos = evento.target.files;
    if (!arquivos || arquivos.length === 0) return;
    const arquivo = arquivos[0];
    setArquivoSelecionadoLocal(arquivo);
    setMostrarConfirmacaoLocal(true);
    setMostrarConfirmacaoDrive(false); // Ensure only one confirmation shows
  };
  
  const cancelarImportacaoLocal = () => {
    setArquivoSelecionadoLocal(null);
    setMostrarConfirmacaoLocal(false);
    if (fileInputRef.current) fileInputRef.current.value = '';
  };
  
  const confirmarImportacaoLocal = async () => {
    if (!arquivoSelecionadoLocal) return;
    
    setStatus('importing');
    showStatusMessage('Importando dados do arquivo local...', 'info', 'importing');
    setMostrarConfirmacaoLocal(false);
    
    try {
      const resultado = await importarDadosDeArquivo(arquivoSelecionadoLocal); 
      if (resultado.sucesso) {
        registrarImportacao(resultado.timestamp); 
        const dataFormatada = formatarData(resultado.timestamp || null);
        showStatusMessage(`Dados importados com sucesso! (Backup local de ${dataFormatada})`, 'success', 'success');
      } else {
        throw new Error(resultado.erro || 'Erro desconhecido na importação');
      }
    } catch (error: any) {
      showStatusMessage(`Erro ao importar localmente: ${error.message}`, 'error', 'error');
    } finally {
       cancelarImportacaoLocal(); // Clear selection
    }
  };

  // --- Google Drive Handlers ---

  const handleConnectDrive = () => {
    window.location.href = '/api/auth/google/connect';
  };

  const handleDisconnectDrive = async () => {
    setIsLoadingDriveAction(true);
    showStatusMessage('Desconectando do Google Drive...', 'info', 'importing');
    try {
      const response = await fetch('/api/auth/google/disconnect', { method: 'POST' });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Falha ao desconectar');
      }
      setIsDriveAuthenticated(false);
      showStatusMessage('Desconectado do Google Drive com sucesso.', 'success', 'success');
    } catch (error: any) {
      console.error('Erro ao desconectar do Drive:', error);
      showStatusMessage(`Erro ao desconectar: ${error.message}`, 'error', 'error');
    } finally {
      setIsLoadingDriveAction(false);
    }
  };

  const handleSaveToDrive = async () => {
    setIsLoadingDriveAction(true);
    showStatusMessage('Salvando backup no Google Drive...', 'info', 'exporting');
    
    const dadosParaSalvar = obterDadosParaExportar();
    if (!dadosParaSalvar) {
      showStatusMessage('Erro ao coletar dados para salvar.', 'error', 'error');
      setIsLoadingDriveAction(false);
      return;
    }

    try {
      const response = await fetch('/api/drive/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(dadosParaSalvar),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Falha ao salvar no Drive');
      }
      
      const result = await response.json();
      showStatusMessage(`Backup salvo com sucesso no Google Drive: ${result.fileName}`, 'success', 'success');
      registrarExportacao(); 
    } catch (error: any) {
      console.error('Erro ao salvar no Drive:', error);
      showStatusMessage(`Erro ao salvar no Drive: ${error.message}`, 'error', 'error');
    } finally {
      setIsLoadingDriveAction(false);
    }
  };

  const handleLoadFromDrive = async () => {
    setIsLoadingDriveAction(true);
    showStatusMessage('Buscando backups no Google Drive...', 'info', 'importing');
    try {
      const response = await fetch('/api/drive/list');
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Falha ao listar arquivos do Drive');
      }
      const result = await response.json();
      if (result.success && result.files && result.files.length > 0) {
        setDriveFiles(result.files);
        setShowDriveFilesModal(true);
        // Clear loading message, modal will show results
        setMensagem(''); 
        setStatus('idle');
      } else {
        showStatusMessage('Nenhum arquivo de backup encontrado no Google Drive.', 'info', 'idle');
      }
    } catch (error: any) {
      console.error('Erro ao listar arquivos do Drive:', error);
      showStatusMessage(`Erro ao buscar backups: ${error.message}`, 'error', 'error');
    } finally {
      setIsLoadingDriveAction(false);
    }
  };

  const selectDriveFileToLoad = async (fileId: string) => {
    setShowDriveFilesModal(false);
    setIsLoadingDriveAction(true);
    showStatusMessage(`Carregando backup ${fileId} do Google Drive...`, 'info', 'importing');
    try {
      const response = await fetch(`/api/drive/load?fileId=${fileId}`);
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Falha ao carregar arquivo do Drive');
      }
      const result = await response.json();
      if (result.success && result.data) {
        setDadosParaImportarDrive(result.data); 
        setTimestampImportacaoDrive(result.data.timestamp); 
        setMostrarConfirmacaoDrive(true); 
        setMostrarConfirmacaoLocal(false);
        // Clear loading message, confirmation dialog will show
        setMensagem(''); 
        setStatus('idle');
      } else {
        throw new Error('Dados inválidos recebidos do backup do Drive.');
      }
    } catch (error: any) {
      console.error('Erro ao carregar arquivo do Drive:', error);
      showStatusMessage(`Erro ao carregar backup: ${error.message}`, 'error', 'error');
    } finally {
      setIsLoadingDriveAction(false);
    }
  };

  const cancelarImportacaoDrive = () => {
    setDadosParaImportarDrive(null);
    setTimestampImportacaoDrive(undefined);
    setMostrarConfirmacaoDrive(false);
  };

  const confirmarImportacaoDrive = () => {
    if (!dadosParaImportarDrive) return;

    setStatus('importing');
    showStatusMessage('Importando dados do Google Drive...', 'info', 'importing');
    setMostrarConfirmacaoDrive(false);

    try {
      const resultado = importarDadosFromObject(dadosParaImportarDrive); 
      if (resultado.sucesso) {
        registrarImportacao(resultado.timestamp); 
        const dataFormatada = formatarData(resultado.timestamp || null);
        showStatusMessage(`Dados importados com sucesso! (Backup do Drive de ${dataFormatada})`, 'success', 'success');
      } else {
        throw new Error(resultado.erro || 'Erro desconhecido na importação do Drive');
      }
    } catch (error: any) {
      showStatusMessage(`Erro ao importar do Drive: ${error.message}`, 'error', 'error');
    } finally {
      setDadosParaImportarDrive(null); 
      setTimestampImportacaoDrive(undefined);
    }
  };

  // --- Render Logic ---
  const isLoading = status === 'exporting' || status === 'importing' || isLoadingAuthCheck || isLoadingDriveAction;

  return (
    <>
      {/* Main Component Card */}
      <div className="w-full max-w-lg mx-auto bg-card text-card-foreground rounded-lg shadow-md p-6 border">
        {/* Header */}
        <div className="mb-6">
          <div className="flex items-center justify-between">
            <h2 className="text-xl font-semibold">Backup Local e Google Drive</h2>
            <Link href="/perfil/ajuda" className="text-primary hover:underline flex items-center" title="Ajuda">
              <HelpCircle size={16} />
            </Link>
          </div>
          <p className="text-sm text-muted-foreground">
            Faça backup local ou no Google Drive, e restaure seus dados.
          </p>
        </div>
        
        {/* Global Status Message Area */}
        {mensagem && (
          <div className={`mb-4 flex items-start gap-3 p-3 rounded-md text-sm border ${
            tipoMensagem === 'success' ? 'bg-green-50 dark:bg-green-900/30 border-green-200 dark:border-green-700 text-green-700 dark:text-green-300' : 
            tipoMensagem === 'error' ? 'bg-red-50 dark:bg-red-900/30 border-red-200 dark:border-red-700 text-red-700 dark:text-red-300' : 
            'bg-blue-50 dark:bg-blue-900/30 border-blue-200 dark:border-blue-700 text-blue-700 dark:text-blue-300' // Info style
          }`}>
            {tipoMensagem === 'success' ? <CheckCircle className="flex-shrink-0 mt-0.5" size={18} /> : 
             tipoMensagem === 'error' ? <AlertCircle className="flex-shrink-0 mt-0.5" size={18} /> :
             <Info className="flex-shrink-0 mt-0.5" size={18} />}
            <span className="flex-grow">{mensagem}</span>
            {isLoading && <Loader2 className="animate-spin ml-2 flex-shrink-0" size={18} />}
          </div>
        )}

        {/* Main Content Area */}
        <div className="space-y-6">
          {/* History Section */}
          {(ultimaExportacao || ultimaImportacao) && (
            <div className="text-xs text-muted-foreground space-y-1 border-b pb-4">
              {ultimaExportacao && (
                <div className="flex items-center gap-1">
                  <Clock size={12} />
                  <span>Última exportação (local/Drive): {formatarData(ultimaExportacao)}</span>
                </div>
              )}
              {ultimaImportacao && (
                <div className="flex items-center gap-1">
                  <Clock size={12} />
                  <span>Última importação (local/Drive): {formatarData(ultimaImportacao)}</span>
                </div>
              )}
            </div>
          )}

          {/* Google Drive Section */}
          <div className="space-y-3 p-4 border rounded-md">
            <h3 className="font-medium">Google Drive</h3>
            {isLoadingAuthCheck ? (
               <div className="flex items-center text-sm text-muted-foreground"> <Loader2 className="animate-spin mr-2" size={16} /> Verificando conexão...</div>
            ) : isDriveAuthenticated ? (
              <div className="space-y-2">
                 <p className="text-sm text-green-600 dark:text-green-400">Conectado ao Google Drive.</p>
                 <div className="grid grid-cols-1 sm:grid-cols-3 gap-2">
                   <Button onClick={handleSaveToDrive} disabled={isLoading} variant="outline" size="sm">
                     <Save size={16} className="mr-1" /> Salvar
                   </Button>
                   <Button onClick={handleLoadFromDrive} disabled={isLoading} variant="outline" size="sm">
                     <FolderOpen size={16} className="mr-1" /> Carregar
                   </Button>
                   <Button onClick={handleDisconnectDrive} disabled={isLoading} variant="destructive" size="sm">
                     <LogOut size={16} className="mr-1" /> Desconectar
                   </Button>
                 </div>
              </div>
            ) : (
              <div className="space-y-2">
                <p className="text-sm text-muted-foreground">Conecte sua conta para salvar e carregar backups na nuvem.</p>
                <Button onClick={handleConnectDrive} disabled={isLoading}>
                  <LogIn size={16} className="mr-1" /> Conectar ao Google Drive
                </Button>
              </div>
            )}
          </div>

          {/* Local Backup Section */}
          <div className="space-y-3 pt-4 border-t">
             <h3 className="font-medium">Backup Local</h3>
             <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                {/* Local Export */}
                <div className="space-y-1 flex flex-col">
                  <Button onClick={handleExportarLocal} disabled={isLoading} variant="outline">
                    <Download size={18} className="mr-1" /> Exportar Arquivo
                  </Button>
                  <p className="text-xs text-muted-foreground text-center">Salva um arquivo .json.</p>
                </div>
                
                {/* Local Import */}
                <div className="space-y-1 flex flex-col">
                  <Button onClick={() => fileInputRef.current?.click()} disabled={isLoading || mostrarConfirmacaoLocal || mostrarConfirmacaoDrive} variant="outline">
                    <Upload size={18} className="mr-1" /> Importar Arquivo
                  </Button>
                  <input type="file" ref={fileInputRef} onChange={handleSelecionarArquivoLocal} accept=".json" className="hidden" />
                  <p className="text-xs text-muted-foreground text-center">Restaura de um arquivo .json.</p>
                </div>
             </div>
          </div>
          
          {/* Local Confirmation Dialog */}
          {mostrarConfirmacaoLocal && arquivoSelecionadoLocal && (
            <div className="mt-4 p-4 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-md">
              <div className="flex items-start gap-3">
                <Info className="text-yellow-600 dark:text-yellow-400 mt-0.5 flex-shrink-0" size={20} />
                <div>
                  <h3 className="font-medium text-yellow-800 dark:text-yellow-200">Confirmar Importação Local</h3>
                  <p className="text-sm text-yellow-700 dark:text-yellow-300 mt-1">
                    Substituir dados atuais pelos dados do arquivo: <span className="font-mono">{arquivoSelecionadoLocal.name}</span>?
                  </p>
                  <div className="flex gap-2 mt-3">
                    {/* Use outline variant for confirmation */}
                    <Button onClick={confirmarImportacaoLocal} size="sm" variant="outline">Importar Local</Button> 
                    <Button onClick={cancelarImportacaoLocal} size="sm" variant="ghost">Cancelar</Button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Drive Confirmation Dialog */}
          {mostrarConfirmacaoDrive && dadosParaImportarDrive && (
            <div className="mt-4 p-4 bg-yellow-50 dark:bg-yellow-900/30 border border-yellow-200 dark:border-yellow-700 rounded-md">
              <div className="flex items-start gap-3">
                <Info className="text-yellow-600 dark:text-yellow-400 mt-0.5 flex-shrink-0" size={20} />
                <div>
                  <h3 className="font-medium text-yellow-800 dark:text-yellow-200">Confirmar Importação do Drive</h3>
                  <p className="text-sm text-yellow-700 dark:text-yellow-300 mt-1">
                    Substituir dados atuais pelos dados do backup de <span className="font-mono">{formatarData(timestampImportacaoDrive || null)}</span>?
                  </p>
                  <div className="flex gap-2 mt-3">
                     {/* Use outline variant for confirmation */}
                    <Button onClick={confirmarImportacaoDrive} size="sm" variant="outline">Importar do Drive</Button>
                    <Button onClick={cancelarImportacaoDrive} size="sm" variant="ghost">Cancelar</Button>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Modal for selecting Drive file */}
      <Modal 
        isOpen={showDriveFilesModal} 
        onClose={() => setShowDriveFilesModal(false)}
        title="Selecione um Backup do Google Drive"
      >
        <div className="max-h-96 overflow-y-auto space-y-2 p-1"> {/* Add padding */}
          {isLoadingDriveAction ? (
             <div className="flex justify-center items-center p-4"> <Loader2 className="animate-spin mr-2" size={16} /> Carregando...</div>
          ) : driveFiles.length > 0 ? (
            driveFiles.map((file) => (
              <button
                key={file.id}
                onClick={() => selectDriveFileToLoad(file.id)}
                disabled={isLoading}
                className="w-full text-left p-3 bg-background hover:bg-muted rounded-md transition-colors border disabled:opacity-50"
              >
                <p className="font-medium">{file.name}</p>
                <p className="text-xs text-muted-foreground">
                  Modificado: {formatarData(file.modifiedTime)}
                </p>
              </button>
            ))
          ) : (
            <p className="text-center text-muted-foreground py-4">Nenhum arquivo de backup encontrado.</p>
          )}
        </div>
      </Modal>
    </>
  );
};
</file>

<file path="app/components/ThemeProvider.tsx">
'use client'

import { createContext, useContext, useEffect, useState } from 'react'

type Theme = 'dark' | 'light' | 'system'

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  enableSystem?: boolean
  disableTransitionOnChange?: boolean
  attribute?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) => void
  systemTheme: 'dark' | 'light' | undefined
}

const initialState: ThemeProviderState = {
  theme: 'system',
  setTheme: () => null,
  systemTheme: undefined,
}

const ThemeProviderContext = createContext<ThemeProviderState>(initialState)

export function ThemeProvider({
  children,
  defaultTheme = 'system',
  enableSystem = true,
  disableTransitionOnChange = false,
  attribute = 'class',
  ...props
}: ThemeProviderProps) {
  const [theme, setThemeState] = useState<Theme>(defaultTheme)
  const [systemTheme, setSystemTheme] = useState<'dark' | 'light' | undefined>(undefined)

  useEffect(() => {
    const root = window.document.documentElement
    
    // Remove transition classes
    if (disableTransitionOnChange) {
      root.classList.add('transition-none')
      window.setTimeout(() => {
        root.classList.remove('transition-none')
      }, 0)
    }

    // Check for system preference
    if (theme === 'system' && enableSystem) {
      const systemPreference = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
      setSystemTheme(systemPreference)
      
      root.classList.remove('light', 'dark')
      root.classList.add(systemPreference)
      return
    }

    // Apply theme
    root.classList.remove('light', 'dark')
    root.classList.add(theme)
  }, [theme, disableTransitionOnChange, enableSystem])

  // Listen for system preference changes
  useEffect(() => {
    if (!enableSystem) return

    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
    
    const handleChange = () => {
      const newSystemTheme = mediaQuery.matches ? 'dark' : 'light'
      setSystemTheme(newSystemTheme)
      
      if (theme === 'system') {
        document.documentElement.classList.remove('light', 'dark')
        document.documentElement.classList.add(newSystemTheme)
      }
    }

    mediaQuery.addEventListener('change', handleChange)
    return () => mediaQuery.removeEventListener('change', handleChange)
  }, [enableSystem, theme])

  const setTheme = (theme: Theme) => {
    setThemeState(theme)
    // Save to localStorage
    localStorage.setItem('theme', theme)
  }

  // Initialize from localStorage
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme') as Theme | null
    if (savedTheme) {
      setThemeState(savedTheme)
    }
  }, [])

  const value = {
    theme,
    setTheme,
    systemTheme,
  }

  return (
    <ThemeProviderContext.Provider {...props} value={value}>
      {children}
    </ThemeProviderContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext)
  
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }

  return context
}
</file>

<file path="app/concursos/[id]/page.tsx">
'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useConcursosStore } from '@/app/stores/concursosStore';
import { useQuestoesStore, Questao } from '@/app/stores/questoesStore';
import { Button } from '@/app/components/ui/Button';
import { ConcursoForm } from '@/app/components/concursos/ConcursoForm';
import { QuestaoList } from '@/app/components/concursos/QuestaoList';
import { GeradorQuestoesLLM } from '@/app/components/concursos/GeradorQuestoesLLM';
import { QuestaoForm } from '@/app/components/concursos/QuestaoForm';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { Award, Calendar, Edit, ExternalLink, Trash, BookOpen, ChevronDown, ChevronUp, Star, StarOff, Edit2, X } from 'lucide-react';
import { Input } from '@/app/components/ui/Input';
import VisualizadorMarkdown from '@/app/components/estudos/VisualizadorMarkdown';
import { VisualizadorChecklist } from '@/app/components/estudos/VisualizadorChecklist'; // Importar VisualizadorChecklist
import { Modal } from '@/app/components/ui/Modal'; // Importar Modal

interface DetalhesConcursoPageProps {
  params: {
    id: string;
  };
}

interface SimuladoFavorito {
  id: string;
  nome: string;
  data: string;
  link: string;
}

export default function DetalhesConcursoPage({ params }: DetalhesConcursoPageProps) {
  const router = useRouter();
  const { concursos, removerConcurso, atualizarProgresso } = useConcursosStore();
  const [showQuestaoModal, setShowQuestaoModal] = useState(false);
  const [questaoParaEditar, setQuestaoParaEditar] = useState<Questao | null>(null);
  const [showEditModal, setShowEditModal] = useState(false);
 
  // Estados para os modais de materiais
  const [isMaterialVisualizationModalOpen, setIsMaterialVisualizationModalOpen] = useState(false); // Estado único para visibilidade do modal de visualização
  const [selectedMaterialFileId, setSelectedMaterialFileId] = useState<string | null>(null);
  const [materialModalTitle, setMaterialModalTitle] = useState('');

  // Novos estados para seleção de arquivos
  const [isFileListModalOpen, setIsFileListModalOpen] = useState(false);
  const [filesForSelection, setFilesForSelection] = useState<{ id: string; name: string }[]>([]);
  const [selectedMaterialType, setSelectedMaterialType] = useState<string | null>(null);


  // Abas principais
  const abas = [
    { key: 'conteudo', label: 'Conteúdo Programático' },
    { key: 'gerar', label: 'Gerar Questões Automáticas' },
    { key: 'questoes', label: 'Questões do Concurso' },
    { key: 'simulados', label: 'Simulados Salvos' },
    { key: 'materiais', label: 'Materiais de Estudo' } // Nova aba adicionada
  ];
  const [abaAtiva, setAbaAtiva] = useState('conteudo');

  // Collapse/expand do conteúdo programático
  const concurso = concursos.find(c => c.id === params.id);
  const [disciplinasAbertas, setDisciplinasAbertas] = useState<{ [disciplina: string]: boolean }>({});

  // Simulados favoritos (armazenados no localStorage por concurso)
  const storageKey = `simulados_favoritos_${params.id}`;
  const [simuladosFavoritos, setSimuladosFavoritos] = useState<SimuladoFavorito[]>(() => {
    if (typeof window !== 'undefined') {
      try {
        return JSON.parse(localStorage.getItem(storageKey) || '[]');
      } catch {
        return [];
      }
    }
    return [];
  });
  const [editandoSimuladoId, setEditandoSimuladoId] = useState<string | null>(null);
  const [novoNomeSimulado, setNovoNomeSimulado] = useState('');

  if (!concurso) {
    return (
      <div className="text-center py-12">
        <p className="text-gray-500">Concurso não encontrado</p>
        <Button variant="outline" onClick={() => router.push('/concursos')} className="mt-4">
          Voltar para Concursos
        </Button>
      </div>
    );
  }

  const handleRemover = () => {
    if (confirm('Tem certeza que deseja remover este concurso?')) {
      removerConcurso(concurso.id);
      router.push('/concursos');
    }
  };

  const handleProgressoChange = (disciplina: string, value: number) => {
    atualizarProgresso(concurso.id, disciplina, value);
  };

  const handleAddQuestaoClick = () => {
    setQuestaoParaEditar(null);
    setShowQuestaoModal(true);
  };

  const handleEditQuestaoClick = (questao: Questao) => {
    setQuestaoParaEditar(questao);
    setShowQuestaoModal(true);
  };

  const handleCloseQuestaoModal = () => {
    setShowQuestaoModal(false);
    setQuestaoParaEditar(null);
  };

  // Função para fechar o modal de visualização de materiais
  const handleCloseMaterialVisualizationModal = () => {
    setIsMaterialVisualizationModalOpen(false);
    setSelectedMaterialFileId(null);
    setMaterialModalTitle('');
    setSelectedMaterialType(null); // Resetar o tipo selecionado ao fechar
  };

  // Collapse/expand handler
  const toggleDisciplina = (disciplina: string) => {
    setDisciplinasAbertas(prev => ({
      ...prev,
      [disciplina]: !prev[disciplina]
    }));
  };

  // Simulados favoritos handlers
  const handleFavoritarSimulado = (simulado: SimuladoFavorito) => {
    const novos = [...simuladosFavoritos, simulado];
    setSimuladosFavoritos(novos);
    localStorage.setItem(storageKey, JSON.stringify(novos));
  };

  const handleExcluirSimulado = (id: string) => {
    const novos = simuladosFavoritos.filter(s => s.id !== id);
    setSimuladosFavoritos(novos);
    localStorage.setItem(storageKey, JSON.stringify(novos));
  };

  const handleEditarNomeSimulado = (id: string) => {
    setEditandoSimuladoId(id);
    const simulado = simuladosFavoritos.find(s => s.id === id);
    setNovoNomeSimulado(simulado?.nome || '');
  };

  const handleSalvarNomeSimulado = (id: string) => {
    const novos = simuladosFavoritos.map(s =>
      s.id === id ? { ...s, nome: novoNomeSimulado } : s
    );
    setSimuladosFavoritos(novos);
    localStorage.setItem(storageKey, JSON.stringify(novos));
    setEditandoSimuladoId(null);
    setNovoNomeSimulado('');
  };

  const progressoGeral = Math.round(
    (concurso.conteudoProgramatico.reduce((acc, curr) => acc + curr.progresso, 0)) /
    (concurso.conteudoProgramatico.length || 1)
  );

  // Função para selecionar o tipo de material e buscar arquivos
  const handleSelectMaterialType = async (materialNome: string) => {
    setSelectedMaterialType(materialNome);
    setMaterialModalTitle(materialNome); // Define o título do modal de visualização antecipadamente

    try {
      const response = await fetch(`/api/drive/listar-materiais?tipo=${encodeURIComponent(materialNome.toLowerCase())}`);
      const data = await response.json();

      if (response.ok && data.files && Array.isArray(data.files)) {
        if (data.files.length > 1) {
          // Múltiplos arquivos, exibir lista para seleção
          setFilesForSelection(data.files);
          setIsFileListModalOpen(true);
        } else if (data.files.length === 1) {
          // Apenas um arquivo, abrir diretamente
          const file = data.files[0];
          setSelectedMaterialFileId(file.id);
          setMaterialModalTitle(`${materialNome}: ${file.name}`);
          setIsMaterialVisualizationModalOpen(true); // Abre o modal de visualização
        } else {
          // Nenhum arquivo encontrado
          alert(`Nenhum arquivo encontrado para o material: ${materialNome}`);
          setSelectedMaterialFileId(null); // Garante que nenhum arquivo anterior seja exibido
          setIsMaterialVisualizationModalOpen(false); // Garante que o modal esteja fechado
        }
      } else {
        // Erro na resposta da API
        alert(`Erro ao listar arquivos para o material: ${materialNome}`);
        console.error('Erro na resposta da API:', data);
        setSelectedMaterialFileId(null);
        setIsMaterialVisualizationModalOpen(false); // Garante que o modal esteja fechado
      }
    } catch (error) {
      console.error('Erro ao buscar lista de arquivos:', error);
      alert(`Erro ao buscar lista de arquivos para o material: ${materialNome}`);
      setSelectedMaterialFileId(null);
      setIsMaterialVisualizationModalOpen(false); // Garante que o modal esteja fechado
    }
  };

  // Função para lidar com a seleção de um arquivo na lista
  const handleFileSelection = (file: { id: string; name: string }) => {
    if (selectedMaterialType) {
      setSelectedMaterialFileId(file.id);
      setMaterialModalTitle(`${selectedMaterialType}: ${file.name}`);
      setIsFileListModalOpen(false); // Fecha o modal de seleção de arquivos
      setIsMaterialVisualizationModalOpen(true); // Abre o modal de visualização
    }
  };


  return (
    <div className="space-y-6">
      <div className="flex justify-between items-start">
        <div>
          <div className="flex items-center gap-2 mb-2">
            <Award className="text-indigo-600" size={24} />
            <h1 className="text-2xl font-bold">{concurso.titulo}</h1>
          </div>
          <p className="text-gray-500">{concurso.organizadora}</p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={() => setShowEditModal(true)}>
            <Edit size={16} className="mr-2" />
            Editar
          </Button>
          <Button variant="destructive" onClick={handleRemover}>
            <Trash size={16} className="mr-2" />
            Remover
          </Button>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="space-y-4">
          <div className="flex items-center gap-3">
            <Calendar size={16} className="text-gray-500" />
            <div>
              <div className="text-sm text-gray-500">Data da Prova</div>
              <div>{format(new Date(concurso.dataProva), 'dd/MM/yyyy', { locale: ptBR })}</div>
            </div>
          </div>
          <div>
            <div className="text-sm text-gray-500 mb-1">Inscrição</div>
            <div>{format(new Date(concurso.dataInscricao), 'dd/MM/yyyy', { locale: ptBR })}</div>
          </div>
          {concurso.edital && (
            <div>
              <div className="text-sm text-gray-500 mb-1">Edital</div>
              <a
                href={concurso.edital}
                target="_blank"
                rel="noopener noreferrer"
                className="text-indigo-600 hover:text-indigo-700 flex items-center gap-1"
              >
                Ver edital <ExternalLink size={14} />
              </a>
            </div>
          )}
        </div>
        <div>
          <div className="text-lg font-semibold mb-4">Progresso Geral</div>
          <div className="flex justify-between items-center text-sm mb-2">
            <span>Total concluído</span>
            <span className="font-medium">{progressoGeral}%</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2.5 mb-6">
            <div
              className="bg-indigo-600 h-2.5 rounded-full"
              style={{ width: `${progressoGeral}%` }}
            ></div>
          </div>
        </div>
      </div>

      {/* Abas principais */}
      <div className="flex gap-2 border-b mb-4">
        {abas.map((aba) => (
          <Button
            key={aba.key}
            variant={abaAtiva === aba.key ? 'primary' : 'outline'}
            size="sm"
            className={`rounded-b-none ${abaAtiva === aba.key ? 'border-b-2 border-blue-600' : ''}`}
            onClick={() => setAbaAtiva(aba.key)}
          >
            {aba.label}
          </Button>
        ))}
      </div>

      {/* Conteúdo das abas */}
      {abaAtiva === 'conteudo' && (
        <div>
          <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
            <BookOpen size={20} /> Conteúdo Programático
          </h2>
          <div className="space-y-4">
            {concurso.conteudoProgramatico.map((disciplina, index) => {
              const aberta = disciplinasAbertas[disciplina.disciplina] ?? true;
              return (
                <div key={index} className="border rounded-lg">
                  <div className="flex justify-between items-center p-4 cursor-pointer" onClick={() => toggleDisciplina(disciplina.disciplina)}>
                    <h3 className="font-medium">{disciplina.disciplina}</h3>
                    <div className="flex items-center gap-2">
                      <input
                        type="range"
                        min="0"
                        max="100"
                        value={disciplina.progresso}
                        onChange={(e) => handleProgressoChange(disciplina.disciplina, Number(e.target.value))}
                        className="w-32"
                        onClick={e => e.stopPropagation()}
                      />
                      <span className="text-sm font-medium w-12">{disciplina.progresso}%</span>
                      <Button variant="ghost" size="icon" onClick={e => { e.stopPropagation(); toggleDisciplina(disciplina.disciplina); }}>
                        {aberta ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                      </Button>
                    </div>
                  </div>
                  {aberta && (
                    <ul className="list-disc list-inside space-y-1 px-6 pb-4">
                      {disciplina.topicos.map((topico, topicoIndex) => (
                        <li key={topicoIndex} className="text-sm text-gray-600">
                          {topico}
                        </li>
                      ))}
                    </ul>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      )}

      {abaAtiva === 'gerar' && (
        <div>
          <GeradorQuestoesLLM concursoId={concurso.id} />
        </div>
      )}

      {abaAtiva === 'questoes' && (
        <div>
          <QuestaoList
            concursoId={concurso.id}
            onAddQuestao={handleAddQuestaoClick}
            onEditQuestao={handleEditQuestaoClick}
          />
        </div>
      )}

      {abaAtiva === 'simulados' && (
        <div>
          <h2 className="text-lg font-semibold mb-4 flex items-center gap-2">
            <Star size={20} /> Simulados Salvos
          </h2>
          {simuladosFavoritos.length === 0 ? (
            <p className="text-gray-500">Nenhum simulado favoritado ainda.</p>
          ) : (
            <ul className="space-y-3">
              {simuladosFavoritos.map((simulado) => (
                <li key={simulado.id} className="border rounded-lg p-3 flex justify-between items-center">
                  <div>
                    {editandoSimuladoId === simulado.id ? (
                      <div className="flex items-center gap-2">
                        <Input
                          value={novoNomeSimulado}
                          onChange={e => setNovoNomeSimulado(e.target.value)}
                        />
                        <Button size="sm" variant="success" onClick={() => handleSalvarNomeSimulado(simulado.id)}>
                          Salvar
                        </Button>
                        <Button size="sm" variant="outline" onClick={() => setEditandoSimuladoId(null)}>
                          Cancelar
                        </Button>
                      </div>
                    ) : (
                      <span className="font-medium">{simulado.nome}</span>
                    )}
                    <div className="text-xs text-gray-500">{format(new Date(simulado.data), 'dd/MM/yyyy HH:mm', { locale: ptBR })}</div>
                  </div>
                  <div className="flex gap-2">
                    <Button size="icon" variant="outline" onClick={() => router.push(simulado.link)} title="Abrir simulado">
                      <ExternalLink size={16} />
                    </Button>
                    <Button size="icon" variant="outline" onClick={() => handleEditarNomeSimulado(simulado.id)} title="Editar nome">
                      <Edit2 size={16} />
                    </Button>
                    <Button size="icon" variant="destructive" onClick={() => handleExcluirSimulado(simulado.id)} title="Excluir">
                      <X size={16} />
                    </Button>
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>
      )}

      {/* Conteúdo da nova aba Materiais de Estudo */}
      {abaAtiva === 'materiais' && (
        <div>
          <h2 className="text-lg font-semibold mb-4">Materiais de Estudo Gerais</h2>
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
            {/* Removido o mapeamento materialPaths, agora usa nomes diretos */}
            <Button variant="outline" onClick={() => handleSelectMaterialType('Resumos')}>Resumos</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Flashcards')}>Flashcards</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Simulados')}>Simulados</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Tarefas')}>Tarefas</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Estratégias de Foco')}>Estratégias de Foco</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Agendamento de Pausas')}>Agendamento de Pausas</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Mapas Mentais')}>Mapas Mentais</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Outlines de Infográficos')}>Outlines de Infográficos</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Checklists')}>Checklists</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Guias de Estudo')}>Guias de Estudo</Button>
          </div>
        </div>
      )}

      {/* Modal/Form para Adicionar/Editar Concurso */}
      <ConcursoForm
        isOpen={showEditModal}
        onClose={() => setShowEditModal(false)}
        concursoParaEditar={concurso}
      />

      {/* Modal/Form para Adicionar/Editar Questão */}
      <QuestaoForm
        isOpen={showQuestaoModal}
        onClose={handleCloseQuestaoModal}
        concursoId={concurso.id}
        questaoParaEditar={questaoParaEditar}
      />

      {/* Modal para seleção de arquivos */}
      <Modal
        isOpen={isFileListModalOpen}
        onClose={() => setIsFileListModalOpen(false)}
        title={`Selecionar Arquivo para ${selectedMaterialType}`}
      >
        <div className="space-y-2">
          {filesForSelection.map((file) => (
            <Button
              key={file.id}
              variant="outline"
              className="w-full justify-start"
              onClick={() => handleFileSelection(file)}
            >
              {file.name}
            </Button>
          ))}
        </div>
      </Modal>

      {/* Modal Visualizador de Markdown */}
      {selectedMaterialType !== 'Checklists' && (
        <VisualizadorMarkdown
          isOpen={isMaterialVisualizationModalOpen} // Usar estado único
          onClose={handleCloseMaterialVisualizationModal} // Usar função única de fechar
          fileId={selectedMaterialFileId}
          title={materialModalTitle}
        />
      )}

      {/* Modal Visualizador de Checklist */}
      {selectedMaterialType === 'Checklists' && (
        <VisualizadorChecklist
          isOpen={isMaterialVisualizationModalOpen} // Usar estado único
          onClose={handleCloseMaterialVisualizationModal} // Usar função única de fechar
          fileId={selectedMaterialFileId}
          title={materialModalTitle}
        />
      )}
    </div>
  );
}
</file>

<file path="app/concursos/page.tsx">
'use client';

import React, { useState } from 'react';
import { Award, Calendar, Plus, Wand2, ListChecks, Upload } from 'lucide-react';
import { useConcursosStore } from '@/app/stores/concursosStore';
import { Button } from '@/app/components/ui/Button';
import { Card } from '@/app/components/ui/Card';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { ConcursoForm } from '@/app/components/concursos/ConcursoForm';
import { GeradorContextoLLM } from '@/app/components/concursos/GeradorContextoLLM';
import Link from 'next/link';
import { ImportarConcursoJsonModal } from '@/app/components/concursos/ImportarConcursoJsonModal';
import { useRouter } from 'next/navigation';

// Mapeamento de status para labels em português
const statusLabel = {
  planejado: 'Planejado',
  inscrito: 'Inscrito',
  estudando: 'Estudando',
  realizado: 'Realizado',
  aguardando_resultado: 'Aguardando Resultado'
};

const statusColors = {
  planejado: 'bg-gray-100 text-gray-800',
  inscrito: 'bg-blue-100 text-blue-800',
  estudando: 'bg-indigo-100 text-indigo-800',
  realizado: 'bg-green-100 text-green-800',
  aguardando_resultado: 'bg-yellow-100 text-yellow-800'
};

// Mapeamento de status para labels em português
// ... (código existente) ...

// Mapeamento de cores para status
// ... (código existente) ...

export default function ConcursosPage() {
  const { concursos, adicionarConcurso } = useConcursosStore();
  const [showAddModal, setShowAddModal] = useState(false);
  const [showImportModal, setShowImportModal] = useState(false);
  const [modoCadastro, setModoCadastro] = useState<'manual' | 'llm'>('manual');
  const router = useRouter();

  // Função para importar concurso via JSON
  const handleImportConcurso = (concurso: any) => {
    // Gera um id único (igual ao store)
    const id = (typeof crypto !== 'undefined' && crypto.randomUUID)
      ? crypto.randomUUID()
      : Math.random().toString(36).substring(2, 15);
    const novoConcurso = { ...concurso, id, status: 'planejado' };
    adicionarConcurso(novoConcurso);
    setTimeout(() => {
      router.push(`/concursos/${id}`);
    }, 500);
  };

  return (
    <div className="space-y-6"> {/* Adicionado space-y-6 para espaçamento */}
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold flex items-center gap-2">
          <Award className="text-indigo-600" size={24} />
          Concursos
        </h1>
        {/* Botão Adicionar Manual */}
        <div className="flex justify-end mb-4 gap-2">
          <Button onClick={() => setShowAddModal(true)} size="sm">
            <Plus size={16} className="mr-2" />
            Adicionar Manualmente
          </Button>
          <Button onClick={() => setShowImportModal(true)} size="sm" variant="outline">
            <Upload size={16} className="mr-2" />
            Importar JSON do Edital
          </Button>
        </div>
      </div>

      {/* Lista de Concursos */}
      {concursos.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {concursos.map((concurso) => (
            <Card key={concurso.id} className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h3 className="font-bold text-lg">{concurso.titulo}</h3>
                  <p className="text-gray-500 text-sm">{concurso.organizadora}</p>
                </div>
                <div className={`py-1 px-3 rounded-full text-sm font-medium ${statusColors[concurso.status]}`}>
                  {statusLabel[concurso.status]}
                </div>
              </div>

              <div className="mt-4 flex items-center gap-3">
                <Calendar size={16} className="text-gray-500" />
                <span className="text-sm">
                  {format(new Date(concurso.dataProva), 'dd/MM/yyyy', { locale: ptBR })}
                </span>
              </div>

              <div className="mt-3">
                <div className="flex justify-between items-center text-sm mb-1">
                  <span>Progresso de estudos</span>
                  <span className="font-medium">
                    {Math.round(
                      (concurso.conteudoProgramatico?.reduce((acc, curr) => acc + curr.progresso, 0) || 0) / 
                      (concurso.conteudoProgramatico?.length || 1)
                    )}%
                  </span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className="bg-indigo-600 h-2 rounded-full" 
                    style={{ 
                      width: `${Math.round(
                        (concurso.conteudoProgramatico?.reduce((acc, curr) => acc + curr.progresso, 0) || 0) / 
                        (concurso.conteudoProgramatico?.length || 1)
                      )}%` 
                    }}
                  ></div>
                </div>
              </div>

              <div className="mt-4 flex justify-end">
                <Link href={`/concursos/${concurso.id}`} passHref>
                  <Button variant="link" className="text-indigo-600">
                    Ver detalhes
                  </Button>
                </Link>
              </div>
            </Card>
          ))}
        </div>
      ) : (
        <div className="text-center py-12 border rounded-lg bg-gray-50">
          <p className="text-gray-500 mb-4">Você ainda não cadastrou nenhum concurso</p>
          <p className="text-gray-500 mb-4">Você ainda não cadastrou nenhum concurso manualmente.</p>
        </div>
      )}

      {/* Modal de Cadastro Manual (controlado pelo estado showAddModal) */}
      <ConcursoForm
        isOpen={showAddModal}
        onClose={() => setShowAddModal(false)}
      />
        {/* Modal de importação de concurso via JSON */}
        <ImportarConcursoJsonModal
          isOpen={showImportModal}
          onClose={() => setShowImportModal(false)}
          onImport={handleImportConcurso}
        />
    </div>
  );
}
</file>

<file path="app/estudos/materiais/page.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { Button } from '@/app/components/ui/Button';
import { Card } from '@/app/components/ui/Card';
import { Modal } from '@/app/components/ui/Modal';
import VisualizadorMarkdown from '@/app/components/estudos/VisualizadorMarkdown';
import { VisualizadorChecklist } from '@/app/components/estudos/VisualizadorChecklist';
import { Input } from '@/app/components/ui/Input';

const materialTypes = [
  'Resumos',
  'Flashcards',
  'Simulados',
  'Tarefas',
  'Estratégias de Foco',
  'Agendamento de Pausas',
  'Mapas Mentais',
  'Outlines de Infográficos',
  'Checklists',
  'Guias de Estudo',
];

export default function MateriaisPage() {
  const [isFileListModalOpen, setIsFileListModalOpen] = useState(false);
  const [filesForSelection, setFilesForSelection] = useState<{ id: string; name: string }[]>([]);
  const [selectedMaterialType, setSelectedMaterialType] = useState<string | null>(null);
  const [isVisualizationModalOpen, setIsVisualizationModalOpen] = useState(false);
  const [selectedFileId, setSelectedFileId] = useState<string | null>(null);
  const [modalTitle, setModalTitle] = useState('');
  const handleSelectMaterialType = async (type: string) => {
    setSelectedMaterialType(type);
    setModalTitle(type); // Use type as initial modal title

    const subfolderId = prompt(`Por favor, insira o ID da pasta "${type}" no Google Drive:`);
    if (!subfolderId) {
      alert('ID da pasta não fornecido.');
      return;
    }

    try {
      const response = await fetch(`/api/drive/listar-materiais?folderId=${encodeURIComponent(subfolderId)}`);
      const data = await response.json();

      if (response.ok) {
        const filteredFiles = data.files.filter((file: { id: string; name: string }) =>
          file.name.toLowerCase().includes(type.toLowerCase())
        );

        if (filteredFiles && filteredFiles.length > 1) {
          // Assuming data.files is an array of { id: string, name: string }
          setFilesForSelection(filteredFiles);
          setIsFileListModalOpen(true);
        } else if (filteredFiles && filteredFiles.length === 1) {
          // Directly open visualization if only one file
          const file = filteredFiles[0];
          setSelectedFileId(file.id);
          setModalTitle(`${type}: ${file.name}`);
          setIsVisualizationModalOpen(true);
          setIsFileListModalOpen(false); // Close file list modal if it was open
        } else {
          // No files found
          alert(`Nenhum material encontrado para ${type}.`);
          setFilesForSelection([]);
          setSelectedFileId(null);
          setIsFileListModalOpen(false);
          setIsVisualizationModalOpen(false);
        }
      } else {
        // Handle API errors
        alert(`Erro ao listar materiais: ${data.error}`);
        setFilesForSelection([]);
        setSelectedFileId(null);
        setIsFileListModalOpen(false);
        setIsVisualizationModalOpen(false);
      }
    } catch (error) {
      console.error('Erro ao buscar lista de materiais:', error);
      alert('Erro ao buscar lista de materiais.');
      setFilesForSelection([]);
      setSelectedFileId(null);
      setIsFileListModalOpen(false);
      setIsVisualizationModalOpen(false);
    }
  };

  const handleFileSelection = (file: { id: string; name: string }) => {
    if (selectedMaterialType) {
      setSelectedFileId(file.id);
      setModalTitle(`${selectedMaterialType}: ${file.name}`);
      setIsFileListModalOpen(false);
      setIsVisualizationModalOpen(true);
    }
  };

  const handleCloseVisualizationModal = () => {
    setIsVisualizationModalOpen(false);
    setSelectedFileId(null);
    setSelectedMaterialType(null);
    setModalTitle('');
  };

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Materiais de Estudo</h1>

      <Card title="Tipos de Materiais">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {materialTypes.map((type) => (
            <Button key={type} onClick={() => handleSelectMaterialType(type)}>
              {type}
            </Button>
          ))}
        </div>
      </Card>

      {/* Modal para seleção de arquivos */}
      <Modal
        isOpen={isFileListModalOpen}
        onClose={() => setIsFileListModalOpen(false)}
        title={`Selecionar Arquivo de ${selectedMaterialType}`}
      >
        <div className="flex flex-col gap-2">
          {filesForSelection.map((file) => (
            <Button key={file.id} onClick={() => handleFileSelection(file)}>
              {file.name}
            </Button>
          ))}
        </div>
      </Modal>

      {/* Modal para visualização do material */}
      <Modal
        isOpen={isVisualizationModalOpen}
        onClose={handleCloseVisualizationModal}
        title={modalTitle}
        size="xl" // Adjust size as needed
      >
        {selectedFileId && selectedMaterialType && (
          selectedMaterialType === 'Checklists' ? (
            <VisualizadorChecklist isOpen={isVisualizationModalOpen} fileId={selectedFileId} title={modalTitle} onClose={handleCloseVisualizationModal} />
          ) : (
            <VisualizadorMarkdown isOpen={isVisualizationModalOpen} fileId={selectedFileId} title={modalTitle} onClose={handleCloseVisualizationModal} />
          )
        )}
      </Modal>
    </div>
  );
}
</file>

<file path="app/estudos/simulado/page.tsx">
'use client'; // Necessário para usar hooks como useState e useEffect, e o store Zustand

import React, { useState } from 'react'; // Adicionar useState
import { useSimuladoStore } from '@/app/stores/simuladoStore';
// Padronizando a forma de importação para todos os componentes
import SimuladoLoader from '@/app/components/estudos/simulado/SimuladoLoader';
import SimuladoReview from '@/app/components/estudos/simulado/SimuladoReview';
import SimuladoResults from '@/app/components/estudos/simulado/SimuladoResults';
import HistoricoModal from '@/app/components/estudos/simulado/HistoricoModal'; // <-- Corrigir importação sem extensão
import { Container } from '@/app/components/ui/Container'; // Usando um container genérico existente
import { Button } from '@/app/components/ui/Button'; // Usando botão existente
import { History } from 'lucide-react'; // <-- Importar ícone de histórico

const SimuladoPage: React.FC = () => {
  const { status, resetSimulado } = useSimuladoStore();
  const [isHistoricoOpen, setIsHistoricoOpen] = useState(false); // <-- Estado para controlar o modal

  const renderContent = () => {
    switch (status) {
      case 'reviewing':
        return <SimuladoReview />;
      case 'results':
        return <SimuladoResults />;
      case 'loading': // Poderia ter um estado de loading visual
        return <div>Carregando simulado...</div>;
      case 'idle':
      default:
        return <SimuladoLoader />;
    }
  };

  return (
    <> {/* Usar Fragment para envolver Container e Modal */}
      <Container>
        <div className="flex justify-between items-center mb-6 gap-2"> {/* Adicionado gap */}
          <h1 className="text-2xl font-bold">Conferência de Simulado</h1>
          <div className="flex gap-2"> {/* Agrupar botões */}
            <Button onClick={() => setIsHistoricoOpen(true)} variant="outline" size="sm">
              <History className="mr-1 h-4 w-4" /> Histórico
            </Button>
            {status !== 'idle' && (
              <Button onClick={resetSimulado} variant="outline" size="sm">
                Carregar Novo
              </Button>
            )}
          </div>
        </div>
        {renderContent()}
      </Container>

      {/* Modal do Histórico */}
      <HistoricoModal
        isOpen={isHistoricoOpen}
        onClose={() => setIsHistoricoOpen(false)}
      />
    </>
  );
};

export default SimuladoPage;
</file>

<file path="app/estudos/simulado-personalizado/page.tsx">
'use client';

import React, { useEffect } from 'react';
import { useSimuladoStore } from '@/app/stores/simuladoStore';
import SimuladoReview from '@/app/components/estudos/simulado/SimuladoReview';

const SimuladoPersonalizadoPage: React.FC = () => {
  const { loadSimulado, simuladoData } = useSimuladoStore();

  useEffect(() => {
    // Carrega as questões selecionadas do localStorage
    const raw = localStorage.getItem('simulado_personalizado_questoes');
    if (raw) {
      try {
        const questoes = JSON.parse(raw);
        if (Array.isArray(questoes) && questoes.length > 0) {
          // Monta estrutura mínima de simulado
          loadSimulado({
            metadata: {
              titulo: 'Simulado Personalizado',
              totalQuestoes: questoes.length,
              dataGeracao: new Date().toISOString(),
              concurso: questoes[0]?.concursoId || '',
            },
            questoes: questoes.map((q: any, idx: number) => {
              // Adapta para o formato esperado pelo SimuladoReview
              const alternativasObj: Record<string, string> = {};
              q.alternativas.forEach((alt: any, i: number) => {
                const key = String.fromCharCode(97 + i); // a, b, c, d...
                alternativasObj[key] = alt.texto;
              });
              let gabaritoKey = '';
              q.alternativas.forEach((alt: any, i: number) => {
                if (alt.id === q.respostaCorreta) {
                  gabaritoKey = String.fromCharCode(97 + i);
                }
              });
              return {
                id: idx + 1,
                enunciado: q.enunciado,
                alternativas: alternativasObj,
                gabarito: gabaritoKey,
                assunto: q.topico || q.disciplina,
                dificuldade: q.nivelDificuldade ? (['facil', 'medio', 'dificil'].indexOf(q.nivelDificuldade) + 1) : undefined,
                explicacao: q.justificativa,
              };
            }),
          });
        }
      } catch (err) {
        // erro de parse, não faz nada
      }
    }
  }, [loadSimulado]);

  if (!simuladoData) {
    return <div className="p-8 text-center">Carregando simulado personalizado...</div>;
  }

  return (
    <div className="p-4">
      <SimuladoReview />
    </div>
  );
};

export default SimuladoPersonalizadoPage;
</file>

<file path="app/estudos/page.tsx">
'use client';
import { useState } from 'react'; // Importar useState
import Link from 'next/link'; // Importar Link para navegação
import { Card } from '@/app/components/ui/Card';
import { Button } from '@/app/components/ui/Button'; // Importar Button
import { Modal } from '@/app/components/ui/Modal'; // Importar Modal
import { TemporizadorPomodoro } from '@/app/components/estudos/TemporizadorPomodoro';
import { RegistroEstudos } from '@/app/components/estudos/RegistroEstudos';
import VisualizadorMarkdown from '@/app/components/estudos/VisualizadorMarkdown'; // Importar VisualizadorMarkdown
import { VisualizadorChecklist } from '@/app/components/estudos/VisualizadorChecklist'; // Importar VisualizadorChecklist
import { useConcursosStore } from '@/app/stores/concursosStore';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';

export default function EstudosPage() {
  const { concursos } = useConcursosStore();
  const [selectedFileId, setSelectedFileId] = useState<string | null>(null);
  const [modalTitle, setModalTitle] = useState('');
  const [isVisualizationModalOpen, setIsVisualizationModalOpen] = useState(false); // Novo estado para o modal de visualização

  // Novos estados para seleção de arquivos
  const [isFileListModalOpen, setIsFileListModalOpen] = useState(false);
  const [filesForSelection, setFilesForSelection] = useState<{ id: string; name: string }[]>([]);
  const [selectedMaterialType, setSelectedMaterialType] = useState<string | null>(null);

  // Encontrar próximo concurso
  const proximoConcurso = concursos
    .filter(c => c.status !== 'realizado' && new Date(c.dataProva) > new Date())
    .sort((a, b) => new Date(a.dataProva).getTime() - new Date(b.dataProva).getTime())[0];

  // Função para selecionar o tipo de material e buscar arquivos
  const handleSelectMaterialType = async (materialNome: string) => {
    setSelectedMaterialType(materialNome);
    setModalTitle(materialNome); // Define o título do modal de visualização antecipadamente

    try {
      const response = await fetch(`/api/drive/listar-materiais?tipo=${encodeURIComponent(materialNome.toLowerCase())}`);
      const data = await response.json();

      if (response.ok && data.files && Array.isArray(data.files)) {
        if (data.files.length > 1) {
          // Múltiplos arquivos, exibir lista para seleção
          setFilesForSelection(data.files);
          setIsFileListModalOpen(true);
        } else if (data.files.length === 1) {
          // Apenas um arquivo, abrir diretamente
          const file = data.files[0];
          setSelectedFileId(file.id);
          setModalTitle(`${materialNome}: ${file.name}`);
          setIsVisualizationModalOpen(true); // Abre o modal de visualização

        } else {
          // Nenhum arquivo encontrado
          alert(`Nenhum arquivo encontrado para o material: ${materialNome}`);
          setSelectedFileId(null); // Garante que nenhum arquivo anterior seja exibido
        }
      } else {
        // Erro na resposta da API
        alert(`Erro ao listar arquivos para o material: ${materialNome}`);
        console.error('Erro na resposta da API:', data);
        setSelectedFileId(null);
      }
    } catch (error) {
      console.error('Erro ao buscar lista de arquivos:', error);
      alert(`Erro ao buscar lista de arquivos para o material: ${materialNome}`);
      setSelectedFileId(null);
    }
  };

  // Função para lidar com a seleção de um arquivo na lista
  const handleFileSelection = (file: { id: string; name: string }) => {
    if (selectedMaterialType) {
      setSelectedFileId(file.id);
      setModalTitle(`${selectedMaterialType}: ${file.name}`);
      setIsFileListModalOpen(false); // Fecha o modal de seleção de arquivos

      setIsVisualizationModalOpen(true); // Abre o modal de visualização
    }
  };

  // Função para fechar o modal de visualização
  const handleCloseVisualizationModal = () => {
    setIsVisualizationModalOpen(false);
    setSelectedFileId(null);
    setModalTitle('');
    setSelectedMaterialType(null); // Resetar o tipo selecionado ao fechar
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center"> {/* Container para título e botão */}
        <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Estudos</h1>
        <div className="flex gap-2">
          <Link href="/estudos/simulado" passHref>
            <Button variant="outline">Conferir Simulado</Button>
          </Link>
          <Link href="/concursos" passHref>
            <Button variant="default">Ver Todos Concursos</Button>
          </Link>
          <Link href="/estudos/materiais" passHref>
            <Button variant="default">Acesso a matérias de estudos</Button>
          </Link>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Temporizador Pomodoro Adaptado */}
        <Card title="Temporizador Pomodoro">
          <TemporizadorPomodoro />
        </Card>

        {/* Registro de Sessões de Estudo */}
        <Card title="Registro de Estudos">
          <RegistroEstudos />
        </Card>

        {/* Próximo Concurso */}
        <Card title="Próximo Concurso">
          {proximoConcurso ? (
            <div className="space-y-4">
              <div>
                <h3 className="font-semibold text-lg">{proximoConcurso.titulo}</h3>
                <p className="text-sm text-gray-500">{proximoConcurso.organizadora}</p>
              </div>

              <div className="flex items-center gap-2 text-sm">
                <span className="font-medium">Data da Prova:</span>
                <span>{format(new Date(proximoConcurso.dataProva), 'dd/MM/yyyy', { locale: ptBR })}</span>
              </div>

              <div>
                <div className="flex justify-between items-center text-sm mb-1">
                  <span>Progresso de estudos</span>
                  <span className="font-medium">
                    {Math.round(
                      (proximoConcurso.conteudoProgramatico?.reduce((acc, curr) => acc + curr.progresso, 0) || 0) /
                      (proximoConcurso.conteudoProgramatico?.length || 1)
                    )}%
                  </span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div
                    className="bg-indigo-600 h-2 rounded-full"
                    style={{
                      width: `${Math.round(
                        (proximoConcurso.conteudoProgramatico?.reduce((acc, curr) => acc + curr.progresso, 0) || 0) /
                        (proximoConcurso.conteudoProgramatico?.length || 1)
                      )}%`
                    }}
                  ></div>
                </div>
              </div>

              <div className="flex justify-end">
                <Link href={`/concursos/${proximoConcurso.id}`} passHref>
                  <Button variant="link" className="text-indigo-600">
                    Ver detalhes
                  </Button>
                </Link>
              </div>
            </div>
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-500 mb-4">Nenhum concurso planejado</p>
              <Link href="/concursos" passHref>
                <Button variant="outline">Adicionar Concurso</Button>
              </Link>
            </div>
          )}
        </Card>
        {/* Materiais de Estudo */}
        <Card title="Materiais de Estudo" className="md:col-span-2"> {/* Ocupa a largura total em telas médias */}
          <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3 p-4"> {/* Adicionado padding */}
            <Button variant="outline" onClick={() => handleSelectMaterialType('Resumos')}>Resumos</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Flashcards')}>Flashcards</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Simulados')}>Simulados</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Tarefas')}>Tarefas</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Estratégias de Foco')}>Estratégias de Foco</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Agendamento de Pausas')}>Agendamento de Pausas</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Mapas Mentais')}>Mapas Mentais</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Outlines de Infográficos')}>Outlines de Infográficos</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Checklists')}>Checklists</Button>
            <Button variant="outline" onClick={() => handleSelectMaterialType('Guias de Estudo')}>Guias de Estudo</Button>
          </div>
        </Card>
      </div>

      {/* Modal para seleção de arquivos */}
      <Modal
        isOpen={isFileListModalOpen}
        onClose={() => setIsFileListModalOpen(false)}
        title={`Selecionar Arquivo para ${selectedMaterialType}`}
      >
        <div className="space-y-2">
          {filesForSelection.map((file) => (
            <Button
              key={file.id}
              variant="outline"
              className="w-full justify-start"
              onClick={() => handleFileSelection(file)}
            >
              {file.name}
            </Button>
          ))}
        </div>
      </Modal>

      {/* Renderiza o Modal VisualizadorMarkdown */}
      {selectedMaterialType !== 'Checklists' && (
        <VisualizadorMarkdown
          isOpen={isVisualizationModalOpen}
          onClose={handleCloseVisualizationModal}
          fileId={selectedFileId}
          title={modalTitle}
        />
      )}

      {/* Renderiza o Modal VisualizadorChecklist */}
      {selectedMaterialType === 'Checklists' && (
        <VisualizadorChecklist
          isOpen={isVisualizationModalOpen}
          onClose={handleCloseVisualizationModal}
          fileId={selectedFileId}
          title={modalTitle}
        />
      )}
    </div>
  )
}
</file>

<file path="app/financas/page.tsx">
import dynamic from 'next/dynamic'
import { Card } from '@/app/components/ui/Card'
// import { RastreadorGastos } from '@/app/components/financas/RastreadorGastos' // Importação estática removida
import { EnvelopesVirtuais } from '@/app/components/financas/EnvelopesVirtuais'
import { CalendarioPagamentos } from '@/app/components/financas/CalendarioPagamentos'
import { AdicionarDespesa } from '@/app/components/financas/AdicionarDespesa'

// Importação dinâmica para o RastreadorGastos (ajustada para default export)
const RastreadorGastos = dynamic(
  () => import('@/app/components/financas/RastreadorGastos'), // Importa o módulo
  // O .then() não é mais necessário aqui, pois dynamic() lida com default export por padrão
  { 
    ssr: false, // Desabilita SSR pois recharts depende de APIs do browser
    loading: () => <p className="text-center text-gray-500 dark:text-gray-400">Carregando gráfico...</p> 
  }
)

export default function FinancasPage() {
  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Finanças</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Rastreador de Gastos */}
        <Card title="Rastreador de Gastos">
          <RastreadorGastos />
        </Card>
        
        {/* Envelopes Virtuais */}
        <Card title="Envelopes Virtuais">
          <EnvelopesVirtuais />
        </Card>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Calendário de Pagamentos */}
        <Card title="Calendário de Pagamentos">
          <CalendarioPagamentos />
        </Card>
        
        {/* Adicionar Despesa Rápida */}
        <Card title="Adicionar Despesa">
          <AdicionarDespesa />
        </Card>
      </div>
    </div>
  )
}
</file>

<file path="app/hiperfocos/page.tsx">
'use client'

import { useState } from 'react'
import { ConversorInteresses } from '../components/hiperfocos/ConversorInteresses'
import { SistemaAlternancia } from '../components/hiperfocos/SistemaAlternancia'
import { VisualizadorProjetos } from '../components/hiperfocos/VisualizadorProjetos'
import { TemporizadorFoco } from '../components/hiperfocos/TemporizadorFoco'
import { useHiperfocosStore } from '../stores/hiperfocosStore'

export default function HiperfocosPage() {
  // Separamos a interface em guias para melhor organização
  const [tabAtiva, setTabAtiva] = useState<'conversor' | 'alternancia' | 'visualizador' | 'temporizador'>('conversor')
  const { hiperfocos } = useHiperfocosStore()

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6 text-gray-800 dark:text-white flex items-center">
        <span role="img" aria-label="Foguete" className="mr-2">🚀</span>
        Hiperfocos
      </h1>
      
      <p className="text-gray-600 dark:text-gray-300 mb-8">
        Transforme seus interesses intensos em projetos estruturados e gerencie suas transições de foco.
      </p>
      
      {/* Tabs de navegação */}
      <div className="flex flex-wrap gap-2 mb-6 border-b border-gray-200 dark:border-gray-700">
        <button
          onClick={() => setTabAtiva('conversor')}
          className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
            tabAtiva === 'conversor'
              ? 'bg-hiperfocos-light text-hiperfocos-primary border-b-2 border-hiperfocos-primary'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white'
          }`}
          aria-current={tabAtiva === 'conversor' ? 'page' : undefined}
        >
          Conversor de Interesses
        </button>
        
        <button
          onClick={() => setTabAtiva('alternancia')}
          className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
            tabAtiva === 'alternancia'
              ? 'bg-hiperfocos-light text-hiperfocos-primary border-b-2 border-hiperfocos-primary'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white'
          }`}
          aria-current={tabAtiva === 'alternancia' ? 'page' : undefined}
        >
          Sistema de Alternância
        </button>
        
        <button
          onClick={() => setTabAtiva('visualizador')}
          className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
            tabAtiva === 'visualizador'
              ? 'bg-hiperfocos-light text-hiperfocos-primary border-b-2 border-hiperfocos-primary'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white'
          }`}
          aria-current={tabAtiva === 'visualizador' ? 'page' : undefined}
        >
          Estrutura de Projetos
        </button>
        
        <button
          onClick={() => setTabAtiva('temporizador')}
          className={`px-4 py-2 rounded-t-lg font-medium transition-colors ${
            tabAtiva === 'temporizador'
              ? 'bg-hiperfocos-light text-hiperfocos-primary border-b-2 border-hiperfocos-primary'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white'
          }`}
          aria-current={tabAtiva === 'temporizador' ? 'page' : undefined}
        >
          Temporizador
        </button>
      </div>
      
      {/* Conteúdo da tab ativa */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
        {tabAtiva === 'conversor' && <ConversorInteresses />}
        {tabAtiva === 'alternancia' && <SistemaAlternancia />}
        {tabAtiva === 'visualizador' && <VisualizadorProjetos />}
        {tabAtiva === 'temporizador' && <TemporizadorFoco />}
      </div>
      
      {/* Card de resumo - visível em todas as abas */}
      {hiperfocos.length > 0 && (
        <div className="mt-8 bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
          <h2 className="text-lg font-medium mb-2 text-gray-800 dark:text-white">Resumo dos Hiperfocos</h2>
          <div className="space-y-2">
            {hiperfocos.map((hiperfoco) => (
              <div 
                key={hiperfoco.id} 
                className="px-3 py-2 rounded-md flex justify-between"
                style={{ backgroundColor: `${hiperfoco.cor}20` }}
              >
                <span className="font-medium" style={{ color: hiperfoco.cor }}>
                  {hiperfoco.titulo}
                </span>
                <span className="text-gray-600 dark:text-gray-300">
                  {hiperfoco.tarefas.filter(t => t.concluida).length}/{hiperfoco.tarefas.length} tarefas
                </span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/hooks/useDashboard.ts">
'use client'

import { useEffect, useState } from 'react'
import { usePainelDiaStore, BlocoTempo } from '@/app/stores/painelDiaStore'
import { usePrioridadesStore, Prioridade } from '@/app/stores/prioridadesStore'
import { usePerfilStore } from '@/app/stores/perfilStore'

export type DashboardData = {
  blocosDia: BlocoTempo[]
  prioridadesDia: Prioridade[] 
  proximosCompromissos: BlocoTempo[]
  prioridadesPendentes: number
  prioridadesConcluidas: number
  metasPausas: number
  mostrarPausas: boolean
  metasPrioridades: number
  nomeUsuario: string
  preferenciasVisuais: {
    altoContraste: boolean
    reducaoEstimulos: boolean
    textoGrande: boolean
  }
  isLoading: boolean
}

// Valores padrão para garantir tipo seguro
const defaultDashboardData: DashboardData = {
  blocosDia: [],
  prioridadesDia: [],
  proximosCompromissos: [],
  prioridadesPendentes: 0,
  prioridadesConcluidas: 0,
  metasPausas: 4,
  mostrarPausas: true,
  metasPrioridades: 3,
  nomeUsuario: 'Usuário',
  preferenciasVisuais: {
    altoContraste: false,
    reducaoEstimulos: false,
    textoGrande: false
  },
  isLoading: true
}

export const useDashboard = () => {
  const [data, setData] = useState<DashboardData>(defaultDashboardData)
  const [isLoading, setIsLoading] = useState(true)
  
  // Stores do Zustand
  const { blocos } = usePainelDiaStore()
  const { prioridades, getHistoricoPorData } = usePrioridadesStore()
  const { 
    nome, 
    metasDiarias, 
    pausasAtivas, 
    preferenciasVisuais 
  } = usePerfilStore()
  
  useEffect(() => {
    const carregarDados = async () => {
      try {
        // Obtenha a data atual em formato ISO (YYYY-MM-DD)
        const dataAtual = new Date().toISOString().split('T')[0]
        
        // Obtenha prioridades do dia atual
        const prioridadesDoDia = getHistoricoPorData(dataAtual)
        
        // Calcule próximos compromissos (próximos 3 blocos a partir da hora atual)
        const agora = new Date()
        const horaAtual = `${agora.getHours().toString().padStart(2, '0')}:${agora.getMinutes().toString().padStart(2, '0')}`
        
        // Ordenar blocos por hora e filtrar os que ainda estão por vir
        const blocosFuturos = [...blocos]
          .sort((a, b) => {
            const horaA = a.hora.split(':').map(Number)
            const horaB = b.hora.split(':').map(Number)
            
            if (horaA[0] !== horaB[0]) {
              return horaA[0] - horaB[0]
            }
            return horaA[1] - horaB[1]
          })
          .filter(bloco => bloco.hora >= horaAtual)
          .slice(0, 3)
        
        // Calcule estatísticas de prioridades
        const prioridadesPendentes = prioridadesDoDia.filter(p => !p.concluida).length
        const prioridadesConcluidas = prioridadesDoDia.filter(p => p.concluida).length
        
        // Atualizar dados do dashboard
        setData({
          blocosDia: blocos || [],
          prioridadesDia: prioridadesDoDia || [],
          proximosCompromissos: blocosFuturos,
          prioridadesPendentes,
          prioridadesConcluidas,
          metasPausas: metasDiarias?.pausasProgramadas || 4,
          mostrarPausas: pausasAtivas,
          metasPrioridades: metasDiarias?.tarefasPrioritarias || 3,
          nomeUsuario: nome || 'Usuário',
          preferenciasVisuais: preferenciasVisuais || {
            altoContraste: false,
            reducaoEstimulos: false,
            textoGrande: false
          },
          isLoading: false
        })
      } catch (error) {
        console.error("Erro ao carregar dados do dashboard:", error)
        // Em caso de erro, definir valores padrão, mas manter isLoading como false
        setData({
          ...defaultDashboardData,
          isLoading: false
        })
      } finally {
        setIsLoading(false)
      }
    }
    
    carregarDados()
  }, [blocos, prioridades, nome, metasDiarias, pausasAtivas, preferenciasVisuais, getHistoricoPorData])
  
  return { ...data, isLoading }
}
</file>

<file path="app/lazer/page.tsx">
import { Card } from '@/app/components/ui/Card'
import { AtividadesLazer } from '@/app/components/lazer/AtividadesLazer'
import { SugestoesDescanso } from '@/app/components/lazer/SugestoesDescanso'
import { TemporizadorLazer } from '@/app/components/lazer/TemporizadorLazer'

export default function LazerPage() {
  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-4">Lazer</h1>
      
      <div className="grid grid-cols-1 gap-6">
        {/* Temporizador de Lazer */}
        <Card title="Temporizador de Lazer">
          <TemporizadorLazer />
        </Card>
        
        {/* Atividades de Lazer */}
        <Card title="Atividades de Lazer">
          <AtividadesLazer />
        </Card>
        
        {/* Sugestões de Descanso */}
        <Card title="Sugestões de Descanso">
          <SugestoesDescanso />
        </Card>
      </div>
    </div>
  )
}
</file>

<file path="app/lib/dataService.ts">
/**
 * Serviço para exportação e importação de dados do StayFocus
 * Permite que usuários façam backup de seus dados e os restaurem quando necessário
 */

// Importações das stores
import { useFinancasStore } from '../stores/financasStore';
import { useAlimentacaoStore } from '../stores/alimentacaoStore';
import { useAutoconhecimentoStore } from '../stores/autoconhecimentoStore';
import { useHiperfocosStore } from '../stores/hiperfocosStore';
import { usePainelDiaStore } from '../stores/painelDiaStore';
import { usePerfilStore } from '../stores/perfilStore';
import { usePomodoroStore } from '../stores/pomodoroStore';
import { usePrioridadesStore } from '../stores/prioridadesStore';
import { useRegistroEstudosStore } from '../stores/registroEstudosStore';
import { useSonoStore } from '../stores/sonoStore';
import { useAtividadesStore } from '../stores/atividadesStore';
import { useHistoricoSimuladosStore } from '../stores/historicoSimuladosStore'; // <-- Importar novo store
import { useAppStore } from '../store'; // Store global que contém dados de saúde e lazer

/**
 * Coleta todos os dados das stores para exportação.
 * @returns O objeto de dados pronto para ser serializado ou null em caso de erro.
 */
const coletarDadosParaExportar = (): object | null => {
  try {
    const financas = useFinancasStore.getState();
    const alimentacao = useAlimentacaoStore.getState();
    const autoconhecimento = useAutoconhecimentoStore.getState();
    const hiperfocos = useHiperfocosStore.getState();
    const painelDia = usePainelDiaStore.getState();
    const perfil = usePerfilStore.getState();
    const pomodoro = usePomodoroStore.getState();
    const prioridades = usePrioridadesStore.getState();
    const registroEstudos = useRegistroEstudosStore.getState();
    const sono = useSonoStore.getState();
    const atividades = useAtividadesStore.getState();
    const historicoSimulados = useHistoricoSimuladosStore.getState(); // <-- Coletar estado do histórico
    const appGlobal = useAppStore.getState();

    return {
      versao: '1.1', // <-- Incrementar versão para indicar mudança na estrutura de dados
      timestamp: new Date().toISOString(),
      dados: { // <-- Bloco de dados correto começa aqui
        financas: limparFuncoesDoObjeto(financas),
        alimentacao: limparFuncoesDoObjeto(alimentacao),
        autoconhecimento: limparFuncoesDoObjeto(autoconhecimento),
        hiperfocos: limparFuncoesDoObjeto(hiperfocos),
        painelDia: limparFuncoesDoObjeto(painelDia),
        perfil: limparFuncoesDoObjeto(perfil),
        pomodoro: limparFuncoesDoObjeto(pomodoro),
        prioridades: limparFuncoesDoObjeto(prioridades),
        registroEstudos: limparFuncoesDoObjeto(registroEstudos),
        sono: limparFuncoesDoObjeto(sono),
        atividades: limparFuncoesDoObjeto(atividades),
        historicoSimulados: limparFuncoesDoObjeto(historicoSimulados), // <-- Incluir histórico nos dados (linha única)
        appGlobal: limparFuncoesDoObjeto(appGlobal),
      } // <-- Fechamento correto do bloco 'dados'
    };
  } catch (error) {
    console.error('Erro ao coletar dados para exportação:', error);
    return null;
  }
};

/**
 * Exporta os dados e dispara o download do arquivo JSON.
 * Usado para exportação local.
 * @returns Objeto com informação de sucesso ou erro.
 */
export const exportarDadosParaArquivo = (): { sucesso: boolean; mensagem?: string; erro?: string } => {
  const dadosExportados = coletarDadosParaExportar();
  if (!dadosExportados) {
    return { sucesso: false, erro: 'Falha ao coletar dados para exportação.' };
  }

  try {
    triggerJsonDownload(dadosExportados, 'stayfocus_backup');
    return { sucesso: true, mensagem: 'Download do backup iniciado.' };
  } catch (error: any) {
    console.error('Erro ao disparar download do JSON:', error);
    return { sucesso: false, erro: `Erro ao criar arquivo de backup: ${error.message}` };
  }
};

/**
 * Retorna o objeto de dados para ser enviado para APIs (ex: Google Drive).
 * @returns O objeto de dados ou null em caso de erro.
 */
export const obterDadosParaExportar = (): object | null => {
  return coletarDadosParaExportar();
};


/**
 * Helper para disparar o download de um objeto como arquivo JSON.
 * @param dataObject O objeto a ser baixado.
 * @param baseFilename O nome base para o arquivo (timestamp será adicionado).
 */
export const triggerJsonDownload = (dataObject: any, baseFilename: string) => {
  const jsonString = JSON.stringify(dataObject, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const timestamp = dataObject.timestamp || new Date().toISOString();
  const dataFormatada = timestamp.split('T')[0];
  const link = document.createElement('a');
  link.href = url;
  link.download = `${baseFilename}_${dataFormatada}.json`;
  document.body.appendChild(link); // Necessário para Firefox
  link.click();
  document.body.removeChild(link); // Limpar
  URL.revokeObjectURL(url);
};


/**
 * Limpa as funções de um objeto para exportação JSON.
 * @param obj Objeto a ser limpo.
 * @returns Objeto sem funções
 */
const limparFuncoesDoObjeto = (obj: Record<string, any>): Record<string, any> => {
  // Criar cópia do objeto
  const resultado = {...obj};
  
  // Remover todas as funções pois não podem ser serializadas em JSON
  Object.keys(resultado).forEach(key => {
    if (typeof resultado[key] === 'function') {
      delete resultado[key];
    }
  });
  
  return resultado;
};

/**
 * Valida a estrutura básica de dados importados.
 * @param dados Dados a serem validados.
 * @returns Objeto com informação de validade e possível erro.
 */
const validarDadosImportados = (dados: any): { valido: boolean; erro?: string; timestamp?: string } => {
  if (!dados || typeof dados !== 'object') {
    return { valido: false, erro: 'Dados inválidos ou não são um objeto.' };
  }
  if (!dados.versao || !dados.timestamp || !dados.dados) {
    return { valido: false, erro: 'Formato de arquivo inválido: Faltam propriedades essenciais (versao, timestamp, dados).' };
  } // <-- Fechar o primeiro IF aqui

  // Validar a versão
  if (dados.versao !== '1.0' && dados.versao !== '1.1') {
    return { valido: false, erro: `Versão incompatível: ${dados.versao}. Esperada: 1.0 ou 1.1` };
  }

  // Validar a seção 'dados'
  if (typeof dados.dados !== 'object' || Object.keys(dados.dados).length === 0) {
    return { valido: false, erro: 'Seção "dados" está vazia ou inválida.' };
  }

  return { valido: true, timestamp: dados.timestamp };
};

/**
 * Aplica os dados importados (já validados) às stores Zustand.
 * @param dadosImportados Objeto contendo os dados dos módulos.
 */
const _applyImportedData = (dadosImportados: any) => {
  // Helper para aplicar estado a uma store
  const applyState = (storeSetter: (partialState: any) => void, data: any) => {
    if (data && typeof data === 'object') {
      // Limpar funções novamente por segurança, caso existam no JSON por algum motivo
      const cleanedData = limparFuncoesDoObjeto(data);
      // Add explicit 'any' type for state parameter
      storeSetter((state: any) => ({ 
        ...state,
        ...cleanedData
      }));
    }
  };

  // Aplicar dados a cada store se existirem no objeto importado
  applyState(useFinancasStore.setState, dadosImportados.financas);
  applyState(useAlimentacaoStore.setState, dadosImportados.alimentacao);
  applyState(useAutoconhecimentoStore.setState, dadosImportados.autoconhecimento);
  applyState(useHiperfocosStore.setState, dadosImportados.hiperfocos);
  applyState(usePainelDiaStore.setState, dadosImportados.painelDia);
  applyState(usePerfilStore.setState, dadosImportados.perfil);
  applyState(usePomodoroStore.setState, dadosImportados.pomodoro);
  applyState(usePrioridadesStore.setState, dadosImportados.prioridades);
  applyState(useRegistroEstudosStore.setState, dadosImportados.registroEstudos);
  applyState(useSonoStore.setState, dadosImportados.sono);
  applyState(useAtividadesStore.setState, dadosImportados.atividades);
  // Aplicar histórico apenas se existir nos dados importados (compatibilidade com v1.0)
  if (dadosImportados.historicoSimulados) {
    applyState(useHistoricoSimuladosStore.setState, dadosImportados.historicoSimulados); // <-- Restaurar histórico
  }
  applyState(useAppStore.setState, dadosImportados.appGlobal);
};


/**
 * Importa dados de um arquivo JSON local.
 * @param arquivo Arquivo File selecionado pelo usuário.
 * @returns Objeto com resultado da importação.
 */
export const importarDadosDeArquivo = async (arquivo: File): Promise<{ sucesso: boolean; mensagem?: string; timestamp?: string; erro?: string }> => {
  try {
    const texto = await arquivo.text();
    const dados = JSON.parse(texto);

    // Validar dados
    const validacao = validarDadosImportados(dados);
    if (!validacao.valido) {
      return { sucesso: false, erro: validacao.erro ?? 'Erro de validação desconhecido.' };
    }

    // Aplicar dados aos stores
    _applyImportedData(dados.dados);

    return {
      sucesso: true,
      mensagem: 'Dados importados com sucesso do arquivo.',
      timestamp: validacao.timestamp
    };
  } catch (error: any) {
    console.error('Erro ao importar dados do arquivo:', error);
    return {
      sucesso: false,
      erro: `Erro ao importar dados do arquivo: ${error.message}`
    };
  }
};

/**
 * Importa dados de um objeto JavaScript (ex: vindo de uma API).
 * @param dataObject Objeto contendo a estrutura de dados exportada ({ versao, timestamp, dados }).
 * @returns Objeto com resultado da importação.
 */
export const importarDadosFromObject = (dataObject: any): { sucesso: boolean; mensagem?: string; timestamp?: string; erro?: string } => {
  try {
    // Validar dados
    const validacao = validarDadosImportados(dataObject);
    if (!validacao.valido) {
      return { sucesso: false, erro: validacao.erro ?? 'Erro de validação desconhecido.' };
    }

    // Aplicar dados aos stores
    _applyImportedData(dataObject.dados);

    return {
      sucesso: true,
      mensagem: 'Dados importados com sucesso.',
      timestamp: validacao.timestamp
    };
  } catch (error: any) {
    console.error('Erro ao importar dados do objeto:', error);
    return {
      sucesso: false,
      erro: `Erro ao importar dados: ${error.message}`
    };
  }
};
</file>

<file path="app/lib/googleDriveClient.ts">
import { google, Auth } from 'googleapis'; // Import Auth explicitly
import { IronSession, IronSessionData } from 'iron-session';

const CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
const CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
// Use the same redirect URI as in auth routes, although it might not be strictly needed for refresh
const REDIRECT_URI = process.env.NODE_ENV === 'production' 
  ? 'https://stayfocus-main.vercel.app/api/auth/google/callback' 
  : 'http://localhost:3000/api/auth/google/callback';

if (!CLIENT_ID || !CLIENT_SECRET) {
  throw new Error('Missing Google OAuth credentials in environment variables');
}

/**
 * Creates an OAuth2 client and handles token refresh if necessary.
 * Updates the session with new tokens if refreshed.
 * @param session The IronSession object containing the tokens.
 * @returns An authenticated Auth.OAuth2Client instance or null if authentication fails.
 */
export async function getAuthenticatedClient(session: IronSession<IronSessionData>): Promise<Auth.OAuth2Client | null> {
  if (!session.tokens?.access_token) {
    console.error('No access token found in session.');
    return null;
  }

  const oauth2Client = new Auth.OAuth2Client( // Use Auth.OAuth2Client
    CLIENT_ID,
    CLIENT_SECRET,
    REDIRECT_URI
  );

  oauth2Client.setCredentials({
    access_token: session.tokens.access_token,
    refresh_token: session.tokens.refresh_token,
    expiry_date: session.tokens.expiry_date,
    token_type: session.tokens.token_type,
    scope: session.tokens.scope,
  });

  // Check if the token is expired or close to expiring (e.g., within 5 minutes)
  const expiryBuffer = 5 * 60 * 1000; // 5 minutes in milliseconds
  const isTokenExpired = session.tokens.expiry_date <= Date.now() + expiryBuffer;

  if (isTokenExpired) {
    if (!session.tokens.refresh_token) {
      console.error('Access token expired, but no refresh token available.');
      // Optionally destroy the session here if refresh is impossible
      // await session.destroy();
      return null; 
    }

    console.log('Access token expired, attempting refresh...');
    try {
      // Refresh the tokens
      const { credentials } = await oauth2Client.refreshAccessToken();
      
      if (!credentials || !credentials.access_token || !credentials.expiry_date) {
         throw new Error('Failed to refresh tokens: Invalid credentials received.');
      }

      console.log('Tokens refreshed successfully.');

      // Update the client with new credentials
      oauth2Client.setCredentials(credentials);

      // Update the session with the new tokens
      // Ensure session.tokens exists before assigning (should exist based on checks above)
      if (!session.tokens) {
        throw new Error("Session tokens object is unexpectedly undefined during refresh update.");
      }

      // Construct a new tokens object with the correct types
      const updatedTokens = {
        access_token: credentials.access_token,
        refresh_token: credentials.refresh_token === null 
                      ? undefined 
                      : credentials.refresh_token ?? session.tokens?.refresh_token,
        expiry_date: credentials.expiry_date,
        token_type: credentials.token_type,
        scope: credentials.scope === null ? undefined : credentials.scope ?? session.tokens?.scope
      } as IronSessionData['tokens'];

      // Assign the new object to the session
      session.tokens = updatedTokens; 

      await session.save();
      console.log('Session updated with refreshed tokens.');

    } catch (error: any) {
      console.error('Error refreshing access token:', error.message);
      // Optionally destroy the session if refresh fails permanently
      // await session.destroy();
      return null;
    }
  }

  return oauth2Client;
}
</file>

<file path="app/lib/session.ts">
import { getIronSession } from 'iron-session';
import {
  GetServerSidePropsContext,
  GetServerSidePropsResult,
  NextApiHandler,
  NextApiRequest,
  NextApiResponse,
} from 'next';

// Ensure SESSION_SECRET is set and is strong
const SESSION_SECRET = process.env.SESSION_SECRET;

if (!SESSION_SECRET || SESSION_SECRET === 'replace_this_with_a_real_random_32_byte_hex_string' || SESSION_SECRET.length < 32) {
  console.warn(
    'WARNING: SESSION_SECRET is not set or is weak in .env.local. Please generate a strong secret.'
  );
  // In a real app, you might throw an error here in production
}

// Extend NextApiRequest with session
declare module "next" {
  interface NextApiRequest {
    session: any;
  }
}

// Define the structure of your session data
declare module "iron-session" {
  interface IronSessionData {
    tokens?: {
      access_token: string;
      refresh_token: string | null | undefined; // Explicitly allow string, null, or undefined
      expiry_date: number;
      token_type?: string;
      scope?: string;
    };
  }
}

export const sessionOptions = {
  password: SESSION_SECRET || 'fallback_secret_for_dev_only_change_this', // Fallback only for type safety, real check above
  cookieName: 'myapp-session', // Choose a unique name
  cookieOptions: {
    // Settings recommended for security
    secure: process.env.NODE_ENV === 'production', // Secure in production
    httpOnly: true,
    sameSite: 'lax' as const, // Protection against CSRF
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
};

// Helper function to wrap API routes with session handling
export function withSessionRoute(handler: NextApiHandler) {
  return async (req: NextApiRequest, res: NextApiResponse) => {
    req.session = await getIronSession(req, res, sessionOptions);
    return handler(req, res);
  };
}

// Helper function to wrap getServerSideProps with session handling
export function withSessionSsr<P extends { [key: string]: unknown } = { [key: string]: unknown }>(
  handler: (
    context: GetServerSidePropsContext & { req: { session: any } },
  ) => GetServerSidePropsResult<P> | Promise<GetServerSidePropsResult<P>>,
) {
  return async (context: GetServerSidePropsContext) => {
    const session = await getIronSession(context.req, context.res, sessionOptions);
    
    // Assign the session to the request object
    (context.req as any).session = session;
    
    return handler(context as GetServerSidePropsContext & { req: { session: any } });
  };
}
</file>

<file path="app/lib/utils.ts">
import { clsx, type ClassValue } from 'clsx'
import { twMerge } from 'tailwind-merge'

/**
 * Mescla classes do Tailwind de forma eficiente, evitando conflitos
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="app/perfil/ajuda/page.tsx">
'use client';

import { ArrowLeft, HelpCircle, FileDown, FileUp, AlertTriangle } from 'lucide-react';
import Link from 'next/link';

export default function AjudaImportacaoExportacao() {
  return (
    <div className="max-w-4xl mx-auto p-6">
      <Link 
        href="/perfil" 
        className="flex items-center text-blue-600 dark:text-blue-400 mb-6 hover:underline"
      >
        <ArrowLeft size={16} className="mr-1" />
        Voltar para Perfil
      </Link>
      
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-8">
        <div className="flex items-center mb-4">
          <HelpCircle className="text-blue-600 dark:text-blue-400 mr-2" size={24} />
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Ajuda: Importação e Exportação de Dados
          </h1>
        </div>
        
        <div className="prose dark:prose-invert max-w-none">
          <p>
            O StayFocus permite que você faça backup dos seus dados e os restaure quando necessário.
            Isso é útil para transferir seus dados entre dispositivos ou para garantir que você não perca
            suas informações importantes.
          </p>
          
          <h2 className="flex items-center mt-6 mb-3">
            <FileDown className="mr-2 text-green-600 dark:text-green-400" size={20} />
            Exportação de Dados
          </h2>
          
          <p>
            A exportação de dados cria um arquivo JSON contendo todas as suas informações do StayFocus.
            Este arquivo pode ser armazenado com segurança em seu computador ou serviço de armazenamento na nuvem.
          </p>
          
          <h3>Como exportar seus dados:</h3>
          
          <ol className="list-decimal list-inside space-y-2 pl-4">
            <li>Acesse a página de Perfil</li>
            <li>Localize a seção "Importar/Exportar Dados"</li>
            <li>Clique no botão "Exportar Dados"</li>
            <li>Um arquivo chamado <code>stayfocus_backup_DATA.json</code> será baixado automaticamente</li>
            <li>Guarde este arquivo em um local seguro</li>
          </ol>
          
          <p className="text-sm bg-blue-50 dark:bg-blue-900/20 p-3 rounded-md border border-blue-100 dark:border-blue-800 my-4">
            <strong>Dica:</strong> Recomendamos fazer backup dos seus dados regularmente, especialmente antes de fazer
            alterações significativas no seu perfil ou configurações.
          </p>
          
          <h2 className="flex items-center mt-6 mb-3">
            <FileUp className="mr-2 text-amber-600 dark:text-amber-400" size={20} />
            Importação de Dados
          </h2>
          
          <p>
            A importação de dados permite restaurar informações previamente exportadas.
            Ao importar dados, todas as informações atuais serão substituídas pelo conteúdo do arquivo de backup.
          </p>
          
          <h3>Como importar seus dados:</h3>
          
          <ol className="list-decimal list-inside space-y-2 pl-4">
            <li>Acesse a página de Perfil</li>
            <li>Localize a seção "Importar/Exportar Dados"</li>
            <li>Clique no botão "Importar Dados"</li>
            <li>Selecione o arquivo de backup previamente exportado</li>
            <li>Confirme a importação quando solicitado</li>
            <li>Aguarde a mensagem de confirmação</li>
          </ol>
          
          <div className="flex items-start gap-3 bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-md border border-yellow-100 dark:border-yellow-800 my-4">
            <AlertTriangle className="text-yellow-600 dark:text-yellow-400 flex-shrink-0 mt-1" size={20} />
            <div>
              <p className="font-medium text-yellow-800 dark:text-yellow-200">Importante:</p>
              <p className="text-sm text-yellow-700 dark:text-yellow-300">
                A importação de dados <strong>substituirá</strong> todas as suas informações atuais.
                Este processo não pode ser desfeito, então certifique-se de exportar seus dados atuais
                antes de importar um backup, caso queira preservar as informações atuais.
              </p>
            </div>
          </div>
          
          <h2 className="mt-6 mb-3">Perguntas Frequentes</h2>
          
          <div className="space-y-4">
            <div>
              <h3 className="font-medium text-gray-900 dark:text-white">O que acontece com meus dados atuais quando faço uma importação?</h3>
              <p className="text-gray-600 dark:text-gray-300">
                Seus dados atuais serão completamente substituídos pelos dados do arquivo importado.
                Recomendamos fazer um backup dos seus dados atuais antes de importar novos dados.
              </p>
            </div>
            
            <div>
              <h3 className="font-medium text-gray-900 dark:text-white">Posso transferir meus dados entre dispositivos diferentes?</h3>
              <p className="text-gray-600 dark:text-gray-300">
                Sim! Exporte seus dados no dispositivo de origem, transfira o arquivo para o dispositivo
                de destino e então importe os dados nesse novo dispositivo.
              </p>
            </div>
            
            <div>
              <h3 className="font-medium text-gray-900 dark:text-white">É seguro armazenar o arquivo de backup?</h3>
              <p className="text-gray-600 dark:text-gray-300">
                O arquivo de backup contém todas as suas informações do StayFocus. Recomendamos
                armazená-lo em um local seguro e não compartilhá-lo com terceiros, a menos que
                você esteja ciente de que todas as suas informações pessoais estão contidas nele.
              </p>
            </div>
            
            <div>
              <h3 className="font-medium text-gray-900 dark:text-white">Meu backup é compatível com versões futuras do StayFocus?</h3>
              <p className="text-gray-600 dark:text-gray-300">
                Fazemos o possível para manter a compatibilidade com versões anteriores, mas
                ocasionalmente alterações estruturais podem ocorrer. Se encontrar problemas ao
                importar um backup antigo, entre em contato com o suporte.
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Nova Seção: Criando Simulados com IA */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mt-8">
        <div className="flex items-center mb-4">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-brain-circuit text-purple-600 dark:text-purple-400 mr-2"><path d="M12 5a3 3 0 1 0-5.997.004A3 3 0 0 0 12 5Z"/><path d="M12 19a3 3 0 1 0-5.997-.004A3 3 0 0 0 12 19Z"/><path d="M17 12a3 3 0 1 0-.004 5.997A3 3 0 0 0 17 12Z"/><path d="M17 12a3 3 0 1 0-.004-5.997A3 3 0 0 0 17 12Z"/><path d="M12 9a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1"/><path d="m14.5 12.5 1-1"/><path d="m15.5 10.5-1 1"/><path d="m14.5 11.5 1 1"/><path d="m15.5 13.5-1-1"/><path d="M9.5 12.5 11 14"/><path d="m6.5 11.5 1 1"/><path d="M8 9.5V7a1 1 0 0 1 1-1h"/><path d="M7.5 12.5 9 11"/></svg>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Criando Simulados com Inteligência Artificial (IA)
          </h1>
        </div>

        <div className="prose dark:prose-invert max-w-none">
          <p>
            Você pode usar Modelos de Linguagem Grandes (LLMs), como Claude, ChatGPT, Gemini, entre outros,
            para gerar arquivos de simulado personalizados sobre os conteúdos que você precisa estudar.
            Siga os passos abaixo para garantir que o arquivo gerado seja compatível com o StayFocus.
          </p>

          <h3 className="mt-5 mb-2">1. Copie a Estrutura JSON Necessária</h3>
          <p>
            A IA precisa saber exatamente qual formato de arquivo criar. Copie a estrutura abaixo e forneça-a
            como exemplo no seu prompt (pedido) para a IA:
          </p>
          <pre className="bg-gray-100 dark:bg-gray-700 p-3 rounded-md text-sm overflow-x-auto">
            <code>
{`{
  "metadata": {
    "titulo": "Título do Seu Simulado Aqui",
    "concurso": "Opcional: Nome do Concurso",
    "ano": 2025,
    "area": "Opcional: Área de Conhecimento",
    "nivel": "Opcional: Nível (Fácil, Médio, Difícil)",
    "totalQuestoes": 10, // Ajuste o número total de questões
    "autor": "Opcional: Seu Nome ou Fonte"
  },
  "questoes": [
    {
      "id": 1, // ID numérico único para cada questão
      "enunciado": "Texto completo da pergunta aqui...",
      "alternativas": {
        "a": "Texto da alternativa A",
        "b": "Texto da alternativa B",
        "c": "Texto da alternativa C",
        "d": "Texto da alternativa D",
        "e": "Opcional: Texto da alternativa E"
        // Adicione mais alternativas se necessário (f, g, ...)
      },
      "gabarito": "c", // Letra da alternativa correta
      "assunto": "Opcional: Tópico específico da questão",
      "dificuldade": 2, // Opcional: Nível de dificuldade (ex: 1 a 5)
      "explicacao": "Opcional: Justificativa detalhada da resposta correta"
    }
    // Repita a estrutura acima para cada questão, ajustando o "id"
  ]
}`}
            </code>
          </pre>
          <p className="text-sm mt-2">
            <strong>Importante:</strong> Os campos <code>titulo</code>, <code>totalQuestoes</code>, <code>id</code>, <code>enunciado</code>, <code>alternativas</code> e <code>gabarito</code> são <strong>obrigatórios</strong>. Os outros são opcionais.
            Certifique-se de que cada <code>id</code> de questão seja um número único.
          </p>

          <h3 className="mt-5 mb-2">2. Prepare o Conteúdo (Opcional, mas Recomendado)</h3>
          <p>
            Se você tem um texto, PDF ou anotações sobre o conteúdo que deseja transformar em simulado,
            é útil copiá-lo para um arquivo <code>.txt</code> simples. Você poderá anexar este arquivo
            ao seu pedido para a IA, facilitando a criação de questões relevantes.
          </p>

          <h3 className="mt-5 mb-2">3. Crie o Prompt para a IA</h3>
          <p>
            Vá até a interface de chat da sua IA preferida (Claude, ChatGPT, Gemini, etc.) e crie um prompt claro.
            Anexe o arquivo <code>.txt</code> com o conteúdo, se você o criou.
          </p>
          <p><strong>Exemplo de Prompt:</strong></p>
          <blockquote className="border-l-4 border-purple-500 pl-4 italic my-4">
            "Por favor, crie um simulado com [Número] questões de múltipla escolha sobre o conteúdo do arquivo anexado (ou sobre [Tópico Específico]).
            As questões devem abordar [Aspectos específicos do tópico, se houver].
            Gere a resposta estritamente no formato JSON que forneci abaixo. Certifique-se de que cada questão tenha um ID numérico único,
            e que o campo 'totalQuestoes' no metadata corresponda ao número de questões geradas. Inclua 4 alternativas (a, b, c, d) para cada questão.
            Se possível, adicione também os campos opcionais 'assunto' e 'explicacao' para cada questão.

            Aqui está o formato JSON exato a ser seguido:
            [Cole aqui a estrutura JSON copiada no Passo 1]"
          </blockquote>
          <p className="text-sm mt-2">
            Ajuste o `[Número]` de questões e o `[Tópico Específico]` conforme sua necessidade.
          </p>

          <h3 className="mt-5 mb-2">4. Use o JSON Gerado no StayFocus</h3>
          <p>
            A IA deve retornar uma resposta contendo o código JSON. Copie todo esse código JSON.
            Você tem duas opções para carregá-lo no StayFocus:
          </p>
          <ul className="list-disc list-inside space-y-2 pl-4 mb-3">
            <li>
              <strong>Opção 1 (Recomendado): Colar o Texto</strong><br/>
              Vá para a seção "Estudos" no StayFocus, clique em "Conferir Simulado". Na tela de carregamento,
              cole o código JSON diretamente na caixa de texto "Opção 2: Colar o texto JSON aqui" e clique no botão
              "Carregar Texto Colado".
            </li>
            <li>
              <strong>Opção 2: Salvar como Arquivo</strong><br/>
              Abra um editor de texto simples (como Bloco de Notas no Windows ou TextEdit no Mac), cole o código JSON
              e salve o arquivo com a extensão <code>.json</code> (ex: <code>meu_simulado.json</code>). Depois, na tela
              "Conferir Simulado" do StayFocus, use a "Opção 1: Carregar arquivo .json" para selecionar este arquivo.
            </li>
          </ul>

          <div className="flex items-start gap-3 bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded-md border border-yellow-100 dark:border-yellow-800 my-4">
            <AlertTriangle className="text-yellow-600 dark:text-yellow-400 flex-shrink-0 mt-1" size={20} />
            <div>
              <p className="font-medium text-yellow-800 dark:text-yellow-200">Revisão é Essencial:</p>
              <p className="text-sm text-yellow-700 dark:text-yellow-300">
                As IAs podem cometer erros! Sempre revise as questões, alternativas e, principalmente,
                o gabarito gerado pela IA antes de usar o simulado para estudar. Verifique se o JSON está
                corretamente formatado, sem vírgulas extras ou faltando chaves.
              </p>
            </div>
          </div>

        </div>
      </div>
      {/* Fim da Nova Seção */}

    </div>
  );
}
</file>

<file path="app/perfil/page.tsx">
'use client'

import { useState, useEffect } from 'react'
import { usePerfilStore } from '../stores/perfilStore'
import { InformacoesPessoais } from '../components/perfil/InformacoesPessoais'
import { MetasDiarias } from '../components/perfil/MetasDiarias'
import { PreferenciasVisuais } from '../components/perfil/PreferenciasVisuais'
import { ExportarImportarDados } from '../components/ExportarImportarDados'
import { RefreshCw, User } from 'lucide-react'

export default function PerfilPage() {
  const { resetarPerfil, preferenciasVisuais } = usePerfilStore()
  const [resetConfirmOpen, setResetConfirmOpen] = useState(false)
  
  // Aplicar classes de acessibilidade ao carregar a página
  useEffect(() => {
    if (preferenciasVisuais.altoContraste) {
      document.documentElement.classList.add('alto-contraste')
    }
    
    if (preferenciasVisuais.reducaoEstimulos) {
      document.documentElement.classList.add('reducao-estimulos')
    }
    
    if (preferenciasVisuais.textoGrande) {
      document.documentElement.classList.add('texto-grande')
    }
    
    // Cleanup
    return () => {
      document.documentElement.classList.remove('alto-contraste', 'reducao-estimulos', 'texto-grande')
    }
  }, [preferenciasVisuais])
  
  const confirmarReset = () => {
    resetarPerfil()
    setResetConfirmOpen(false)
  }

  return (
    <div className="container max-w-4xl mx-auto px-4 py-8">
      <div className="flex items-center justify-between mb-8">
        <div className="flex items-center">
          <div className="h-12 w-12 rounded-full bg-perfil-primary flex items-center justify-center text-white text-xl font-bold mr-4">
            <User className="h-6 w-6" />
          </div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Informações Pessoais
          </h1>
        </div>
        
        <button
          onClick={() => setResetConfirmOpen(true)}
          className="text-sm flex items-center text-gray-500 hover:text-perfil-primary dark:text-gray-400 dark:hover:text-perfil-secondary focus:outline-none"
          aria-label="Redefinir configurações"
        >
          <RefreshCw className="h-4 w-4 mr-1" />
          Redefinir
        </button>
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2 space-y-6">
          <InformacoesPessoais />
          <MetasDiarias />
        </div>
        
        <div className="space-y-6">
          <PreferenciasVisuais />
          <ExportarImportarDados />
        </div>
      </div>
      
      {/* Modal de confirmação */}
      {resetConfirmOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-lg max-w-md w-full p-6 shadow-xl">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-3">
              Redefinir configurações?
            </h3>
            <p className="text-gray-600 dark:text-gray-300 mb-6">
              Todas as suas preferências, metas e configurações serão restauradas para os valores padrão.
              Esta ação não pode ser desfeita.
            </p>
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => setResetConfirmOpen(false)}
                className="px-4 py-2 text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-700 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600 focus:outline-none"
              >
                Cancelar
              </button>
              <button
                onClick={confirmarReset}
                className="px-4 py-2 text-white bg-red-500 rounded-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500"
              >
                Redefinir
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
</file>

<file path="app/receitas/[id]/page.tsx">
import { DetalhesReceita } from '../../components/receitas/DetalhesReceita';

interface ReceitaDetalhesPageProps {
  params: {
    id: string;
  };
}

// This page will be dynamically rendered based on the [id] parameter
export default function ReceitaDetalhesPage({ params }: ReceitaDetalhesPageProps) {
  // The DetalhesReceita component handles fetching the recipe data using the id
  return <DetalhesReceita id={params.id} />;
}

// Optional: Add generateStaticParams if you want to pre-render some recipe pages at build time
// export async function generateStaticParams() {
//   // Fetch a list of recipe IDs from your data source (e.g., the store or an API)
//   // const recipes = await fetchRecipes(); // Replace with your data fetching logic
//   // return recipes.map((recipe) => ({
//   //   id: recipe.id,
//   // }));
//   return []; // Return empty array if not pre-rendering
// }
</file>

<file path="app/receitas/adicionar/page.tsx">
import { AdicionarReceitaForm } from '../../components/receitas/AdicionarReceitaForm';

// This page renders the form for adding a new recipe.
// No 'receitaParaEditar' prop is passed, so the form starts empty.
export default function AdicionarReceitaPage() {
  return <AdicionarReceitaForm />;
}
</file>

<file path="app/receitas/editar/[id]/page.tsx">
'use client'; // Required for client-side data fetching (useReceitasStore)

import { AdicionarReceitaForm } from '../../../components/receitas/AdicionarReceitaForm';
import { useReceitasStore } from '../../../stores/receitasStore';
import { useParams } from 'next/navigation'; // Hook to get route parameters

// This page renders the form for editing an existing recipe.
export default function EditarReceitaPage() {
  const params = useParams();
  const { obterReceitaPorId } = useReceitasStore();

  // Wait until params are available
  if (!params) {
    return <p className="p-4 text-center text-gray-500">Carregando...</p>; // Or a loading spinner
  }

  // Get the recipe ID from the route parameters
  const id = typeof params.id === 'string' ? params.id : undefined;

  // Fetch the recipe data using the ID
  const receitaParaEditar = id ? obterReceitaPorId(id) : undefined;

  if (!id) {
    // Handle case where ID is missing (shouldn't normally happen with file-based routing)
    return <p className="p-4 text-center text-red-500">ID da receita não encontrado na URL.</p>;
  }

  if (!receitaParaEditar) {
    // Handle case where recipe with the given ID doesn't exist
    // You might want to redirect or show a more specific error
    return <p className="p-4 text-center text-gray-500">Receita com ID '{id}' não encontrada.</p>;
  }

  // Pass the fetched recipe data to the form component
  return <AdicionarReceitaForm receitaParaEditar={receitaParaEditar} />;
}
</file>

<file path="app/receitas/lista-compras/page.tsx">
import { ListaCompras } from '../../components/receitas/ListaCompras';

// This page renders the shopping list component.
export default function ListaComprasPage() {
  return <ListaCompras />;
}
</file>

<file path="app/receitas/page.tsx">
'use client'; // Required for useState and other client-side hooks

import { useState } from 'react';
import { ListaReceitas } from '../components/receitas/ListaReceitas';
import { FiltroCategorias } from '../components/receitas/FiltroCategorias';
import { Pesquisa } from '../components/ui/Pesquisa'; // Corrected path
import { useReceitasStore } from '../stores/receitasStore';
import { Button } from '../components/ui/Button'; // Import Button
import Link from 'next/link'; // Import Link
import { ImportadorReceitas } from '../components/receitas/ImportadorReceitas'; // Import the new component

export default function ReceitasPage() {
  const { receitas } = useReceitasStore();
  const [filtroCategoria, setFiltroCategoria] = useState('todas');
  const [termoPesquisa, setTermoPesquisa] = useState('');

  const receitasFiltradas = receitas
    .filter(receita =>
      filtroCategoria === 'todas' || (receita.categorias && receita.categorias.includes(filtroCategoria))
    )
    .filter(receita => {
      const termo = termoPesquisa.toLowerCase();
      const nomeMatch = receita.nome.toLowerCase().includes(termo);
      const ingredienteMatch = receita.ingredientes?.some(ing =>
        ing.nome.toLowerCase().includes(termo)
      );
      // Add description and tag search if needed
      // const descricaoMatch = receita.descricao?.toLowerCase().includes(termo);
      // const tagMatch = receita.tags?.some(tag => tag.toLowerCase().includes(termo));
      return nomeMatch || ingredienteMatch; // || descricaoMatch || tagMatch;
    });

  return (
    <div className="p-4 md:p-6 lg:p-8">
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
        <h1 className="text-2xl md:text-3xl font-bold">Minhas Receitas</h1>
        <Link href="/receitas/adicionar" passHref>
           <Button color="primary">Adicionar Nova Receita</Button>
        </Link>
      </div>

      {/* Import Component Added Here */}
      <ImportadorReceitas />

      <div className="flex flex-col sm:flex-row gap-4 mb-6">
        <Pesquisa
          placeholder="Buscar por nome ou ingrediente"
          valor={termoPesquisa}
          aoMudar={setTermoPesquisa}
          className="flex-grow" // Allow search bar to grow
        />
        <FiltroCategorias
          categoriaAtual={filtroCategoria}
          aoSelecionar={setFiltroCategoria}
          className="w-full sm:w-auto sm:min-w-[200px]" // Set min-width on smaller screens
        />
         <Link href="/receitas/lista-compras" passHref>
           <Button variant="outline">Lista de Compras</Button>
         </Link>
      </div>

      <ListaReceitas receitas={receitasFiltradas} />
    </div>
  );
}
</file>

<file path="app/roadmap/page.tsx">
'use client'

import React from 'react'
import { Container } from '@/app/components/ui/Container'
import { Card } from '@/app/components/ui/Card'
import { Section } from '@/app/components/ui/Section'
import { CheckCircle2 } from 'lucide-react'

export default function RoadmapPage() {
  return (
    <Container>
      <Section title="Roadmap do StayFocus">
        <Card className="mb-6">
          <h2 className="text-xl font-bold text-blue-600 dark:text-blue-400 mb-4">💭 O conceito</h2>
          <p className="mb-4">
            O StayFocus surge da minha própria experiência com TDAH e da observação de que precisamos de ferramentas que funcionem com nossos cérebros, não contra eles. Cada recurso foi pensado para ser:
          </p>
          <ul className="list-disc pl-6 space-y-2 mb-4">
            <li>Simples e focado - Sem distrações ou complexidades desnecessárias</li>
            <li>Visualmente claro - Feedback visual imediato para todas as ações</li>
            <li>Adaptável às suas necessidades - Reconhecendo que cada cérebro neurodivergente é único</li>
            <li>Persistente - Porque sabemos como é fácil esquecer coisas importantes</li>
          </ul>
        </Card>

        <Card className="mb-6">
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-green-600 dark:text-green-400 mb-4">🛠️ O que já temos (Sprint 1)</h2>
            <div className="ml-2 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              Concluído
            </div>
          </div>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">📱 Página Inicial</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Painel do Dia - Visualize seu dia em um único lugar</li>
            <li>Lista de Prioridades - Foque no que realmente importa</li>
            <li>Lembretes de Pausas - Porque nossos cérebros precisam descansar!</li>
            <li>Checklist de Medicamentos - Organização por tipo para facilitar o acompanhamento</li>
          </ul>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">🥗 Alimentação</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Planejador de Refeições - Facilite a decisão do que comer</li>
            <li>Registro de Refeições - Acompanhe seus padrões alimentares</li>
            <li>Lembrete de Hidratação - Para não esquecer de beber água (sim, acontece!)</li>
          </ul>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">📚 Estudos</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Temporizador Pomodoro - Técnica adaptada para cérebros neurodivergentes</li>
            <li>Registro de Estudos - Acompanhe seu progresso e celebre pequenas vitórias</li>
            <li>**Conferência de Simulados - Carregue arquivos JSON e revise suas respostas**</li>
            <li>**Histórico de Simulados - Veja seu desempenho (melhor/última nota) e refaça simulados**</li>
            <li>**Integração do Histórico com Backups - Salve e restaure seu progresso via Google Drive ou localmente**</li>
          </ul>

          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">❤️ Saúde</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Registro de Medicamentos - Com sistema de intervalo entre doses para evitar superdosagem acidental</li>
            <li>Monitoramento de Humor - Identifique padrões e gatilhos emocionais</li>
          </ul>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-4 mb-2">🎮 Lazer</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Temporizador de Lazer - Para garantir que você também se divirta</li>
            <li>Atividades de Lazer - Registre e acompanhe suas atividades favoritas</li>
            <li>Sugestões de Descanso - Quando seu cérebro precisa de uma pausa, mas você não sabe o que fazer</li>
          </ul>
        </Card>

        <Card className="mb-6">
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-indigo-600 dark:text-indigo-400 mb-4">⚙️ Sprint 2</h2>
            <div className="ml-2 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              Concluído
            </div>
          </div>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">😴 Gestão do Sono</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Registro de Sono - Acompanhe os horários de dormir e acordar</li>
            <li>Visualizador Semanal - Veja padrões de sono ao longo do tempo</li>
            <li>Lembretes Personalizáveis - Configure alertas para criar uma rotina de sono</li>
            <li>Metas de Sono - Defina objetivos realistas para melhorar sua qualidade de sono</li>
          </ul>
        </Card>

        <Card className="mb-6">
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-purple-600 dark:text-purple-400 mb-4">⚙️ Sprint 3</h2>
            <div className="ml-2 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              Concluído
            </div>
          </div>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">🧠 Notas de Autoconhecimento</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Seções Organizadas - "Quem sou", "Meus porquês" e "Meus padrões"</li>
            <li>Modo Refúgio - Interface simplificada para momentos de crise</li>
            <li>Sistema de Tags - Categorize suas anotações para encontrá-las facilmente</li>
            <li>Âncoras Visuais - Adicione imagens significativas que te ajudem a se reconectar</li>
          </ul>

          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-3 mb-2">👤 Informações Pessoais</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Perfil Personalizável - Configure seu nome e preferências</li>
            <li>Metas Diárias - Defina objetivos personalizados para sono, tarefas, água e pausas</li>
            <li>Preferências Visuais - Configure opções de acessibilidade como alto contraste, redução de estímulos e texto grande</li>
          </ul>
        </Card>

        <Card className="mb-6">
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-amber-600 dark:text-amber-400 mb-4">⚙️ Sprint 4</h2>
            <div className="ml-2 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              Concluído
            </div>
          </div>
          
          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">🔄 Melhorias de Interface</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Correção de distorções visuais - Garantia de uma experiência mais agradável</li>
            <li>Novos ícones e layout - Design mais intuitivo e acessível</li>
            <li>Atualização do rodapé - Inclusão de provérbio inspirador e acesso ao repositório</li>
            <li>Renomeação para StayFocus - Nova identidade visual</li>
          </ul>
        </Card>

        {/* Nova Sprint para Funcionalidades Adicionais */}
        <Card className="mb-6">
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-cyan-600 dark:text-cyan-400 mb-4">⚙️ Sprint 6 (Funcionalidades Adicionais)</h2>
            <div className="ml-2 bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              Concluído
            </div>
          </div>

          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">💾 Backup e Restauração</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Backup Local - Exporte todos os seus dados para um arquivo JSON</li>
            <li>Importação Local - Restaure seus dados a partir de um arquivo JSON</li>
            <li>Integração com Google Drive - Conecte sua conta para salvar e carregar backups na nuvem</li>
            <li>Inclusão do Histórico de Simulados - Garante que seu progresso nos simulados seja salvo nos backups</li>
          </ul>
        </Card>
        {/* Fim da Nova Sprint */}


        <Card>
          <div className="flex items-center">
            <h2 className="text-xl font-bold text-rose-600 dark:text-rose-400 mb-4">🔮 Sprint 7 (Final)</h2> {/* Renomeado para Sprint 7 */}
            <div className="ml-2 bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-400 px-2 py-0.5 rounded-full text-xs flex items-center">
              Planejado
            </div>
          </div>
          
          <div className="mb-4 p-3 border border-amber-200 dark:border-amber-900/50 rounded-lg bg-amber-50 dark:bg-amber-900/20">
            <p className="text-amber-800 dark:text-amber-200 font-medium">⚠️ Aviso importante</p>
            <p className="text-amber-700 dark:text-amber-300 text-sm">
              Para evitar sobrecarga cognitiva, haverá uma pausa de um mês antes do início do desenvolvimento deste sprint final.
            </p>
          </div>

          <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mt-2 mb-2">🔄 Sincronização e Apps Mobile</h3>
          <ul className="list-disc pl-6 space-y-1 mb-3">
            <li>Backend com Supabase - Sincronização de dados entre dispositivos</li>
            <li>Aplicativo para iOS - Acesse sua aplicação em dispositivos Apple</li>
            <li>Aplicativo para Android - Versão para dispositivos Android</li>
            <li>Sincronização offline - Acesse seus dados mesmo sem internet</li>
          </ul>
        </Card>
      </Section>
    </Container>
  )
}
</file>

<file path="app/saude/page.tsx">
import { RegistroMedicamentos } from '@/app/components/saude/RegistroMedicamentos'
import { MonitoramentoHumor } from '@/app/components/saude/MonitoramentoHumor'

export default function SaudePage() {
  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-4">Saúde</h1>
      
      <div className="grid grid-cols-1 gap-6">
        {/* Registro de Medicamentos */}
        <RegistroMedicamentos />
        
        {/* Monitoramento de Humor */}
        <MonitoramentoHumor />
      </div>
    </div>
  )
}
</file>

<file path="app/sono/page.tsx">
'use client'

import { useState } from 'react'
import { RegistroSono } from '../components/sono/RegistroSono'
import { VisualizadorSemanal } from '../components/sono/VisualizadorSemanal'
import { ConfiguracaoLembretes } from '../components/sono/ConfiguracaoLembretes'

export default function SonoPage() {
  const [abaSelecionada, setAbaSelecionada] = useState<'registro' | 'visualizador' | 'lembretes'>('registro')
  
  return (
    <main className="container mx-auto px-4 py-8 max-w-7xl">
      <div className="flex items-center mb-8">
        <div className="text-sono-primary mr-3 font-mono">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="28"
            height="28"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            aria-hidden="true"
          >
            <path d="M2 4v16"></path>
            <path d="M2 8h18a2 2 0 0 1 2 2v10"></path>
            <path d="M2 17h20"></path>
            <path d="M6 8v9"></path>
          </svg>
        </div>
        <h1 className="text-2xl font-bold text-gray-800 dark:text-white">Gestão do Sono</h1>
      </div>
      
      {/* Navegação entre abas */}
      <div className="flex border-b border-gray-200 dark:border-gray-700 mb-6">
        <button
          className={`px-4 py-2 font-medium text-sm rounded-t-lg ${
            abaSelecionada === 'registro'
              ? 'bg-sono-light text-sono-primary border-b-2 border-sono-primary'
              : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
          }`}
          onClick={() => setAbaSelecionada('registro')}
          aria-current={abaSelecionada === 'registro' ? 'page' : undefined}
        >
          Registrar Sono
        </button>
        <button
          className={`px-4 py-2 font-medium text-sm rounded-t-lg ${
            abaSelecionada === 'visualizador'
              ? 'bg-sono-light text-sono-primary border-b-2 border-sono-primary'
              : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
          }`}
          onClick={() => setAbaSelecionada('visualizador')}
          aria-current={abaSelecionada === 'visualizador' ? 'page' : undefined}
        >
          Visualizar Sono
        </button>
        <button
          className={`px-4 py-2 font-medium text-sm rounded-t-lg ${
            abaSelecionada === 'lembretes'
              ? 'bg-sono-light text-sono-primary border-b-2 border-sono-primary'
              : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300'
          }`}
          onClick={() => setAbaSelecionada('lembretes')}
          aria-current={abaSelecionada === 'lembretes' ? 'page' : undefined}
        >
          Lembretes
        </button>
      </div>
      
      {/* Conteúdo da aba selecionada */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        {abaSelecionada === 'registro' && <RegistroSono />}
        {abaSelecionada === 'visualizador' && <VisualizadorSemanal />}
        {abaSelecionada === 'lembretes' && <ConfiguracaoLembretes />}
      </div>
      
      {/* Informações adicionais */}
      <div className="bg-sono-light bg-opacity-50 dark:bg-gray-700 p-4 rounded-lg text-gray-700 dark:text-gray-300">
        <h3 className="text-lg font-medium mb-2 text-sono-primary">A importância do sono</h3>
        <p className="text-sm mb-2">
          O sono de qualidade é essencial para a saúde cerebral e física, especialmente para pessoas neurodivergentes.
          Regular seus ciclos de sono pode ajudar a reduzir a sobrecarga sensorial e melhorar o funcionamento cognitivo.
        </p>
        <ul className="text-sm list-disc pl-5 space-y-1">
          <li>Tente manter horários regulares para dormir e acordar</li>
          <li>Crie uma rotina relaxante antes de dormir</li>
          <li>Reduza a exposição à luz azul pelo menos 1 hora antes de dormir</li>
          <li>Evite cafeína e estimulantes no período da tarde</li>
        </ul>
      </div>
    </main>
  )
}
</file>

<file path="app/store/index.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipos para o estado global
export type Tarefa = {
  id: string
  texto: string
  concluida: boolean
  categoria: 'inicio' | 'alimentacao' | 'estudos' | 'saude' | 'lazer'
  data: string // formato YYYY-MM-DD
}

export type BlocoTempo = {
  id: string
  hora: string
  atividade: string
  categoria: 'inicio' | 'alimentacao' | 'estudos' | 'saude' | 'lazer' | 'nenhuma'
  data: string // formato YYYY-MM-DD
}

export type Refeicao = {
  id: string
  hora: string
  descricao: string
  foto?: string
  data: string // formato YYYY-MM-DD
}

export type Medicacao = {
  id: string
  nome: string
  horarios: string[]
  tomada: Record<string, boolean> // chave: data-horario, valor: tomada ou não
}

// Novo tipo para medicamentos refatorado
export type Medicamento = {
  id: string
  nome: string
  dosagem: string
  frequencia: string
  horarios: string[]
  observacoes: string
  dataInicio: string
  ultimaTomada: string | null
  intervalo?: number // tempo em minutos entre doses
}

// Novo tipo para registros de humor
export type RegistroHumor = {
  id: string
  data: string
  nivel: number
  fatores: string[]
  notas: string
}

export type ConfiguracaoUsuario = {
  tempoFoco: number // em minutos
  tempoPausa: number // em minutos
  temaEscuro: boolean
  reducaoEstimulos: boolean
}

// Interface do estado global
interface AppState {
  tarefas: Tarefa[]
  blocosTempo: BlocoTempo[]
  refeicoes: Refeicao[]
  medicacoes: Medicacao[]
  configuracao: ConfiguracaoUsuario
  
  // Novos estados para medicamentos e humor refatorados
  medicamentos: Medicamento[]
  registrosHumor: RegistroHumor[]
  
  // Ações para tarefas
  adicionarTarefa: (tarefa: Omit<Tarefa, 'id'>) => void
  removerTarefa: (id: string) => void
  toggleTarefaConcluida: (id: string) => void
  
  // Ações para blocos de tempo
  adicionarBlocoTempo: (bloco: Omit<BlocoTempo, 'id'>) => void
  atualizarBlocoTempo: (id: string, bloco: Partial<BlocoTempo>) => void
  removerBlocoTempo: (id: string) => void
  
  // Ações para refeições
  adicionarRefeicao: (refeicao: Omit<Refeicao, 'id'>) => void
  removerRefeicao: (id: string) => void
  
  // Ações para medicações
  adicionarMedicacao: (medicacao: Omit<Medicacao, 'id'>) => void
  marcarMedicacaoTomada: (id: string, data: string, horario: string, tomada: boolean) => void
  
  // Novas ações para medicamentos refatorados
  adicionarMedicamento: (medicamento: Omit<Medicamento, 'id'>) => void
  atualizarMedicamento: (id: string, medicamento: Partial<Omit<Medicamento, 'id'>>) => void
  removerMedicamento: (id: string) => void
  registrarTomadaMedicamento: (id: string, dataHora: string) => void
  
  // Novas ações para registros de humor
  adicionarRegistroHumor: (registro: Omit<RegistroHumor, 'id'>) => void
  atualizarRegistroHumor: (id: string, registro: Partial<Omit<RegistroHumor, 'id'>>) => void
  removerRegistroHumor: (id: string) => void
  
  // Ações para configurações
  atualizarConfiguracao: (config: Partial<ConfiguracaoUsuario>) => void
}

// Criação da store com persistência local
export const useAppStore = create<AppState>()(
  persist(
    (set) => ({
      // Estado inicial
      tarefas: [],
      blocosTempo: [],
      refeicoes: [],
      medicacoes: [],
      configuracao: {
        tempoFoco: 25,
        tempoPausa: 5,
        temaEscuro: false,
        reducaoEstimulos: false,
      },
      
      // Novos estados iniciais para medicamentos e humor
      medicamentos: [],
      registrosHumor: [],

      // Implementações das ações para tarefas
      adicionarTarefa: (tarefa) =>
        set((state) => ({
          tarefas: [...state.tarefas, { ...tarefa, id: Date.now().toString() }],
        })),
      
      removerTarefa: (id) =>
        set((state) => ({
          tarefas: state.tarefas.filter((t) => t.id !== id),
        })),
      
      toggleTarefaConcluida: (id) =>
        set((state) => ({
          tarefas: state.tarefas.map((t) =>
            t.id === id ? { ...t, concluida: !t.concluida } : t
          ),
        })),

      // Implementações das ações para blocos de tempo
      adicionarBlocoTempo: (bloco) =>
        set((state) => ({
          blocosTempo: [...state.blocosTempo, { ...bloco, id: Date.now().toString() }],
        })),
      
      atualizarBlocoTempo: (id, bloco) =>
        set((state) => ({
          blocosTempo: state.blocosTempo.map((b) =>
            b.id === id ? { ...b, ...bloco } : b
          ),
        })),
      
      removerBlocoTempo: (id) =>
        set((state) => ({
          blocosTempo: state.blocosTempo.filter((b) => b.id !== id),
        })),

      // Implementações das ações para refeições
      adicionarRefeicao: (refeicao) =>
        set((state) => ({
          refeicoes: [...state.refeicoes, { ...refeicao, id: Date.now().toString() }],
        })),
      
      removerRefeicao: (id) =>
        set((state) => ({
          refeicoes: state.refeicoes.filter((r) => r.id !== id),
        })),

      // Implementações das ações para medicações
      adicionarMedicacao: (medicacao) =>
        set((state) => ({
          medicacoes: [
            ...state.medicacoes,
            { ...medicacao, id: Date.now().toString() },
          ],
        })),
      
      marcarMedicacaoTomada: (id, data, horario, tomada) =>
        set((state) => ({
          medicacoes: state.medicacoes.map((med) => {
            if (med.id === id) {
              return {
                ...med,
                tomada: {
                  ...med.tomada,
                  [`${data}-${horario}`]: tomada,
                },
              }
            }
            return med
          }),
        })),
        
      // Implementações das novas ações para medicamentos
      adicionarMedicamento: (medicamento) =>
        set((state) => ({
          medicamentos: [
            ...state.medicamentos,
            {
              ...medicamento,
              id: Date.now().toString(),
            },
          ],
        })),
        
      atualizarMedicamento: (id, medicamento) =>
        set((state) => ({
          medicamentos: state.medicamentos.map((med) =>
            med.id === id ? { ...med, ...medicamento } : med
          ),
        })),
        
      removerMedicamento: (id) =>
        set((state) => ({
          medicamentos: state.medicamentos.filter((med) => med.id !== id),
        })),
        
      registrarTomadaMedicamento: (id, dataHora) =>
        set((state) => ({
          medicamentos: state.medicamentos.map((med) =>
            med.id === id ? { ...med, ultimaTomada: dataHora } : med
          ),
        })),
        
      // Implementações das novas ações para registros de humor
      adicionarRegistroHumor: (registro) =>
        set((state) => ({
          registrosHumor: [
            ...state.registrosHumor,
            {
              ...registro,
              id: Date.now().toString(),
            },
          ],
        })),
        
      atualizarRegistroHumor: (id, registro) =>
        set((state) => ({
          registrosHumor: state.registrosHumor.map((reg) =>
            reg.id === id ? { ...reg, ...registro } : reg
          ),
        })),
        
      removerRegistroHumor: (id) =>
        set((state) => ({
          registrosHumor: state.registrosHumor.filter((reg) => reg.id !== id),
        })),

      // Implementações das ações para configurações
      atualizarConfiguracao: (config) =>
        set((state) => ({
          configuracao: {
            ...state.configuracao,
            ...config,
          },
        })),
    }),
    {
      name: 'painel-neurodivergentes-storage',
      partialize: (state) => ({
        tarefas: state.tarefas,
        blocosTempo: state.blocosTempo,
        refeicoes: state.refeicoes,
        medicacoes: state.medicacoes,
        configuracao: state.configuracao,
        medicamentos: state.medicamentos,
        registrosHumor: state.registrosHumor,
      }),
    }
  )
)
</file>

<file path="app/stores/alimentacaoStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipos
export type Refeicao = {
  id: string
  horario: string
  descricao: string
}

export type RegistroRefeicao = {
  id: string
  data: string
  horario: string
  descricao: string
  tipoIcone: string | null
  foto: string | null
}

type AlimentacaoState = {
  // Planejador de Refeições
  refeicoes: Refeicao[]
  adicionarRefeicao: (horario: string, descricao: string) => void
  atualizarRefeicao: (id: string, horario: string, descricao: string) => void
  removerRefeicao: (id: string) => void
  
  // Registro de Refeições
  registros: RegistroRefeicao[]
  adicionarRegistro: (horario: string, descricao: string, tipoIcone: string | null, foto: string | null) => void
  removerRegistro: (id: string) => void
  
  // Hidratação
  coposBebidos: number
  metaDiaria: number
  ultimoRegistro: string | null
  adicionarCopo: () => void
  removerCopo: () => void
  ajustarMeta: (valor: number) => void
}

export const useAlimentacaoStore = create<AlimentacaoState>()(
  persist(
    (set) => ({
      // Planejador de Refeições - Estado Inicial
      refeicoes: [
        { id: '1', horario: '07:30', descricao: 'Café da manhã' },
        { id: '2', horario: '12:00', descricao: 'Almoço' },
        { id: '3', horario: '16:00', descricao: 'Lanche da tarde' },
        { id: '4', horario: '19:30', descricao: 'Jantar' },
      ],
      
      adicionarRefeicao: (horario, descricao) => 
        set((state) => ({
          refeicoes: [
            ...state.refeicoes,
            {
              id: Date.now().toString(),
              horario,
              descricao,
            },
          ],
        })),
      
      atualizarRefeicao: (id, horario, descricao) =>
        set((state) => ({
          refeicoes: state.refeicoes.map((refeicao) =>
            refeicao.id === id ? { ...refeicao, horario, descricao } : refeicao
          ),
        })),
      
      removerRefeicao: (id) =>
        set((state) => ({
          refeicoes: state.refeicoes.filter((refeicao) => refeicao.id !== id),
        })),
      
      // Registro de Refeições - Estado Inicial
      registros: [
        {
          id: '1',
          data: '2025-03-03',
          horario: '08:30',
          descricao: 'Café da manhã',
          tipoIcone: 'cafe',
          foto: null,
        },
      ],
      
      adicionarRegistro: (horario, descricao, tipoIcone, foto) =>
        set((state) => {
          const hoje = new Date().toISOString().split('T')[0]
          return {
            registros: [
              ...state.registros,
              {
                id: Date.now().toString(),
                data: hoje,
                horario,
                descricao,
                tipoIcone,
                foto,
              },
            ],
          }
        }),
      
      removerRegistro: (id) =>
        set((state) => ({
          registros: state.registros.filter((registro) => registro.id !== id),
        })),
      
      // Hidratação - Estado Inicial
      coposBebidos: 0,
      metaDiaria: 8,
      ultimoRegistro: null,
      
      adicionarCopo: () =>
        set((state) => {
          if (state.coposBebidos < state.metaDiaria) {
            return {
              coposBebidos: state.coposBebidos + 1,
              ultimoRegistro: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            }
          }
          return state
        }),
      
      removerCopo: () =>
        set((state) => ({
          coposBebidos: Math.max(0, state.coposBebidos - 1),
        })),
      
      ajustarMeta: (valor) =>
        set((state) => {
          const novaMeta = state.metaDiaria + valor
          if (novaMeta >= 1 && novaMeta <= 15) {
            return { metaDiaria: novaMeta }
          }
          return state
        }),
    }),
    {
      name: 'alimentacao-storage', // nome para o localStorage
    }
  )
)
</file>

<file path="app/stores/atividadesStore.ts">
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'

type Atividade = {
  id: string
  nome: string
  categoria: string
  duracao: number // em minutos
  observacoes: string
  data: string
  concluida: boolean
}

interface AtividadesState {
  atividades: Atividade[]
  adicionarAtividade: (atividade: Atividade) => void
  removerAtividade: (id: string) => void
  marcarConcluida: (id: string) => void
}

export const useAtividadesStore = create<AtividadesState>()(
  persist(
    (set) => ({
      atividades: [],
      
      adicionarAtividade: (atividade) => set((state) => ({
        atividades: [...state.atividades, atividade]
      })),
      
      removerAtividade: (id) => set((state) => ({
        atividades: state.atividades.filter(a => a.id !== id)
      })),
      
      marcarConcluida: (id) => set((state) => ({
        atividades: state.atividades.map(a => 
          a.id === id ? { ...a, concluida: true } : a
        )
      })),
    }),
    {
      name: 'atividades-storage',
      storage: createJSONStorage(() => localStorage)
    }
  )
)
</file>

<file path="app/stores/autoconhecimentoStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipo para as notas
export type Nota = {
  id: string
  titulo: string
  conteudo: string
  secao: 'quem-sou' | 'meus-porques' | 'meus-padroes'
  tags: string[]
  dataCriacao: string
  dataAtualizacao: string
  imagemUrl?: string // URL para imagem âncora (opcional)
}

// Tipo para o estado da store
export type AutoconhecimentoState = {
  notas: Nota[]
  modoRefugio: boolean
  // Ações
  adicionarNota: (
    titulo: string,
    conteudo: string,
    secao: 'quem-sou' | 'meus-porques' | 'meus-padroes',
    tags?: string[],
    imagemUrl?: string
  ) => string
  atualizarNota: (
    id: string,
    dados: Partial<Omit<Nota, 'id' | 'dataCriacao'>>
  ) => void
  removerNota: (id: string) => void
  adicionarTag: (id: string, tag: string) => void
  removerTag: (id: string, tag: string) => void
  adicionarImagem: (id: string, imagemUrl: string) => void
  removerImagem: (id: string) => void
  alternarModoRefugio: () => void
  buscarNotas: (termo: string) => Nota[]
}

// Estado inicial
const estadoInicial = {
  notas: [],
  modoRefugio: false
}

// Criação da store com persistência
export const useAutoconhecimentoStore = create<AutoconhecimentoState>()(
  persist(
    (set, get) => ({
      ...estadoInicial,
      
      adicionarNota: (titulo, conteudo, secao, tags = [], imagemUrl) => {
        const id = Date.now().toString()
        const agora = new Date().toISOString()
        
        set((state) => ({
          notas: [
            ...state.notas,
            {
              id,
              titulo,
              conteudo,
              secao,
              tags,
              dataCriacao: agora,
              dataAtualizacao: agora,
              imagemUrl
            }
          ]
        }))
        
        return id
      },
      
      atualizarNota: (id, dados) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id 
            ? { 
                ...nota, 
                ...dados, 
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      removerNota: (id) => set((state) => ({
        notas: state.notas.filter((nota) => nota.id !== id)
      })),
      
      adicionarTag: (id, tag) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id && !nota.tags.includes(tag)
            ? { 
                ...nota, 
                tags: [...nota.tags, tag],
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      removerTag: (id, tag) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id
            ? { 
                ...nota, 
                tags: nota.tags.filter((t) => t !== tag),
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      adicionarImagem: (id, imagemUrl) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id
            ? { 
                ...nota, 
                imagemUrl,
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      removerImagem: (id) => set((state) => ({
        notas: state.notas.map((nota) => 
          nota.id === id
            ? { 
                ...nota, 
                imagemUrl: undefined,
                dataAtualizacao: new Date().toISOString() 
              } 
            : nota
        )
      })),
      
      alternarModoRefugio: () => set((state) => ({
        modoRefugio: !state.modoRefugio
      })),
      
      buscarNotas: (termo) => {
        const { notas } = get()
        if (!termo.trim()) return notas
        
        const termoBusca = termo.toLowerCase()
        return notas.filter((nota) => 
          nota.titulo.toLowerCase().includes(termoBusca) ||
          nota.conteudo.toLowerCase().includes(termoBusca) ||
          nota.tags.some((tag) => tag.toLowerCase().includes(termoBusca))
        )
      }
    }),
    {
      name: 'autoconhecimento-storage',
    }
  )
)
</file>

<file path="app/stores/concursosStore.ts">
import { create } from 'zustand';
import { persist, createJSONStorage, type StateStorage } from 'zustand/middleware';

export interface ConteudoProgramatico {
  disciplina: string;
  topicos: string[];
  progresso: number;
}

export interface Concurso {
  id: string;
  titulo: string;
  organizadora: string;
  dataInscricao: string;
  dataProva: string;
  edital?: string;
  status: 'planejado' | 'inscrito' | 'estudando' | 'realizado' | 'aguardando_resultado';
  conteudoProgramatico: ConteudoProgramatico[];
}

interface ConcursosStore {
  concursos: Concurso[];
  adicionarConcurso: (concurso: Omit<Concurso, 'id'>) => void;
  removerConcurso: (id: string) => void;
  atualizarConcurso: (id: string, concurso: Partial<Concurso>) => void;
  atualizarProgresso: (concursoId: string, disciplina: string, novoProgresso: number) => void;
}

export const useConcursosStore = create<ConcursosStore>()(
  persist(
    (set) => ({
      concursos: [],

      adicionarConcurso: (novoConcurso) => set((state) => ({
        concursos: [
          ...state.concursos,
          {
          ...novoConcurso,
          id: (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).substring(2, 15),
          status: novoConcurso.status || 'planejado',
          conteudoProgramatico: novoConcurso.conteudoProgramatico.map(c => ({
            ...c,
            progresso: c.progresso || 0
          }))
          }
        ]
      })),

      removerConcurso: (id) => set((state) => ({
        concursos: state.concursos.filter((c) => c.id !== id)
      })),

      atualizarConcurso: (id, dadosAtualizados) => set((state) => ({
        concursos: state.concursos.map((concurso) =>
          concurso.id === id
            ? { ...concurso, ...dadosAtualizados }
            : concurso
        )
      })),

      atualizarProgresso: (concursoId, disciplina, novoProgresso) => set((state) => ({
        concursos: state.concursos.map((concurso) =>
          concurso.id === concursoId
            ? {
                ...concurso,
                conteudoProgramatico: concurso.conteudoProgramatico.map((c) =>
                  c.disciplina === disciplina
                    ? { ...c, progresso: novoProgresso }
                    : c
                )
              }
            : concurso
        )
      }))
    }),
    {
      name: 'concursos-storage',
      storage: createJSONStorage(() => {
        if (typeof window !== 'undefined') {
          const storage: StateStorage = {
            getItem: (name) => {
              const str = localStorage.getItem(name);
              if (!str) return null;
              return JSON.parse(str);
            },
            setItem: (name, value) => {
              localStorage.setItem(name, JSON.stringify(value));
            },
            removeItem: (name) => localStorage.removeItem(name),
          };
          return storage;
        }
        return {
          getItem: () => null,
          setItem: () => {},
          removeItem: () => {},
        };
      })
    }
  )
);
</file>

<file path="app/stores/dataTransferStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

/**
 * Tipos de estado para a transferência de dados
 */
export type TransferenciaStatus = 'idle' | 'exporting' | 'importing' | 'success' | 'error';

interface DataTransferState {
  // Estado
  status: TransferenciaStatus;
  mensagem: string;
  ultimaExportacao: string | null;
  ultimaImportacao: string | null;
  
  // Ações
  setStatus: (status: TransferenciaStatus) => void;
  setMensagem: (mensagem: string) => void;
  registrarExportacao: () => void;
  registrarImportacao: (timestamp?: string) => void;
  limparHistorico: () => void;
}

/**
 * Store para gerenciar o estado da transferência de dados
 */
export const useDataTransferStore = create<DataTransferState>()(
  persist(
    (set) => ({
      // Estado inicial
      status: 'idle',
      mensagem: '',
      ultimaExportacao: null,
      ultimaImportacao: null,
      
      // Ações
      setStatus: (status) => set({ status }),
      
      setMensagem: (mensagem) => set({ mensagem }),
      
      registrarExportacao: () => set({ 
        ultimaExportacao: new Date().toISOString(),
        status: 'success',
        mensagem: 'Dados exportados com sucesso'
      }),
      
      registrarImportacao: (timestamp) => set({ 
        ultimaImportacao: timestamp || new Date().toISOString(),
        status: 'success',
        mensagem: 'Dados importados com sucesso'
      }),
      
      limparHistorico: () => set({ 
        ultimaExportacao: null,
        ultimaImportacao: null
      }),
    }),
    {
      name: 'data-transfer-storage', // nome para o localStorage
    }
  )
);
</file>

<file path="app/stores/financasStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipos
export type Categoria = {
  id: string
  nome: string
  cor: string
  icone: string
}

export type Transacao = {
  id: string
  data: string
  valor: number
  descricao: string
  categoriaId: string
  tipo: 'receita' | 'despesa'
}

export type Envelope = {
  id: string
  nome: string
  cor: string
  valorAlocado: number
  valorUtilizado: number
}

export type PagamentoRecorrente = {
  id: string
  descricao: string
  valor: number
  dataVencimento: string // dia do mês (1-31)
  categoriaId: string
  proximoPagamento: string | null // data do próximo pagamento (YYYY-MM-DD)
  pago: boolean
}

type FinancasState = {
  // Categorias
  categorias: Categoria[]
  adicionarCategoria: (nome: string, cor: string, icone: string) => void
  atualizarCategoria: (id: string, nome: string, cor: string, icone: string) => void
  removerCategoria: (id: string) => void
  
  // Transações
  transacoes: Transacao[]
  adicionarTransacao: (data: string, valor: number, descricao: string, categoriaId: string, tipo: 'receita' | 'despesa') => void
  removerTransacao: (id: string) => void
  
  // Envelopes
  envelopes: Envelope[]
  adicionarEnvelope: (nome: string, cor: string, valorAlocado: number) => void
  atualizarEnvelope: (id: string, nome: string, cor: string, valorAlocado: number) => void
  removerEnvelope: (id: string) => void
  registrarGastoEnvelope: (id: string, valor: number) => void
  
  // Pagamentos Recorrentes
  pagamentosRecorrentes: PagamentoRecorrente[]
  adicionarPagamentoRecorrente: (descricao: string, valor: number, dataVencimento: string, categoriaId: string) => void
  atualizarPagamentoRecorrente: (id: string, descricao: string, valor: number, dataVencimento: string, categoriaId: string) => void
  removerPagamentoRecorrente: (id: string) => void
  marcarPagamentoComoPago: (id: string, pago: boolean) => void
  atualizarProximoPagamento: (id: string, data: string) => void
}

// Cores predefinidas para categorias (com alto contraste)
const CORES_CATEGORIAS = [
  '#FF5252', // Vermelho
  '#4CAF50', // Verde
  '#2196F3', // Azul
  '#FFC107', // Amarelo
  '#9C27B0'  // Roxo
]

// Ícones predefinidos para categorias
const ICONES_CATEGORIAS = [
  'home',    // Casa
  'shopping-cart', // Compras
  'utensils', // Alimentação
  'car',     // Transporte
  'heart'    // Saúde
]

export const useFinancasStore = create<FinancasState>()(
  persist(
    (set) => ({
      // Categorias - Estado Inicial
      categorias: [
        { id: '1', nome: 'Moradia', cor: CORES_CATEGORIAS[0], icone: 'home' },
        { id: '2', nome: 'Alimentação', cor: CORES_CATEGORIAS[1], icone: 'utensils' },
        { id: '3', nome: 'Transporte', cor: CORES_CATEGORIAS[2], icone: 'car' },
        { id: '4', nome: 'Saúde', cor: CORES_CATEGORIAS[3], icone: 'heart' },
        { id: '5', nome: 'Lazer', cor: CORES_CATEGORIAS[4], icone: 'music' },
      ],
      
      adicionarCategoria: (nome, cor, icone) => 
        set((state) => {
          // Limitar a 5 categorias
          if (state.categorias.length >= 5) return state
          
          return {
            categorias: [
              ...state.categorias,
              {
                id: Date.now().toString(),
                nome,
                cor,
                icone,
              },
            ],
          }
        }),
      
      atualizarCategoria: (id, nome, cor, icone) =>
        set((state) => ({
          categorias: state.categorias.map((categoria) =>
            categoria.id === id ? { ...categoria, nome, cor, icone } : categoria
          ),
        })),
      
      removerCategoria: (id) =>
        set((state) => ({
          categorias: state.categorias.filter((categoria) => categoria.id !== id),
          // Remover transações e pagamentos relacionados à categoria
          transacoes: state.transacoes.filter((transacao) => transacao.categoriaId !== id),
          pagamentosRecorrentes: state.pagamentosRecorrentes.filter(
            (pagamento) => pagamento.categoriaId !== id
          ),
        })),
      
      // Transações - Estado Inicial
      transacoes: [],
      
      adicionarTransacao: (data, valor, descricao, categoriaId, tipo) =>
        set((state) => ({
          transacoes: [
            ...state.transacoes,
            {
              id: Date.now().toString(),
              data,
              valor,
              descricao,
              categoriaId,
              tipo,
            },
          ],
        })),
      
      removerTransacao: (id) =>
        set((state) => ({
          transacoes: state.transacoes.filter((transacao) => transacao.id !== id),
        })),
      
      // Envelopes - Estado Inicial
      envelopes: [
        { id: '1', nome: 'Emergências', cor: '#FF5252', valorAlocado: 500, valorUtilizado: 0 },
        { id: '2', nome: 'Férias', cor: '#2196F3', valorAlocado: 300, valorUtilizado: 0 },
        { id: '3', nome: 'Presentes', cor: '#4CAF50', valorAlocado: 100, valorUtilizado: 0 },
      ],
      
      adicionarEnvelope: (nome, cor, valorAlocado) =>
        set((state) => ({
          envelopes: [
            ...state.envelopes,
            {
              id: Date.now().toString(),
              nome,
              cor,
              valorAlocado,
              valorUtilizado: 0,
            },
          ],
        })),
      
      atualizarEnvelope: (id, nome, cor, valorAlocado) =>
        set((state) => ({
          envelopes: state.envelopes.map((envelope) =>
            envelope.id === id ? { ...envelope, nome, cor, valorAlocado } : envelope
          ),
        })),
      
      removerEnvelope: (id) =>
        set((state) => ({
          envelopes: state.envelopes.filter((envelope) => envelope.id !== id),
        })),
      
      registrarGastoEnvelope: (id, valor) =>
        set((state) => ({
          envelopes: state.envelopes.map((envelope) =>
            envelope.id === id
              ? { ...envelope, valorUtilizado: envelope.valorUtilizado + valor }
              : envelope
          ),
        })),
      
      // Pagamentos Recorrentes - Estado Inicial
      pagamentosRecorrentes: [],
      
      adicionarPagamentoRecorrente: (descricao, valor, dataVencimento, categoriaId) => {
        const hoje = new Date()
        const dia = parseInt(dataVencimento)
        const proximoPagamento = new Date(hoje.getFullYear(), hoje.getMonth(), dia)
        
        // Se o dia já passou este mês, avançar para o próximo mês
        if (proximoPagamento.getDate() < hoje.getDate()) {
          proximoPagamento.setMonth(proximoPagamento.getMonth() + 1)
        }
        
        return set((state) => ({
          pagamentosRecorrentes: [
            ...state.pagamentosRecorrentes,
            {
              id: Date.now().toString(),
              descricao,
              valor,
              dataVencimento,
              categoriaId,
              proximoPagamento: proximoPagamento.toISOString().split('T')[0],
              pago: false,
            },
          ],
        }))
      },
      
      atualizarPagamentoRecorrente: (id, descricao, valor, dataVencimento, categoriaId) =>
        set((state) => ({
          pagamentosRecorrentes: state.pagamentosRecorrentes.map((pagamento) =>
            pagamento.id === id
              ? { ...pagamento, descricao, valor, dataVencimento, categoriaId }
              : pagamento
          ),
        })),
      
      removerPagamentoRecorrente: (id) =>
        set((state) => ({
          pagamentosRecorrentes: state.pagamentosRecorrentes.filter(
            (pagamento) => pagamento.id !== id
          ),
        })),
      
      marcarPagamentoComoPago: (id, pago) =>
        set((state) => {
          const pagamentos = state.pagamentosRecorrentes.map((pagamento) => {
            if (pagamento.id !== id) return pagamento
            
            if (pago) {
              // Se marcado como pago, calcular o próximo pagamento
              const dataAtual = new Date()
              const dia = parseInt(pagamento.dataVencimento)
              let proximoMes = dataAtual.getMonth() + 1
              let proximoAno = dataAtual.getFullYear()
              
              if (proximoMes > 11) {
                proximoMes = 0
                proximoAno++
              }
              
              const proximoPagamento = new Date(proximoAno, proximoMes, dia)
              
              return {
                ...pagamento,
                pago,
                proximoPagamento: proximoPagamento.toISOString().split('T')[0],
              }
            }
            
            return { ...pagamento, pago }
          })
          
          return { pagamentosRecorrentes: pagamentos }
        }),
      
      atualizarProximoPagamento: (id, data) =>
        set((state) => ({
          pagamentosRecorrentes: state.pagamentosRecorrentes.map((pagamento) =>
            pagamento.id === id ? { ...pagamento, proximoPagamento: data } : pagamento
          ),
        })),
    }),
    {
      name: 'financas-storage', // nome para o localStorage
    }
  )
)
</file>

<file path="app/stores/hiperfocosStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Tipos
export type Tarefa = {
  id: string
  texto: string
  concluida: boolean
  cor?: string
}

export type Hiperfoco = {
  id: string
  titulo: string
  descricao: string
  tarefas: Tarefa[]
  subTarefas: Record<string, Tarefa[]> // Id da tarefa pai -> lista de sub-tarefas
  cor: string
  dataCriacao: string
  tempoLimite?: number // em minutos, opcional
}

export type SessaoAlternancia = {
  id: string
  titulo: string
  hiperfocoAtual: string | null // ID do hiperfoco ativo
  hiperfocoAnterior: string | null // ID do hiperfoco anterior
  tempoInicio: string
  duracaoEstimada: number // em minutos
  concluida: boolean
}

type HiperfocosState = {
  // Hiperfocos
  hiperfocos: Hiperfoco[]
  adicionarHiperfoco: (titulo: string, descricao: string, cor: string, tempoLimite?: number) => string
  atualizarHiperfoco: (id: string, titulo: string, descricao: string, cor: string, tempoLimite?: number) => void
  removerHiperfoco: (id: string) => void
  
  // Tarefas
  adicionarTarefa: (hiperfocoId: string, texto: string) => string
  atualizarTarefa: (hiperfocoId: string, tarefaId: string, texto: string) => void
  toggleTarefaConcluida: (hiperfocoId: string, tarefaId: string) => void
  removerTarefa: (hiperfocoId: string, tarefaId: string) => void
  
  // Sub-tarefas
  adicionarSubTarefa: (hiperfocoId: string, tarefaPaiId: string, texto: string) => string
  atualizarSubTarefa: (hiperfocoId: string, tarefaPaiId: string, subTarefaId: string, texto: string) => void
  toggleSubTarefaConcluida: (hiperfocoId: string, tarefaPaiId: string, subTarefaId: string) => void
  removerSubTarefa: (hiperfocoId: string, tarefaPaiId: string, subTarefaId: string) => void
  
  // Alternância
  sessoes: SessaoAlternancia[]
  adicionarSessao: (titulo: string, hiperfocoId: string, duracaoEstimada: number) => string
  atualizarSessao: (id: string, titulo: string, hiperfocoId: string, duracaoEstimada: number) => void
  concluirSessao: (id: string) => void
  removerSessao: (id: string) => void
  alternarHiperfoco: (sessaoId: string, novoHiperfocoId: string) => void
}

// Cores predefinidas para hiperfocos
export const CORES_HIPERFOCOS = [
  '#FF5252', // Vermelho
  '#4CAF50', // Verde
  '#2196F3', // Azul
  '#FF9800', // Laranja
  '#9C27B0', // Roxo
  '#795548', // Marrom
  '#607D8B'  // Azul acinzentado
]

export const useHiperfocosStore = create<HiperfocosState>()(
  persist(
    (set, get) => ({
      // Estado inicial
      hiperfocos: [],
      sessoes: [],
      
      // Ações para hiperfocos
      adicionarHiperfoco: (titulo, descricao, cor, tempoLimite) => {
        const id = Date.now().toString()
        set((state) => ({
          hiperfocos: [
            ...state.hiperfocos,
            {
              id,
              titulo,
              descricao,
              tarefas: [],
              subTarefas: {},
              cor,
              dataCriacao: new Date().toISOString(),
              tempoLimite
            }
          ]
        }))
        return id
      },
      
      atualizarHiperfoco: (id, titulo, descricao, cor, tempoLimite) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) =>
            hiperfoco.id === id
              ? { ...hiperfoco, titulo, descricao, cor, tempoLimite }
              : hiperfoco
          )
        }))
      },
      
      removerHiperfoco: (id) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.filter((hiperfoco) => hiperfoco.id !== id),
          // Também remover as sessões associadas a este hiperfoco
          sessoes: state.sessoes.filter(
            (sessao) => sessao.hiperfocoAtual !== id && sessao.hiperfocoAnterior !== id
          )
        }))
      },
      
      // Ações para tarefas
      adicionarTarefa: (hiperfocoId, texto) => {
        const tarefaId = Date.now().toString()
        
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                tarefas: [
                  ...hiperfoco.tarefas,
                  {
                    id: tarefaId,
                    texto,
                    concluida: false
                  }
                ],
                // Inicializar a entrada de subTarefas para esta tarefa
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaId]: []
                }
              }
            }
            return hiperfoco
          })
        }))
        
        return tarefaId
      },
      
      atualizarTarefa: (hiperfocoId, tarefaId, texto) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                tarefas: hiperfoco.tarefas.map((tarefa) =>
                  tarefa.id === tarefaId ? { ...tarefa, texto } : tarefa
                )
              }
            }
            return hiperfoco
          })
        }))
      },
      
      toggleTarefaConcluida: (hiperfocoId, tarefaId) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                tarefas: hiperfoco.tarefas.map((tarefa) =>
                  tarefa.id === tarefaId
                    ? { ...tarefa, concluida: !tarefa.concluida }
                    : tarefa
                )
              }
            }
            return hiperfoco
          })
        }))
      },
      
      removerTarefa: (hiperfocoId, tarefaId) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              // Filtrar a tarefa e também remover suas subtarefas
              const { [tarefaId]: subTarefasARemover, ...restoSubTarefas } = hiperfoco.subTarefas
              
              return {
                ...hiperfoco,
                tarefas: hiperfoco.tarefas.filter((tarefa) => tarefa.id !== tarefaId),
                subTarefas: restoSubTarefas
              }
            }
            return hiperfoco
          })
        }))
      },
      
      // Ações para sub-tarefas
      adicionarSubTarefa: (hiperfocoId, tarefaPaiId, texto) => {
        const subTarefaId = Date.now().toString()
        
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaPaiId]: [
                    ...(hiperfoco.subTarefas[tarefaPaiId] || []),
                    {
                      id: subTarefaId,
                      texto,
                      concluida: false
                    }
                  ]
                }
              }
            }
            return hiperfoco
          })
        }))
        
        return subTarefaId
      },
      
      atualizarSubTarefa: (hiperfocoId, tarefaPaiId, subTarefaId, texto) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaPaiId]: (hiperfoco.subTarefas[tarefaPaiId] || []).map((subTarefa) =>
                    subTarefa.id === subTarefaId ? { ...subTarefa, texto } : subTarefa
                  )
                }
              }
            }
            return hiperfoco
          })
        }))
      },
      
      toggleSubTarefaConcluida: (hiperfocoId, tarefaPaiId, subTarefaId) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaPaiId]: (hiperfoco.subTarefas[tarefaPaiId] || []).map((subTarefa) =>
                    subTarefa.id === subTarefaId
                      ? { ...subTarefa, concluida: !subTarefa.concluida }
                      : subTarefa
                  )
                }
              }
            }
            return hiperfoco
          })
        }))
      },
      
      removerSubTarefa: (hiperfocoId, tarefaPaiId, subTarefaId) => {
        set((state) => ({
          hiperfocos: state.hiperfocos.map((hiperfoco) => {
            if (hiperfoco.id === hiperfocoId) {
              return {
                ...hiperfoco,
                subTarefas: {
                  ...hiperfoco.subTarefas,
                  [tarefaPaiId]: (hiperfoco.subTarefas[tarefaPaiId] || []).filter(
                    (subTarefa) => subTarefa.id !== subTarefaId
                  )
                }
              }
            }
            return hiperfoco
          })
        }))
      },
      
      // Ações para sessões de alternância
      adicionarSessao: (titulo, hiperfocoId, duracaoEstimada) => {
        const id = Date.now().toString()
        
        set((state) => ({
          sessoes: [
            ...state.sessoes,
            {
              id,
              titulo,
              hiperfocoAtual: hiperfocoId,
              hiperfocoAnterior: null,
              tempoInicio: new Date().toISOString(),
              duracaoEstimada,
              concluida: false
            }
          ]
        }))
        
        return id
      },
      
      atualizarSessao: (id, titulo, hiperfocoId, duracaoEstimada) => {
        set((state) => ({
          sessoes: state.sessoes.map((sessao) =>
            sessao.id === id
              ? { ...sessao, titulo, hiperfocoAtual: hiperfocoId, duracaoEstimada }
              : sessao
          )
        }))
      },
      
      concluirSessao: (id) => {
        set((state) => ({
          sessoes: state.sessoes.map((sessao) =>
            sessao.id === id ? { ...sessao, concluida: true } : sessao
          )
        }))
      },
      
      removerSessao: (id) => {
        set((state) => ({
          sessoes: state.sessoes.filter((sessao) => sessao.id !== id)
        }))
      },
      
      alternarHiperfoco: (sessaoId, novoHiperfocoId) => {
        set((state) => ({
          sessoes: state.sessoes.map((sessao) => {
            if (sessao.id === sessaoId) {
              return {
                ...sessao,
                hiperfocoAnterior: sessao.hiperfocoAtual,
                hiperfocoAtual: novoHiperfocoId,
                tempoInicio: new Date().toISOString()
              }
            }
            return sessao
          })
        }))
      }
    }),
    {
      name: 'hiperfocos-storage' // nome para o localStorage
    }
  )
)
</file>

<file path="app/stores/historicoSimuladosStore.ts">
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware'; // Importar persist middleware

// --- Tipos ---
interface Tentativa {
  timestamp: string; // ISO string
  acertos: number;
  percentual: number;
}

interface SimuladoHistoricoEntry {
  titulo: string;
  totalQuestoes: number;
  tentativas: Tentativa[];
}

// O estado principal será um objeto onde a chave é o identificador único
// Ex: "Simulado X|40"
type HistoricoSimuladosStateData = Record<string, SimuladoHistoricoEntry>;

interface HistoricoSimuladosState {
  historico: HistoricoSimuladosStateData;
  adicionarTentativa: (
    identificador: string,
    titulo: string,
    totalQuestoes: number,
    acertos: number,
    percentual: number
  ) => void;
  // Adicionar mais seletores/ações conforme necessário (ex: getMelhorPontuacao, getUltimaPontuacao)
}

// --- Store ---
// Usaremos persistência local para o histórico também, alinhado com as regras
export const useHistoricoSimuladosStore = create<HistoricoSimuladosState>()(
  persist(
    (set, get) => ({
      historico: {},

      adicionarTentativa: (identificador, titulo, totalQuestoes, acertos, percentual) => {
        set((state) => {
          const historicoAtual = { ...state.historico };
          const novaTentativa: Tentativa = {
            timestamp: new Date().toISOString(),
            acertos,
            percentual,
          };

          // Se o simulado já existe no histórico, adiciona a nova tentativa
          if (historicoAtual[identificador]) {
            historicoAtual[identificador] = {
              ...historicoAtual[identificador],
              tentativas: [...historicoAtual[identificador].tentativas, novaTentativa],
            };
          } else {
            // Se é a primeira vez, cria a entrada
            historicoAtual[identificador] = {
              titulo,
              totalQuestoes,
              tentativas: [novaTentativa],
            };
          }

          return { historico: historicoAtual };
        });
      },

      // --- Exemplo de Seletores (podem ser adicionados depois, na criação da UI) ---
      /*
      getMelhorPontuacao: (identificador: string): number | null => {
        const entry = get().historico[identificador];
        if (!entry || entry.tentativas.length === 0) return null;
        return Math.max(...entry.tentativas.map(t => t.percentual));
      },

      getUltimaPontuacao: (identificador: string): number | null => {
        const entry = get().historico[identificador];
        if (!entry || entry.tentativas.length === 0) return null;
        // Assume que as tentativas são adicionadas em ordem cronológica
        return entry.tentativas[entry.tentativas.length - 1].percentual;
      },
      */
    }),
    {
      name: 'historico-simulados-storage', // Nome da chave no localStorage
      storage: createJSONStorage(() => localStorage), // Usar localStorage
    }
  )
);

// --- Helper para criar o identificador ---
export const criarIdentificadorSimulado = (titulo: string, totalQuestoes: number): string => {
  // Simples concatenação, pode ser melhorado se necessário (ex: hash)
  return `${titulo}|${totalQuestoes}`;
};
</file>

<file path="app/stores/painelDiaStore.ts">
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'

export type BlocoTempo = {
  id: string
  hora: string
  atividade: string
  categoria: 'inicio' | 'alimentacao' | 'estudos' | 'saude' | 'lazer' | 'nenhuma'
}

// Dados de exemplo para demonstração
const blocosIniciais: BlocoTempo[] = [
  { id: '1', hora: '08:00', atividade: 'Café da manhã', categoria: 'alimentacao' },
  { id: '2', hora: '09:00', atividade: 'Estudar matemática', categoria: 'estudos' },
  { id: '3', hora: '10:00', atividade: 'Pausa para alongamento', categoria: 'saude' },
  { id: '4', hora: '11:00', atividade: 'Continuar estudos', categoria: 'estudos' },
  { id: '5', hora: '12:00', atividade: 'Almoço', categoria: 'alimentacao' },
  { id: '6', hora: '13:00', atividade: 'Descanso breve', categoria: 'lazer' },
  { id: '7', hora: '14:00', atividade: 'Reunião online', categoria: 'estudos' },
  { id: '8', hora: '15:00', atividade: 'Exercício físico', categoria: 'saude' },
  { id: '9', hora: '16:00', atividade: 'Leitura', categoria: 'lazer' },
  { id: '10', hora: '17:00', atividade: 'Organizar materiais', categoria: 'estudos' },
  { id: '11', hora: '18:00', atividade: 'Jantar', categoria: 'alimentacao' },
  { id: '12', hora: '19:00', atividade: 'Tempo livre', categoria: 'lazer' },
]

interface PainelDiaState {
  blocos: BlocoTempo[]
  editarAtividade: (id: string, atividade: string) => void
  editarCategoria: (id: string, categoria: BlocoTempo['categoria']) => void
  adicionarBloco: (bloco: BlocoTempo) => void
  removerBloco: (id: string) => void
}

export const usePainelDiaStore = create<PainelDiaState>()(
  persist(
    (set) => ({
      blocos: blocosIniciais,
      
      // Editar a atividade de um bloco
      editarAtividade: (id, atividade) => set((state) => ({
        blocos: state.blocos.map(bloco => 
          bloco.id === id ? { ...bloco, atividade } : bloco
        )
      })),
      
      // Editar a categoria de um bloco
      editarCategoria: (id, categoria) => set((state) => ({
        blocos: state.blocos.map(bloco => 
          bloco.id === id ? { ...bloco, categoria } : bloco
        )
      })),
      
      // Adicionar um novo bloco
      adicionarBloco: (bloco) => set((state) => ({
        blocos: [...state.blocos, bloco]
      })),
      
      // Remover um bloco
      removerBloco: (id) => set((state) => ({
        blocos: state.blocos.filter(bloco => bloco.id !== id)
      })),
    }),
    {
      name: 'painel-dia-storage',
      storage: createJSONStorage(() => localStorage)
    }
  )
)
</file>

<file path="app/stores/perfilStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type PreferenciasVisuais = {
  altoContraste: boolean
  reducaoEstimulos: boolean
  textoGrande: boolean
}

export type MetasDiarias = {
  horasSono: number         // Horas ideais de sono
  tarefasPrioritarias: number // Número de tarefas prioritárias
  coposAgua: number         // Copos de água por dia
  pausasProgramadas: number // Número de pausas programadas
}

export type PerfilState = {
  nome: string
  preferenciasVisuais: PreferenciasVisuais
  metasDiarias: MetasDiarias
  notificacoesAtivas: boolean
  pausasAtivas: boolean
  // Ações
  atualizarNome: (nome: string) => void
  atualizarPreferenciasVisuais: (preferencias: Partial<PreferenciasVisuais>) => void
  atualizarMetasDiarias: (metas: Partial<MetasDiarias>) => void
  alternarNotificacoes: () => void
  alternarPausas: () => void
  resetarPerfil: () => void
}

const defaultState = {
  nome: 'Usuário',
  preferenciasVisuais: {
    altoContraste: false,
    reducaoEstimulos: false,
    textoGrande: false
  },
  metasDiarias: {
    horasSono: 8,
    tarefasPrioritarias: 3,
    coposAgua: 8,
    pausasProgramadas: 4
  },
  notificacoesAtivas: true,
  pausasAtivas: true
}

export const usePerfilStore = create<PerfilState>()(
  persist(
    (set) => ({
      ...defaultState,
      
      atualizarNome: (nome) => set({
        nome
      }),
      
      atualizarPreferenciasVisuais: (preferencias) => set((state) => ({
        preferenciasVisuais: {
          ...state.preferenciasVisuais,
          ...preferencias
        }
      })),
      
      atualizarMetasDiarias: (metas) => set((state) => ({
        metasDiarias: {
          ...state.metasDiarias,
          ...metas
        }
      })),
      
      alternarNotificacoes: () => set((state) => ({
        notificacoesAtivas: !state.notificacoesAtivas
      })),
      
      alternarPausas: () => set((state) => ({
        pausasAtivas: !state.pausasAtivas
      })),
      
      resetarPerfil: () => set(defaultState)
    }),
    {
      name: 'perfil-storage',
    }
  )
)
</file>

<file path="app/stores/pomodoroStore.ts">
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'

type CicloPomodoro = 'foco' | 'pausa' | 'longapausa'

interface ConfiguracaoPomodoro {
  tempoFoco: number        // em minutos
  tempoPausa: number       // em minutos
  tempoLongapausa: number  // em minutos
  ciclosAntesLongapausa: number
}

interface PomodoroState {
  // Configuração do pomodoro
  configuracao: ConfiguracaoPomodoro
  atualizarConfiguracao: (config: Partial<ConfiguracaoPomodoro>) => void
  
  // Estatísticas
  ciclosCompletos: number
  incrementarCiclosCompletos: () => void
  resetarCiclosCompletos: () => void
}

export const usePomodoroStore = create<PomodoroState>()(
  persist(
    (set) => ({
      // Configuração padrão
      configuracao: {
        tempoFoco: 25,
        tempoPausa: 5,
        tempoLongapausa: 15,
        ciclosAntesLongapausa: 4,
      },
      
      // Atualizar configuração
      atualizarConfiguracao: (config) => set((state) => ({
        configuracao: {
          ...state.configuracao,
          ...config,
        }
      })),
      
      // Estatísticas
      ciclosCompletos: 0,
      
      incrementarCiclosCompletos: () => set((state) => ({
        ciclosCompletos: state.ciclosCompletos + 1
      })),
      
      resetarCiclosCompletos: () => set({
        ciclosCompletos: 0
      }),
    }),
    {
      name: 'pomodoro-storage',
      storage: createJSONStorage(() => localStorage)
    }
  )
)
</file>

<file path="app/stores/prioridadesStore.ts">
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'

export type Prioridade = {
  id: string;
  texto: string;
  concluida: boolean;
  data: string; // formato ISO: YYYY-MM-DD
  tipo?: 'geral' | 'concurso'; // Novo campo para tipo de prioridade
  origemId?: string; // Novo campo para ID da origem (ex: concursoId)
}

interface PrioridadesState {
  prioridades: Prioridade[];
  // Atualiza a assinatura para aceitar os novos campos opcionais
  adicionarPrioridade: (prioridade: Omit<Prioridade, 'id' | 'data' | 'concluida'> & { concluida?: boolean }) => void;
  editarPrioridade: (id: string, texto: string) => void;
  removerPrioridade: (id: string) => void;
  toggleConcluida: (id: string) => void
  getHistoricoPorData: (data?: string) => Prioridade[]
  getDatasPrioridades: () => string[]
}

export const usePrioridadesStore = create<PrioridadesState>()(
  persist(
    (set, get) => ({
      prioridades: [],

      adicionarPrioridade: (novaPrioridade) => set((state) => {
        // Obter a data atual em formato ISO (YYYY-MM-DD)
        const dataAtual = new Date().toISOString().split('T')[0];
        const prioridadeCompleta: Prioridade = {
          id: crypto.randomUUID(),
          texto: novaPrioridade.texto,
          concluida: novaPrioridade.concluida ?? false, // Define concluida como false por padrão
          data: dataAtual,
          tipo: novaPrioridade.tipo || 'geral', // Define tipo como 'geral' por padrão
          origemId: novaPrioridade.origemId, // Adiciona origemId se fornecido
        };

        return {
          prioridades: [...state.prioridades, prioridadeCompleta],
        };
      }),

      editarPrioridade: (id, texto) => set((state) => ({
        prioridades: state.prioridades.map(p => 
          p.id === id ? { ...p, texto } : p
        )
      })),
      
      removerPrioridade: (id) => set((state) => ({
        prioridades: state.prioridades.filter(p => p.id !== id)
      })),
      
      toggleConcluida: (id) => set((state) => ({
        prioridades: state.prioridades.map(p => 
          p.id === id ? { ...p, concluida: !p.concluida } : p
        )
      })),
      
      getHistoricoPorData: (data) => {
        const dataFiltro = data || new Date().toISOString().split('T')[0]
        return get().prioridades.filter(p => p.data === dataFiltro)
      },
      
      getDatasPrioridades: () => {
        // Retorna array de datas únicas (sem repetições)
        const datas = get().prioridades.map(p => p.data)
        return Array.from(new Set(datas)).sort().reverse() // Mais recentes primeiro
      }
    }),
    {
      name: 'prioridades-diarias',
      storage: createJSONStorage(() => localStorage),
    }
  )
)
</file>

<file path="app/stores/questoesStore.ts">
import { create } from 'zustand';
import { persist, createJSONStorage, type StateStorage } from 'zustand/middleware';

export interface Alternativa {
  id: string;
  texto: string;
  correta: boolean;
}

export interface Questao {
  id: string;
  concursoId?: string; // Para vincular a um concurso específico, se aplicável
  disciplina: string;
  topico: string;
  enunciado: string;
  alternativas: Alternativa[];
  respostaCorreta: string; // ID da alternativa correta
  justificativa?: string;
  nivelDificuldade?: 'facil' | 'medio' | 'dificil';
  ano?: number;
  banca?: string;
  tags?: string[];
  respondida?: boolean; // Para controle em simulados
  respostaUsuario?: string; // ID da alternativa escolhida pelo usuário
  acertou?: boolean; // Resultado da resposta do usuário
}

interface QuestoesStore {
  questoes: Questao[];
  adicionarQuestao: (questao: Omit<Questao, 'id'>) => string; // Retorna o ID da nova questão
  adicionarQuestoes: (concursoId: string, questoes: Omit<Questao, 'id'>[]) => void;
  removerQuestao: (id: string) => void;
  atualizarQuestao: (id: string, questao: Partial<Questao>) => void;
  importarQuestoes: (novasQuestoes: Omit<Questao, 'id'>[]) => void;
  buscarQuestoesPorConcurso: (concursoId: string) => Questao[];
  buscarQuestoesPorDisciplina: (disciplina: string) => Questao[];
  // Adicionar mais métodos conforme necessário (ex: buscar por tag, tópico, etc.)
}

export const useQuestoesStore = create<QuestoesStore>()(
  persist(
    (set, get) => ({
      questoes: [],

      adicionarQuestao: (novaQuestao) => {
        const id = crypto.randomUUID();
        const questaoCompleta: Questao = {
          ...novaQuestao,
          id,
          // Preserva os IDs das alternativas vindos do formulário
          alternativas: novaQuestao.alternativas,
          // Definir valores padrão se necessário
          respondida: false,
        };
        set((state) => ({
          questoes: [...state.questoes, questaoCompleta]
        }));
        return id;
      },

      adicionarQuestoes: (concursoId, questoes) => {
        const questoesCompletas = questoes.map(q => ({
          ...q,
          id: crypto.randomUUID(),
          concursoId,
          alternativas: q.alternativas,
          respondida: false,
        }));
        set((state) => ({
          questoes: [...state.questoes, ...questoesCompletas]
        }));
      },

      removerQuestao: (id) => set((state) => ({
        questoes: state.questoes.filter((q) => q.id !== id)
      })),

      atualizarQuestao: (id, dadosAtualizados) => set((state) => ({
        questoes: state.questoes.map((questao) =>
          questao.id === id
            ? { ...questao, ...dadosAtualizados }
            : questao
        )
      })),

      importarQuestoes: (novasQuestoes) => {
        const questoesCompletas = novasQuestoes.map(q => ({
          ...q,
          id: crypto.randomUUID(),
          // Preserva os IDs das alternativas vindos da importação
          // Assume que o JSON importado já tem IDs únicos para alternativas,
          // ou que a estrutura importada não depende desses IDs internos.
          // Se o JSON importado não tiver IDs, eles precisariam ser gerados aqui.
          // Por simplicidade, vamos assumir que eles existem ou não são necessários para a lógica de gabarito.
          alternativas: q.alternativas,
          respondida: false,
        }));
        set((state) => ({
          questoes: [...state.questoes, ...questoesCompletas]
        }));
      },

      buscarQuestoesPorConcurso: (concursoId) => {
        return get().questoes.filter(q => q.concursoId === concursoId);
      },

      buscarQuestoesPorDisciplina: (disciplina) => {
        return get().questoes.filter(q => q.disciplina === disciplina);
      },

    }),
    {
      name: 'questoes-store', // Nome específico para este store
      storage: createJSONStorage(() => {
        // Reutiliza a lógica de storage, garantindo que funcione no client-side
        if (typeof window !== 'undefined') {
          const storage: StateStorage = {
            getItem: (name) => {
              const str = localStorage.getItem(name);
              if (!str) return null;
              // Adiciona try-catch para robustez na desserialização
              try {
                return JSON.parse(str);
              } catch (e) {
                console.error(`Erro ao parsear ${name} do localStorage`, e);
                return null;
              }
            },
            setItem: (name, value) => {
              localStorage.setItem(name, JSON.stringify(value));
            },
            removeItem: (name) => localStorage.removeItem(name),
          };
          return storage;
        }
        // Fallback para SSR ou ambientes sem window
        return {
          getItem: () => null,
          setItem: () => {},
          removeItem: () => {},
        };
      })
    }
  )
);
</file>

<file path="app/stores/receitasStore.ts">
// stores/receitasStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface Ingrediente {
  nome: string;
  quantidade: number;
  unidade: string;
}

export interface Receita { // Exporting the interface
  id: string;
  nome: string;
  descricao: string;
  categorias: string[];
  tags: string[];
  tempoPreparo: number;
  porcoes: number;
  calorias: string;
  imagem: string; // Store image URL or base64 string
  ingredientes: Ingrediente[];
  passos: string[];
}

interface ReceitasStore {
  receitas: Receita[];
  adicionarReceita: (receita: Receita) => void;
  atualizarReceita: (receita: Receita) => void;
  removerReceita: (id: string) => void;
  obterReceitaPorId: (id: string) => Receita | undefined;
  favoritos: string[];
  alternarFavorito: (id: string) => void;
}

export const useReceitasStore = create<ReceitasStore>()(
  persist(
    (set, get) => ({
      receitas: [],
      adicionarReceita: (receita) =>
        set((state) => ({ receitas: [...state.receitas, receita] })),
      atualizarReceita: (receita) =>
        set((state) => ({
          receitas: state.receitas.map((r) =>
            r.id === receita.id ? receita : r
          ),
        })),
      removerReceita: (id) =>
        set((state) => ({
          receitas: state.receitas.filter((r) => r.id !== id),
        })),
      obterReceitaPorId: (id) => {
        return get().receitas.find((r) => r.id === id);
      },
      favoritos: [],
      alternarFavorito: (id) =>
        set((state) => {
          const { favoritos } = state;
          if (favoritos.includes(id)) {
            return { favoritos: favoritos.filter((fav) => fav !== id) };
          } else {
            return { favoritos: [...favoritos, id] };
          }
        }),
    }),
    {
      name: 'receitas-storage', // name of the item in the storage (must be unique)
      // storage: createJSONStorage(() => localStorage), // (optional) by default, 'localStorage' is used
    }
  )
);
</file>

<file path="app/stores/registroEstudosStore.ts">
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'

export type SessaoEstudo = {
  id: string
  titulo: string
  descricao: string
  duracao: number // em minutos
  data: string
  completo: boolean
}

// Dados iniciais para demonstração
const sessoesIniciais: SessaoEstudo[] = [
  {
    id: '1',
    titulo: 'Matemática - Álgebra Linear',
    descricao: 'Revisão de matrizes e determinantes',
    duracao: 45,
    data: '2023-03-03',
    completo: true,
  },
  {
    id: '2',
    titulo: 'Inglês - Vocabulário',
    descricao: 'Praticar vocabulário técnico',
    duracao: 30,
    data: '2023-03-04',
    completo: false,
  },
]

interface RegistroEstudosState {
  sessoes: SessaoEstudo[]
  adicionarSessao: (sessao: Omit<SessaoEstudo, 'id' | 'data' | 'completo'>) => void
  removerSessao: (id: string) => void
  alternarCompletar: (id: string) => void
  editarSessao: (id: string, dados: Pick<SessaoEstudo, 'titulo' | 'descricao' | 'duracao'>) => void
}

export const useRegistroEstudosStore = create<RegistroEstudosState>()(
  persist(
    (set) => ({
      sessoes: sessoesIniciais,
      
      adicionarSessao: (sessao) => set((state) => {
        const hoje = new Date().toISOString().split('T')[0]
        
        return {
          sessoes: [
            ...state.sessoes,
            {
              id: Date.now().toString(),
              titulo: sessao.titulo,
              descricao: sessao.descricao,
              duracao: sessao.duracao,
              data: hoje,
              completo: false,
            },
          ],
        }
      }),
      
      removerSessao: (id) => set((state) => ({
        sessoes: state.sessoes.filter((sessao) => sessao.id !== id)
      })),
      
      alternarCompletar: (id) => set((state) => ({
        sessoes: state.sessoes.map((sessao) =>
          sessao.id === id ? { ...sessao, completo: !sessao.completo } : sessao
        )
      })),
      
      editarSessao: (id, dados) => set((state) => ({
        sessoes: state.sessoes.map((sessao) =>
          sessao.id === id
            ? {
                ...sessao,
                titulo: dados.titulo,
                descricao: dados.descricao,
                duracao: dados.duracao,
              }
            : sessao
        )
      })),
    }),
    {
      name: 'registro-estudos-storage',
      storage: createJSONStorage(() => localStorage)
    }
  )
)
</file>

<file path="app/stores/simuladoStore.ts">
import { create } from 'zustand';
// Importar store e helper do histórico
import { useHistoricoSimuladosStore, criarIdentificadorSimulado } from './historicoSimuladosStore';

// Define a estrutura baseada no psimulado.json e nas necessidades da interface
export interface Questao {
  id: number;
  enunciado: string;
  alternativas: { [key: string]: string };
  gabarito: string;
  assunto?: string;
  dificuldade?: number;
  dicas?: string[];
  explicacao?: string;
}

export interface SimuladoMetadata {
  titulo: string;
  concurso?: string;
  ano?: number;
  area?: string;
  nivel?: string;
  totalQuestoes: number;
  tempoPrevisto?: number;
  autor?: string;
  dataGeracao?: string;
}

export interface SimuladoData {
  metadata: SimuladoMetadata;
  questoes: Questao[];
}

export type SimuladoStatus = 'idle' | 'loading' | 'reviewing' | 'results';

interface SimuladoState {
  simuladoData: SimuladoData | null;
  userAnswers: { [questaoId: number]: string }; // Armazena a alternativa selecionada pelo usuário (ex: 'a', 'b')
  currentQuestionIndex: number;
  status: SimuladoStatus;
  loadSimulado: (data: SimuladoData) => void;
  selectAnswer: (questaoId: number, answer: string) => void;
  nextQuestion: () => void;
  prevQuestion: () => void;
  finishReview: () => void;
  resetSimulado: () => void;
  setStatus: (status: SimuladoStatus) => void;
}

export const useSimuladoStore = create<SimuladoState>((set, get) => ({
  simuladoData: null,
  userAnswers: {},
  currentQuestionIndex: 0,
  status: 'idle', // Estado inicial

  loadSimulado: (data) => {
    // Validação básica dos dados carregados
    if (!data || !data.metadata || !data.questoes || !Array.isArray(data.questoes) || data.questoes.length === 0) {
      console.error('Erro: Dados do simulado inválidos ou vazios.');
      set({ simuladoData: null, userAnswers: {}, currentQuestionIndex: 0, status: 'idle' });
      // Poderia lançar um erro ou mostrar uma mensagem para o usuário aqui
      return;
    }
    set({
      simuladoData: data,
      userAnswers: {}, // Limpa respostas anteriores ao carregar novo simulado
      currentQuestionIndex: 0, // Começa da primeira questão
      status: 'reviewing', // Muda o status para indicar que a revisão começou
    });
  },

  selectAnswer: (questaoId, answer) => {
    set((state) => ({
      userAnswers: {
        ...state.userAnswers,
        [questaoId]: answer, // Atualiza ou adiciona a resposta do usuário para a questão
      },
    }));
  },

  nextQuestion: () => {
    set((state) => {
      // Só avança se houver um simulado carregado e não estiver na última questão
      if (state.simuladoData && state.currentQuestionIndex < state.simuladoData.questoes.length - 1) {
        return { currentQuestionIndex: state.currentQuestionIndex + 1 };
      }
      // Se estiver na última questão, poderia mudar o status para 'results' ou habilitar um botão "Finalizar"
      return {}; // Não faz nada se já estiver na última ou não houver simulado
    });
  },

  prevQuestion: () => {
    set((state) => {
      // Só volta se não estiver na primeira questão
      if (state.currentQuestionIndex > 0) {
        return { currentQuestionIndex: state.currentQuestionIndex - 1 };
      }
      return {}; // Não faz nada se já estiver na primeira
    });
  },

  finishReview: () => {
    const { simuladoData, userAnswers } = get(); // Obter estado atual

    if (!simuladoData) {
      console.error("Não é possível finalizar a revisão sem dados do simulado.");
      return;
    }

    // Calcular resultados aqui para registrar no histórico
    let correctCount = 0;
    const totalQuestions = simuladoData.questoes.length;
    console.log('--- Iniciando cálculo de resultados ---');
    console.log('Respostas do usuário:', userAnswers);
    simuladoData.questoes.forEach((questao) => {
      const userAnswer = userAnswers[questao.id];
      const correctAnswer = questao.gabarito;
      console.log(`Questão ID: ${questao.id}, Resposta Usuário: ${userAnswer} (tipo: ${typeof userAnswer}), Gabarito: ${correctAnswer} (tipo: ${typeof correctAnswer})`);
      if (userAnswer === correctAnswer) {
        console.log(` -> Acerto! Incrementando contagem.`);
        correctCount++;
      } else {
        console.log(` -> Erro!`);
      }
    });
    console.log(`Contagem final de acertos: ${correctCount}`);
    const percentageCorrect = totalQuestions > 0 ? (correctCount / totalQuestions) * 100 : 0;
    console.log(`Porcentagem de acerto: ${percentageCorrect}%`);
    console.log('--- Fim do cálculo de resultados ---');

    // Criar identificador único
    const identificador = criarIdentificadorSimulado(simuladoData.metadata.titulo, totalQuestions);

    // Adicionar ao histórico
    useHistoricoSimuladosStore.getState().adicionarTentativa(
      identificador,
      simuladoData.metadata.titulo,
      totalQuestions,
      correctCount,
      percentageCorrect
    );

    // Mudar o status para exibir a tela de resultados
    set({ status: 'results' });
  },

  resetSimulado: () => {
    // Reseta todo o estado para o inicial
    set({
      simuladoData: null,
      userAnswers: {},
      currentQuestionIndex: 0,
      status: 'idle',
    });
  },

  setStatus: (status) => {
    // Permite definir o status manualmente se necessário
    set({ status });
  },
}));

// Exemplo de como usar o store em um componente:
// import { useSimuladoStore } from '@/app/stores/simuladoStore';
//
// const MeuComponente = () => {
//   const { simuladoData, currentQuestionIndex, nextQuestion, loadSimulado } = useSimuladoStore();
//   // ... lógica do componente
// }
</file>

<file path="app/stores/sonoStore.ts">
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

export type RegistroSono = {
  id: string
  inicio: string // ISO date string
  fim: string | null // ISO date string ou null se ainda não acordou
  qualidade: number | null // 1-5, onde 5 é a melhor qualidade
  notas: string
}

export type ConfiguracaoLembrete = {
  id: string
  tipo: 'dormir' | 'acordar'
  horario: string // Formato HH:MM
  diasSemana: number[] // 0-6, onde 0 é domingo
  ativo: boolean
}

export type SonoState = {
  registros: RegistroSono[]
  lembretes: ConfiguracaoLembrete[]
  // Ações
  adicionarRegistroSono: (inicio: string, fim?: string | null, qualidade?: number | null, notas?: string) => void
  atualizarRegistroSono: (id: string, dados: Partial<Omit<RegistroSono, 'id'>>) => void
  removerRegistroSono: (id: string) => void
  adicionarLembrete: (tipo: 'dormir' | 'acordar', horario: string, diasSemana: number[]) => void
  atualizarLembrete: (id: string, dados: Partial<Omit<ConfiguracaoLembrete, 'id'>>) => void
  removerLembrete: (id: string) => void
  alternarAtivoLembrete: (id: string) => void
}

export const useSonoStore = create<SonoState>()(
  persist(
    (set) => ({
      registros: [],
      lembretes: [],
      
      adicionarRegistroSono: (inicio, fim = null, qualidade = null, notas = '') => set((state) => ({
        registros: [
          ...state.registros,
          {
            id: Date.now().toString(),
            inicio,
            fim,
            qualidade,
            notas
          }
        ]
      })),
      
      atualizarRegistroSono: (id, dados) => set((state) => ({
        registros: state.registros.map((registro) => 
          registro.id === id 
            ? { ...registro, ...dados } 
            : registro
        )
      })),
      
      removerRegistroSono: (id) => set((state) => ({
        registros: state.registros.filter((registro) => registro.id !== id)
      })),
      
      adicionarLembrete: (tipo, horario, diasSemana) => set((state) => ({
        lembretes: [
          ...state.lembretes,
          {
            id: Date.now().toString(),
            tipo,
            horario,
            diasSemana,
            ativo: true
          }
        ]
      })),
      
      atualizarLembrete: (id, dados) => set((state) => ({
        lembretes: state.lembretes.map((lembrete) => 
          lembrete.id === id 
            ? { ...lembrete, ...dados } 
            : lembrete
        )
      })),
      
      removerLembrete: (id) => set((state) => ({
        lembretes: state.lembretes.filter((lembrete) => lembrete.id !== id)
      })),
      
      alternarAtivoLembrete: (id) => set((state) => ({
        lembretes: state.lembretes.map((lembrete) =>
          lembrete.id === id
            ? { ...lembrete, ativo: !lembrete.ativo }
            : lembrete
        )
      }))
    }),
    {
      name: 'sono-storage',
    }
  )
)
</file>

<file path="app/stores/sugestoesStore.ts">
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'

interface SugestoesState {
  sugestoesFavoritas: string[]
  adicionarFavorita: (sugestao: string) => void
  removerFavorita: (sugestao: string) => void
}

export const useSugestoesStore = create<SugestoesState>()(
  persist(
    (set) => ({
      sugestoesFavoritas: [],
      
      adicionarFavorita: (sugestao) => set((state) => {
        // Evitar duplicatas
        if (state.sugestoesFavoritas.includes(sugestao)) {
          return state
        }
        return {
          sugestoesFavoritas: [...state.sugestoesFavoritas, sugestao]
        }
      }),
      
      removerFavorita: (sugestao) => set((state) => ({
        sugestoesFavoritas: state.sugestoesFavoritas.filter(s => s !== sugestao)
      })),
    }),
    {
      name: 'sugestoes-storage',
      storage: createJSONStorage(() => localStorage)
    }
  )
)
</file>

<file path="app/types/index.ts">
// Tipos compartilhados para todo o aplicativo

// Categorias principais do aplicativo
export type Categoria = 'inicio' | 'alimentacao' | 'estudos' | 'saude' | 'lazer' | 'nenhuma'

// Opções de humor para o monitor de humor
export type OpcaoHumor = 'otimo' | 'bom' | 'neutro' | 'baixo' | 'ruim'

// Interface para atividades de lazer
export type AtividadeLazer = {
  id: string
  nome: string
  descricao: string
  duracao: number // em minutos
  categoria: 'ativo' | 'passivo' | 'criativo' | 'social'
}

// Interface para materiais de estudo
export type MaterialEstudo = {
  id: string
  titulo: string
  tipo: 'livro' | 'video' | 'artigo' | 'exercicio' | 'outro'
  url?: string
  progresso: number // 0-100
  notas?: string
}

// Interface para registro de humor
export type RegistroHumor = {
  id: string
  data: string // formato YYYY-MM-DD
  humor: OpcaoHumor
  notas?: string
}

// Interface para lembretes
export type Lembrete = {
  id: string
  titulo: string
  descricao?: string
  data: string // formato YYYY-MM-DD
  hora: string // formato HH:MM
  recorrente: boolean
  diasRecorrencia?: ('seg' | 'ter' | 'qua' | 'qui' | 'sex' | 'sab' | 'dom')[]
  categoria: Categoria
  completado: boolean
}

// Interface para registro de hidratação
export type RegistroHidratacao = {
  id: string
  data: string // formato YYYY-MM-DD
  quantidade: number // em ml
  hora: string // formato HH:MM
}

// Interface para sessão de estudo
export type SessaoEstudo = {
  id: string
  data: string // formato YYYY-MM-DD
  inicio: string // formato HH:MM
  fim: string // formato HH:MM
  materia: string
  tecnica: 'pomodoro' | 'blocos' | 'livre'
  produtividade: 1 | 2 | 3 | 4 | 5 // escala de 1 a 5
  notas?: string
}

// Tipos para componentes do Dashboard
export type NavItem = {
  name: string
  href: string
  icon: React.ElementType
  color: string
  activeColor: string
  iconClasses?: string
}

export type PlaceholderProps = {
  className?: string
}

export type DashboardCardProps = {
  children: React.ReactNode
  title?: string
  className?: string
  isLoading?: boolean
}

export type DashboardSectionProps = {
  id?: string
  title?: string
  children: React.ReactNode
  className?: string
}

// Tipos para componentes de Suspense do Dashboard
export type SuspenseWrapperProps = {
  children: React.ReactNode
  fallback: React.ReactNode
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 47.4% 11.2%;
 
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
 
    --card: 0 0% 100%;
    --card-foreground: 222.2 47.4% 11.2%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 100% 50%;
    --destructive-foreground: 210 40% 98%;
 
    --ring: 215 20.2% 65.1%;
 
    --radius: 0.5rem;
    
    /* Cores temáticas por área */
    --inicio-primary: 210 100% 50%;
    --inicio-light: 210 100% 95%;
    
    --alimentacao-primary: 16 100% 50%;
    --alimentacao-light: 16 100% 95%;
    
    --estudos-primary: 43 100% 50%;
    --estudos-light: 43 100% 95%;
    
    --saude-primary: 152 100% 45%;
    --saude-light: 152 100% 95%;
    
    --lazer-primary: 262 100% 50%;
    --lazer-light: 262 100% 95%;
    
    --financas-primary: 130 100% 30%;
    --financas-light: 130 100% 95%;
    
    --hiperfocos-primary: 0 90% 50%;
    --hiperfocos-light: 0 90% 95%;
    
    --sono-primary: 240 85% 60%;
    --sono-light: 240 85% 95%;
    
    --perfil-primary: 180 100% 30%;
    --perfil-secondary: 180 100% 35%;
    
    --autoconhecimento-primary: 27 100% 40%;
    --autoconhecimento-light: 27 100% 90%;
  }

  .dark {
    --background: 224 71% 4%;
    --foreground: 213 31% 91%;
 
    --muted: 223 47% 11%;
    --muted-foreground: 215.4 16.3% 56.9%;
 
    --accent: 216 34% 17%;
    --accent-foreground: 210 40% 98%;
 
    --popover: 224 71% 4%;
    --popover-foreground: 215 20.2% 65.1%;
 
    --border: 216 34% 17%;
    --input: 216 34% 17%;
 
    --card: 224 71% 4%;
    --card-foreground: 213 31% 91%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 1.2%;
 
    --secondary: 222.2 47.4% 11.2%;
    --secondary-foreground: 210 40% 98%;
 
    --destructive: 0 63% 31%;
    --destructive-foreground: 210 40% 98%;
 
    --ring: 216 34% 17%;
    
    /* Cores temáticas por área - versão dark */
    --inicio-primary: 210 100% 65%;
    --inicio-light: 210 100% 15%;
    
    --alimentacao-primary: 16 100% 65%;
    --alimentacao-light: 16 100% 15%;
    
    --estudos-primary: 43 100% 65%;
    --estudos-light: 43 100% 15%;
    
    --saude-primary: 152 100% 55%;
    --saude-light: 152 100% 15%;
    
    --lazer-primary: 262 100% 70%;
    --lazer-light: 262 100% 15%;
    
    --financas-primary: 130 100% 40%;
    --financas-light: 130 100% 15%;
    
    --hiperfocos-primary: 0 90% 65%;
    --hiperfocos-light: 0 90% 15%;
    
    --sono-primary: 240 85% 70%;
    --sono-light: 240 85% 15%;
    
    --perfil-primary: 180 100% 40%;
    --perfil-secondary: 180 100% 45%;
    
    --autoconhecimento-primary: 27 100% 60%;
    --autoconhecimento-light: 27 100% 15%;
  }

  body {
    @apply text-gray-900 dark:text-white;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
  
  /* Estilos para acessibilidade */
  .alto-contraste {
    --contrast-factor: 1.5;
  }
  
  .alto-contraste .text-gray-500,
  .alto-contraste .text-gray-400,
  .alto-contraste .text-gray-300 {
    @apply text-gray-900 dark:text-white;
  }
  
  .alto-contraste .bg-gray-50,
  .alto-contraste .bg-gray-100,
  .alto-contraste .bg-gray-200 {
    @apply bg-white dark:bg-gray-900;
  }
  
  .reducao-estimulos * {
    transition: none !important;
    animation: none !important;
  }
  
  .reducao-estimulos .bg-opacity-90,
  .reducao-estimulos .bg-opacity-80,
  .reducao-estimulos .bg-opacity-70 {
    @apply bg-opacity-100;
  }
  
  .texto-grande {
    font-size: 1.1rem;
  }
  
  .texto-grande h1 {
    font-size: 2.5rem;
  }
  
  .texto-grande h2 {
    font-size: 2rem;
  }
  
  .texto-grande h3 {
    font-size: 1.5rem;
  }
  
  .texto-grande input,
  .texto-grande button {
    font-size: 1.1rem;
  }
}

@layer components {
  .focus-ring {
    @apply focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-blue-500 dark:focus-visible:ring-blue-400;
  }
  
  .card {
    @apply bg-white dark:bg-gray-800 rounded-xl shadow-md p-4 transition-all duration-200;
  }
  
  .btn {
    @apply px-4 py-2 rounded-lg font-medium transition-colors duration-200 focus-ring;
  }
  
  .btn-primary {
    @apply bg-blue-600 hover:bg-blue-700 text-white;
  }
  
  .btn-secondary {
    @apply bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-900 dark:text-gray-100;
  }
  
  .input {
    @apply px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg focus-ring;
  }
}

/* Acessibilidade - Classes de preferências */

/* Texto Grande */
.text-lg {
  font-size: 1.125rem !important;
}

.text-lg h1 {
  font-size: 2.5rem !important;
}

.text-lg h2 {
  font-size: 2rem !important;
}

.text-lg h3 {
  font-size: 1.75rem !important;
}

.text-lg p,
.text-lg span,
.text-lg button,
.text-lg a {
  font-size: 1.125rem !important;
}

/* Alto Contraste */
.high-contrast {
  --background: 0 0% 100%;
  --foreground: 0 0% 0%;
  
  --card: 0 0% 100%;
  --card-foreground: 0 0% 0%;
  
  --border: 0 0% 0%;
  --input: 0 0% 0%;
  
  --primary: 0 0% 0%;
  --primary-foreground: 0 0% 100%;
  
  --secondary: 0 0% 95%;
  --secondary-foreground: 0 0% 0%;
  
  --muted: 0 0% 95%;
  --muted-foreground: 0 0% 0%;
}

.dark.high-contrast {
  --background: 0 0% 0%;
  --foreground: 0 0% 100%;
  
  --card: 0 0% 0%;
  --card-foreground: 0 0% 100%;
  
  --border: 0 0% 100%;
  --input: 0 0% 100%;
  
  --primary: 0 0% 100%;
  --primary-foreground: 0 0% 0%;
  
  --secondary: 0 0% 15%;
  --secondary-foreground: 0 0% 100%;
  
  --muted: 0 0% 15%;
  --muted-foreground: 0 0% 100%;
}

.high-contrast a,
.high-contrast button,
.high-contrast input,
.high-contrast select,
.high-contrast textarea {
  outline: 2px solid transparent;
}

.high-contrast a:focus,
.high-contrast button:focus,
.high-contrast input:focus,
.high-contrast select:focus,
.high-contrast textarea:focus {
  outline: 2px solid currentColor;
  outline-offset: 2px;
}

/* Redução de Estímulos */
.reduce-motion * {
  animation: none !important;
  transition: none !important;
}

.reduce-motion *:hover {
  transform: none !important;
}

.reduce-motion .animate-pulse {
  animation: none !important;
}

/* Cores temáticas por área */
.text-inicio-primary {
  color: hsl(var(--inicio-primary)) !important;
}
.bg-inicio-light {
  background-color: hsl(var(--inicio-light)) !important;
}

.text-alimentacao-primary {
  color: hsl(var(--alimentacao-primary)) !important;
}
.bg-alimentacao-light {
  background-color: hsl(var(--alimentacao-light)) !important;
}

.text-estudos-primary {
  color: hsl(var(--estudos-primary)) !important;
}
.bg-estudos-light {
  background-color: hsl(var(--estudos-light)) !important;
}

.text-saude-primary {
  color: hsl(var(--saude-primary)) !important;
}
.bg-saude-light {
  background-color: hsl(var(--saude-light)) !important;
}

.text-lazer-primary {
  color: hsl(var(--lazer-primary)) !important;
}
.bg-lazer-light {
  background-color: hsl(var(--lazer-light)) !important;
}

.text-financas-primary {
  color: hsl(var(--financas-primary)) !important;
}
.bg-financas-light {
  background-color: hsl(var(--financas-light)) !important;
}

.text-hiperfocos-primary {
  color: hsl(var(--hiperfocos-primary)) !important;
}
.bg-hiperfocos-light {
  background-color: hsl(var(--hiperfocos-light)) !important;
}

.text-sono-primary {
  color: hsl(var(--sono-primary)) !important;
}
.bg-sono-light {
  background-color: hsl(var(--sono-light)) !important;
}

.text-autoconhecimento-primary {
  color: hsl(var(--autoconhecimento-primary)) !important;
}
.bg-autoconhecimento-light {
  background-color: hsl(var(--autoconhecimento-light)) !important;
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from 'next'
import './globals.css'
import { Header } from '@/app/components/layout/Header'
import { Footer } from '@/app/components/layout/Footer'
import { Providers } from '@/app/providers'
import { SpeedInsights } from '@vercel/speed-insights/next'

export const metadata: Metadata = {
  title: 'StayFocus',
  description: 'Aplicativo para ajudar pessoas neurodivergentes com organização e produtividade',
  // Atualizar para usar o novo logo como ícone principal
  icons: {
    icon: [
      // Usar o novo logo PNG como ícone principal
      { url: '/images/stayfocus_logo.png', type: 'image/png' }
    ],
    // Manter o logo SVG para Apple touch icon por enquanto, ou podemos mudar se preferir
    apple: '/images/logo.svg',
  },
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="pt-BR" suppressHydrationWarning>
      <body className="bg-gray-50 dark:bg-gray-900">
        <Providers>
          <div className="flex h-screen overflow-hidden">
            <div className="flex flex-col flex-1 overflow-hidden">
              <Header />
              <main className="flex-1 overflow-y-auto p-4">
                {children}
                <Footer />
              </main>
            </div>
          </div>
        </Providers>
        <SpeedInsights />
      </body>
    </html>
  )
}
</file>

<file path="app/page.tsx">
'use client'

import { useEffect } from 'react'
import Link from 'next/link'
import { PlusCircle } from 'lucide-react'
import { DashboardCard } from '@/app/components/ui/DashboardCard'
import { DashboardSection } from '@/app/components/ui/DashboardSection'
import { DashboardHeader } from '@/app/components/ui/DashboardHeader'
import { DashboardSummary } from '@/app/components/ui/DashboardSummary'
import { SuspenseWrapper } from '@/app/components/ui/SuspenseWrapper'
import { PreferencesButton } from '@/app/components/ui/PreferencesButton'
import { Button, buttonVariants } from '@/app/components/ui/Button'
import { PainelDia } from '@/app/components/inicio/PainelDia'
import { ListaPrioridades } from '@/app/components/inicio/ListaPrioridades'
import { LembretePausas } from '@/app/components/inicio/LembretePausas'
import { ChecklistMedicamentos } from '@/app/components/inicio/ChecklistMedicamentos'
import { ProximaProvaCard } from '@/app/components/inicio/ProximaProvaCard'
import { useDashboard } from '@/app/hooks/useDashboard'
import { cn } from '@/app/lib/utils'

// Componentes de placeholder para Suspense
const PainelDiaPlaceholder = () => (
  <div className="md:col-span-2">
    <DashboardCard isLoading title="Painel do Dia">
      Carregando...
    </DashboardCard>
  </div>
)

const ListaPrioridadesPlaceholder = () => (
  <div>
    <DashboardCard isLoading title="Prioridades do Dia">
      Carregando...
    </DashboardCard>
  </div>
)

const LembretePausasPlaceholder = () => (
  <div className="h-40 bg-white dark:bg-gray-800 rounded-xl shadow-md animate-pulse"></div>
)

const ProximaProvaPlaceholder = () => (
  <div className="h-32 bg-white dark:bg-gray-800 rounded-xl shadow-md animate-pulse"></div>
)

export default function HomePage() {
  // Usar o hook personalizado para carregar os dados do dashboard
  const {
    blocosDia,
    prioridadesDia,
    proximosCompromissos,
    prioridadesPendentes,
    prioridadesConcluidas,
    metasPausas,
    mostrarPausas,
    nomeUsuario,
    preferenciasVisuais,
    isLoading
  } = useDashboard()

  // Aplicar preferências visuais se estiverem definidas
  useEffect(() => {
    if (preferenciasVisuais) {
      // Aplicar texto grande
      if (preferenciasVisuais.textoGrande) {
        document.documentElement.classList.add('text-lg')
      } else {
        document.documentElement.classList.remove('text-lg')
      }
      
      // Aplicar alto contraste
      if (preferenciasVisuais.altoContraste) {
        document.documentElement.classList.add('high-contrast')
      } else {
        document.documentElement.classList.remove('high-contrast')
      }
      
      // Aplicar redução de estímulos
      if (preferenciasVisuais.reducaoEstimulos) {
        document.documentElement.classList.add('reduce-motion')
      } else {
        document.documentElement.classList.remove('reduce-motion')
      }
    }
  }, [preferenciasVisuais])

  return (
    <div className={`container mx-auto px-4 space-y-6 ${isLoading ? 'opacity-80' : ''}`}>
      <DashboardHeader
        title="Início"
        userName={nomeUsuario}
        description="Aqui está seu progresso e tarefas para hoje."
        actions={<PreferencesButton />}
      />
      
      {/* Resumo rápido */}
      <DashboardSummary
        prioridadesPendentes={prioridadesPendentes}
        prioridadesConcluidas={prioridadesConcluidas}
        proximosCompromissos={proximosCompromissos?.length || 0}
        className="mb-8"
      />
      
      <main className="pb-8">
        <DashboardSection id="painel-principal" className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {/* Painel Visual do Dia */}
          <SuspenseWrapper fallback={<PainelDiaPlaceholder />}>
            <div className="md:col-span-2">
              <DashboardCard title="Painel do Dia">
                <PainelDia />
              </DashboardCard>
            </div>
          </SuspenseWrapper>
          
          {/* Lista de Prioridades */}
          <SuspenseWrapper fallback={<ListaPrioridadesPlaceholder />}>
            <div>
              <DashboardCard 
                title="Prioridades do Dia"
                className="h-full"
              >
                <div className="space-y-6">
                  <ListaPrioridades />
                  
                  {/* Separador */}
                  <div 
                    role="separator" 
                    className="border-t border-gray-200 dark:border-gray-700 my-2" 
                    aria-hidden="true"
                  ></div>
                  
                  {/* Checklist de Medicamentos Diários */}
                  <ChecklistMedicamentos />
                </div>
              </DashboardCard>
            </div>
          </SuspenseWrapper>
        </DashboardSection>
        
        {/* Lembretes de Pausas e Próximas Provas */}
        {mostrarPausas && (
          <DashboardSection id="pausas-provas" className="mt-8 space-y-6">
            <SuspenseWrapper fallback={<LembretePausasPlaceholder />}>
              <LembretePausas />
            </SuspenseWrapper>

            <SuspenseWrapper fallback={<ProximaProvaPlaceholder />}>
              <ProximaProvaCard />
            </SuspenseWrapper>
          </DashboardSection>
        )}
        
        {/* Links Rápidos */}
        <DashboardSection id="links-rapidos" title="Acesso Rápido" className="mt-8">
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            <Link href="/estudos" className={cn(
              buttonVariants({ variant: "outline" }),
              "flex flex-col items-center justify-center h-24 p-4 text-estudos-primary hover:bg-estudos-light hover:border-estudos-primary"
            )}>
              <span className="text-sm font-medium">Estudos</span>
              <span className="text-xs mt-1 text-gray-500">Materiais e Técnicas</span>
            </Link>
            
            <Link href="/saude" className={cn(
              buttonVariants({ variant: "outline" }),
              "flex flex-col items-center justify-center h-24 p-4 text-saude-primary hover:bg-saude-light hover:border-saude-primary"
            )}>
              <span className="text-sm font-medium">Saúde</span>
              <span className="text-xs mt-1 text-gray-500">Medicamentos e Bem-estar</span>
            </Link>
            
            <Link href="/hiperfocos" className={cn(
              buttonVariants({ variant: "outline" }),
              "flex flex-col items-center justify-center h-24 p-4 text-hiperfocos-primary hover:bg-hiperfocos-light hover:border-hiperfocos-primary"
            )}>
              <span className="text-sm font-medium">Hiperfocos</span>
              <span className="text-xs mt-1 text-gray-500">Projetos e Interesses</span>
            </Link>
            
            <Link href="/lazer" className={cn(
              buttonVariants({ variant: "outline" }),
              "flex flex-col items-center justify-center h-24 p-4 text-lazer-primary hover:bg-lazer-light hover:border-lazer-primary"
            )}>
              <span className="text-sm font-medium">Lazer</span>
              <span className="text-xs mt-1 text-gray-500">Atividades e Descanso</span>
            </Link>
          </div>
        </DashboardSection>
      </main>
    </div>
  )
}
</file>

<file path="app/providers.tsx">
'use client'

import { ThemeProvider as NextThemesProvider } from 'next-themes'
import { type ThemeProviderProps } from 'next-themes/dist/types'

export function Providers({ children, ...props }: ThemeProviderProps) {
  return (
    <NextThemesProvider 
      attribute="class" 
      defaultTheme="system" 
      enableSystem 
      disableTransitionOnChange
      {...props}
    >
      <div suppressHydrationWarning>
        {children}
      </div>
    </NextThemesProvider>
  )
}
</file>

<file path="docs/technical/03-pages/alimentacao.md">
# Documentação da Página: Alimentação ([`app/alimentacao/page.tsx`](app/alimentacao/page.tsx:1))

## Propósito Geral da Página

A página de Alimentação ([`app/alimentacao/page.tsx`](app/alimentacao/page.tsx:1)) centraliza as funcionalidades relacionadas ao gerenciamento da dieta e hidratação do usuário. Ela permite o planejamento de refeições, o registro do que foi consumido e o acompanhamento da ingestão de água.

## Principais Funcionalidades

*   **Planejamento de Refeições:** Os usuários podem definir horários e descrições para suas refeições diárias (ex: café da manhã, almoço, jantar).
*   **Registro de Refeições Consumidas:** Permite que o usuário registre as refeições que efetivamente consumiu, incluindo horário, descrição, um ícone representativo do tipo de alimento e, opcionalmente, uma foto da refeição.
*   **Acompanhamento de Hidratação:** Os usuários podem registrar a quantidade de copos de água bebidos, ajustar uma meta diária de consumo e visualizar seu progresso.
*   **Acesso à Seção de Receitas:** Fornece um atalho para a seção "Minhas Receitas", onde o usuário pode organizar suas receitas favoritas.

## Componentes Visuais Chave e Sua Função

A página é estruturada utilizando o componente [`Card`](app/components/ui/Card.tsx:1) para agrupar funcionalidades relacionadas:

1.  **`PlanejadorRefeicoes` ([`app/components/alimentacao/PlanejadorRefeicoes.tsx`](app/components/alimentacao/PlanejadorRefeicoes.tsx:13))**
    *   **Localização:** Dentro de um [`Card`](app/components/ui/Card.tsx:1) com o título "Planejador de Refeições".
    *   **Função:** Exibe uma lista de refeições planejadas (horário e descrição). Permite ao usuário adicionar novas refeições, editar refeições existentes (alterando horário e/ou descrição) e remover refeições do planejamento.

2.  **`RegistroRefeicoes` ([`app/components/alimentacao/RegistroRefeicoes.tsx`](app/components/alimentacao/RegistroRefeicoes.tsx:18))**
    *   **Localização:** Dentro de um [`Card`](app/components/ui/Card.tsx:1) com o título "Registro de Refeições".
    *   **Função:** Mostra os registros de refeições já feitos pelo usuário. Permite adicionar um novo registro, especificando horário, descrição, um ícone visual para o tipo de refeição (ex: ☕ para café, 🍎 para fruta) e a opção de anexar uma foto (simulada). Os registros existentes podem ser removidos.

3.  **`LembreteHidratacao` ([`app/components/alimentacao/LembreteHidratacao.tsx`](app/components/alimentacao/LembreteHidratacao.tsx:6))**
    *   **Localização:** Dentro de um [`Card`](app/components/ui/Card.tsx:1) com o título "Hidratação".
    *   **Função:** Apresenta o acompanhamento do consumo de água. Exibe a quantidade de copos bebidos em relação a uma meta diária ajustável. O usuário pode registrar ou remover copos de água bebidos. Mostra o progresso visualmente através de uma barra e ícones de gotas. Também exibe o horário do último copo registrado e dicas de hidratação.

4.  **Card "Minhas Receitas"**
    *   **Localização:** É um [`Card`](app/components/ui/Card.tsx:1) com o título "Minhas Receitas".
    *   **Função:** Contém um texto introdutório que incentiva o usuário a organizar e acessar suas receitas. Possui um botão ([`Button`](app/components/ui/Button.tsx:1) estilizado dentro de um componente [`Link`](app/alimentacao/page.tsx:7) do Next.js) "Acessar Minhas Receitas" que redireciona o usuário para a página [`/receitas`](app/receitas/page.tsx:1).

## Conteúdo Textual Estático Proeminente

*   **Título Principal da Página:** "Alimentação" (tag `<h1>`).
*   **Títulos dos Cards:**
    *   "Planejador de Refeições"
    *   "Registro de Refeições"
    *   "Hidratação"
    *   "Minhas Receitas"
*   **Texto Introdutório no Card "Minhas Receitas":** "Organize e acesse suas receitas favoritas aqui. Crie listas de compras e planeje suas refeições."

## Interações com Stores de Estado (Zustand)

A página [`app/alimentacao/page.tsx`](app/alimentacao/page.tsx:1), através de seus componentes filhos, interage intensamente com a store [`useAlimentacaoStore`](app/stores/alimentacaoStore.ts:41) (localizada em [`app/stores/alimentacaoStore.ts`](app/stores/alimentacaoStore.ts:1)).

*   **Store Utilizada:** [`useAlimentacaoStore`](app/stores/alimentacaoStore.ts:41)
*   **Propósito da Interação:**
    *   O componente [`PlanejadorRefeicoes`](app/components/alimentacao/PlanejadorRefeicoes.tsx:13) utiliza a store para:
        *   Ler a lista de `refeicoes` planejadas.
        *   Chamar `adicionarRefeicao` para criar novas refeições.
        *   Chamar `atualizarRefeicao` para modificar refeições existentes.
        *   Chamar `removerRefeicao` para excluir refeições.
    *   O componente [`RegistroRefeicoes`](app/components/alimentacao/RegistroRefeicoes.tsx:18) utiliza a store para:
        *   Ler a lista de `registros` de refeições consumidas.
        *   Chamar `adicionarRegistro` para salvar um novo registro de refeição.
        *   Chamar `removerRegistro` para excluir um registro.
    *   O componente [`LembreteHidratacao`](app/components/alimentacao/LembreteHidratacao.tsx:6) utiliza a store para:
        *   Ler o estado de `coposBebidos`, `metaDiaria` e `ultimoRegistro` de hidratação.
        *   Chamar `adicionarCopo` para incrementar o número de copos bebidos.
        *   Chamar `removerCopo` para decrementar o número de copos bebidos.
        *   Chamar `ajustarMeta` para modificar a meta diária de copos de água.

A store [`useAlimentacaoStore`](app/stores/alimentacaoStore.ts:41) também utiliza o middleware `persist` do Zustand para salvar o estado relacionado à alimentação no `localStorage` do navegador sob a chave `alimentacao-storage`, garantindo que os dados do usuário persistam entre as sessões.
</file>

<file path="docs/technical/03-pages/autoconhecimento.md">
# Documentação da Página: Autoconhecimento ([`app/autoconhecimento/page.tsx`](app/autoconhecimento/page.tsx:1))

## Propósito Geral da Página

A página de Autoconhecimento serve como um diário digital estruturado, permitindo ao usuário registrar, organizar e refletir sobre diferentes aspectos de sua personalidade, motivações e padrões de comportamento. O objetivo é facilitar o autoconhecimento através da documentação e revisão de notas pessoais em seções temáticas. A página também oferece um "Modo Refúgio" para uma experiência de escrita focada e com menos distrações.

## Principais Funcionalidades

*   **Navegação por Abas Temáticas:** O usuário pode alternar entre três seções principais para organizar suas notas:
    *   "Quem sou"
    *   "Meus porquês"
    *   "Meus padrões"
*   **Criação e Edição de Notas:** Permite criar novas notas ou editar notas existentes dentro da seção selecionada.
*   **Listagem de Notas:** Exibe uma lista das notas previamente salvas para a aba ativa, permitindo fácil acesso e seleção.
*   **Modo Refúgio:** Uma funcionalidade que simplifica a interface, possivelmente ocultando elementos visuais secundários para promover foco durante a escrita ou leitura.
*   **Gerenciamento de Estado de Edição:** Controla se o usuário está criando uma nova nota, editando uma existente ou visualizando a lista de notas.

## Componentes Visuais Chave e Sua Função

*   **Abas de Navegação (Dinâmicas):**
    *   Localização: Topo da página, abaixo do título principal ([`app/autoconhecimento/page.tsx:70-89`](app/autoconhecimento/page.tsx:70)).
    *   Função: Permitem ao usuário selecionar qual categoria de notas de autoconhecimento deseja visualizar ou editar ("Quem sou", "Meus porquês", "Meus padrões").
*   **[`ListaNotas`](app/components/autoconhecimento/ListaNotas.tsx:6) ([`app/components/autoconhecimento/ListaNotas.tsx`](app/components/autoconhecimento/ListaNotas.tsx:1)):**
    *   Localização: Na coluna da esquerda (em telas maiores) quando nenhuma nota está selecionada para edição ou criação ([`app/autoconhecimento/page.tsx:124-127`](app/autoconhecimento/page.tsx:124)).
    *   Função: Exibe os títulos ou resumos das notas existentes para a aba selecionada. Clicar em uma nota da lista a seleciona para visualização/edição no [`EditorNotas`](app/components/autoconhecimento/EditorNotas.tsx:5).
*   **[`EditorNotas`](app/components/autoconhecimento/EditorNotas.tsx:5) ([`app/components/autoconhecimento/EditorNotas.tsx`](app/components/autoconhecimento/EditorNotas.tsx:1)):**
    *   Localização: Ocupa a área principal (ou coluna da direita em telas maiores) quando uma nota está sendo criada ou editada ([`app/autoconhecimento/page.tsx:148-152`](app/autoconhecimento/page.tsx:148)).
    *   Função: Provê uma interface rica (provavelmente um editor de texto) para o usuário escrever e formatar o conteúdo de suas notas. Salva as alterações ou a nova nota.
*   **[`ModoRefugio`](app/components/autoconhecimento/ModoRefugio.tsx:7) ([`app/components/autoconhecimento/ModoRefugio.tsx`](app/components/autoconhecimento/ModoRefugio.tsx:1)):**
    *   Localização: Renderizado no final do container da página, possivelmente como um botão flutuante ou um toggle ([`app/autoconhecimento/page.tsx:159`](app/autoconhecimento/page.tsx:159)).
    *   Função: Ativa ou desativa o "Modo Refúgio". Quando ativo, a interface é simplificada (e.g., descrições de seção e o botão "Nova nota" podem ser ocultados).
*   **[`Button`](app/components/ui/Button.tsx:8) ([`app/components/ui/Button.tsx`](app/components/ui/Button.tsx:1)):**
    *   Função: Utilizado para diversas ações:
        *   "Nova nota": Inicia o processo de criação de uma nova nota ([`app/autoconhecimento/page.tsx:113-120`](app/autoconhecimento/page.tsx:113)).
        *   "Cancelar": Descarta a criação ou edição de uma nota, retornando à visualização da lista ([`app/autoconhecimento/page.tsx:138-145`](app/autoconhecimento/page.tsx:138)).
*   **[`Container`](app/components/ui/Container.tsx:9) ([`app/components/ui/Container.tsx`](app/components/ui/Container.tsx:1)):**
    *   Função: Componente de layout que envolve todo o conteúdo da página, garantindo consistência visual e espaçamento.
*   **[`Section`](app/components/ui/Section.tsx:10) ([`app/components/ui/Section.tsx`](app/components/ui/Section.tsx:1)):**
    *   Função: Agrupa o conteúdo principal relacionado à aba selecionada, contendo a [`ListaNotas`](app/components/autoconhecimento/ListaNotas.tsx:6) e/ou o [`EditorNotas`](app/components/autoconhecimento/EditorNotas.tsx:5) ([`app/autoconhecimento/page.tsx:100-156`](app/autoconhecimento/page.tsx:100)).

## Conteúdo Textual Estático Proeminente

*   **Título Principal da Página:** "Notas de Autoconhecimento" ([`app/autoconhecimento/page.tsx:66`](app/autoconhecimento/page.tsx:66)).
*   **Títulos das Abas/Seções (visíveis nas abas e como cabeçalhos de seção):**
    *   "Quem sou" ([`app/autoconhecimento/page.tsx:22`](app/autoconhecimento/page.tsx:22))
    *   "Meus porquês" ([`app/autoconhecimento/page.tsx:23`](app/autoconhecimento/page.tsx:23))
    *   "Meus padrões" ([`app/autoconhecimento/page.tsx:24`](app/autoconhecimento/page.tsx:24))
*   **Descrições das Seções (exibidas abaixo das abas quando nenhuma nota está sendo editada e o Modo Refúgio está desativado):**
    *   Para "Quem sou": "Registre suas preferências, aversões e características pessoais estáveis" ([`app/autoconhecimento/page.tsx:29`](app/autoconhecimento/page.tsx:29)).
    *   Para "Meus porquês": "Documente motivações e valores fundamentais que guiam suas decisões" ([`app/autoconhecimento/page.tsx:30`](app/autoconhecimento/page.tsx:30)).
    *   Para "Meus padrões": "Anote reações emocionais típicas e estratégias eficazes em momentos de crise" ([`app/autoconhecimento/page.tsx:31`](app/autoconhecimento/page.tsx:31)).
*   **Cabeçalhos Dinâmicos:**
    *   "Suas notas em [Nome da Aba]" (e.g., "Suas notas em Quem sou") ([`app/autoconhecimento/page.tsx:109`](app/autoconhecimento/page.tsx:109)).
    *   "Nova nota" ou "Editar nota", dependendo da ação do usuário ([`app/autoconhecimento/page.tsx:135`](app/autoconhecimento/page.tsx:135)).

## Interações com Stores de Estado (Zustand)

*   A página interage com a store `useAutoconhecimentoStore` (importada de [`app/stores/autoconhecimentoStore.ts`](app/stores/autoconhecimentoStore.ts:11)).
*   **Estado Utilizado:** `modoRefugio` ([`app/autoconhecimento/page.tsx:18`](app/autoconhecimento/page.tsx:18)).
*   **Propósito da Interação:** O estado `modoRefugio` é lido da store para determinar se a interface da página deve ser simplificada. Se `modoRefugio` for `true`, certos elementos da interface, como as descrições das seções ([`app/autoconhecimento/page.tsx:92`](app/autoconhecimento/page.tsx:92)) e o botão para criar uma nova nota ([`app/autoconhecimento/page.tsx:112`](app/autoconhecimento/page.tsx:112)), são ocultados para minimizar distrações. O componente [`ModoRefugio`](app/components/autoconhecimento/ModoRefugio.tsx:7) é responsável por permitir ao usuário alterar este estado na store.
</file>

<file path="docs/technical/03-pages/concursos-id.md">
# Documentação da Página: Detalhes do Concurso ([`app/concursos/[id]/page.tsx`](app/concursos/[id]/page.tsx:1))

Este documento detalha a página que exibe os detalhes de um concurso específico na aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.5: Documentação da página [`app/concursos/[id]/page.tsx`](app/concursos/[id]/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/concursos.md">
# Documentação da Página: Concursos ([`app/concursos/page.tsx`](app/concursos/page.tsx:1))

Este documento detalha a página de listagem de concursos da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.4: Documentação da página [`app/concursos/page.tsx`](app/concursos/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/estudos-materiais.md">
# Documentação da Página: Materiais de Estudo ([`app/estudos/materiais/page.tsx`](app/estudos/materiais/page.tsx:1))

Este documento detalha a página de materiais de estudo da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.7: Documentação da página [`app/estudos/materiais/page.tsx`](app/estudos/materiais/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/estudos-simulado-personalizado.md">
# Documentação da Página: Simulado Personalizado ([`app/estudos/simulado-personalizado/page.tsx`](app/estudos/simulado-personalizado/page.tsx:1))

Este documento detalha a página de criação de simulados personalizados da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.9: Documentação da página [`app/estudos/simulado-personalizado/page.tsx`](app/estudos/simulado-personalizado/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/estudos-simulado.md">
# Documentação da Página: Simulado ([`app/estudos/simulado/page.tsx`](app/estudos/simulado/page.tsx:1))

Este documento detalha a página de simulados da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.8: Documentação da página [`app/estudos/simulado/page.tsx`](app/estudos/simulado/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/estudos.md">
qq# Documentação da Página: Estudos ([`app/estudos/page.tsx`](app/estudos/page.tsx:1))

Este documento detalha a página principal de estudos da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.6: Documentação da página [`app/estudos/page.tsx`](app/estudos/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/financas.md">
# Documentação da Página: Finanças ([`app/financas/page.tsx`](app/financas/page.tsx:1))

Este documento detalha a página de finanças da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.10: Documentação da página [`app/financas/page.tsx`](app/financas/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/hiperfocos.md">
# Documentação da Página: Hiperfocos ([`app/hiperfocos/page.tsx`](app/hiperfocos/page.tsx:1))

Este documento detalha a página de hiperfocos da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.11: Documentação da página [`app/hiperfocos/page.tsx`](app/hiperfocos/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/inicio.md">
# Documentação da Página Inicial ([`app/page.tsx`](app/page.tsx:1))

## Propósito Geral da Página

A página inicial ([`app/page.tsx`](app/page.tsx:1)) serve como um painel de controle central para o usuário, fornecendo uma visão geral de suas atividades, prioridades, compromissos e configurações relevantes para o dia. Seu objetivo é oferecer acesso rápido às informações e funcionalidades mais importantes do aplicativo.

## Principais Funcionalidades

*   **Visualização do Painel do Dia:** Exibe os blocos de tempo e atividades planejadas para o dia.
*   **Gerenciamento de Prioridades:** Mostra a lista de tarefas prioritárias para o dia e permite o acompanhamento do status (pendentes/concluídas).
*   **Checklist de Medicamentos:** Apresenta um checklist para o usuário marcar os medicamentos que já tomou.
*   **Lembretes de Pausas:** Caso ativado nas configurações, exibe lembretes para pausas.
*   **Visualização da Próxima Prova:** Mostra informações sobre a próxima prova agendada.
*   **Resumo Rápido:** Apresenta um sumário com o número de prioridades pendentes, prioridades concluídas e próximos compromissos.
*   **Acesso Rápido:** Fornece links diretos para seções importantes do aplicativo como Estudos, Saúde, Hiperfocos e Lazer.
*   **Preferências de Acessibilidade:** Permite ao usuário ajustar preferências visuais como texto grande, alto contraste e redução de estímulos através do botão de preferências.

## Componentes Visuais Chave e Sua Função

A página utiliza diversos componentes, principalmente das pastas [`app/components/ui/`](app/components/ui/) para elementos de interface genéricos e [`app/components/inicio/`](app/components/inicio/) para componentes específicos da página inicial.

*   **Componentes de UI (de [`app/components/ui/`](app/components/ui/)):**
    *   [`DashboardCard`](app/components/ui/DashboardCard.tsx:6): Contêiner padrão para seções do dashboard, com título e opção de estado de carregamento. Usado para envolver o `PainelDia`, `ListaPrioridades`, etc.
    *   [`DashboardSection`](app/components/ui/DashboardSection.tsx:7): Define uma seção dentro do dashboard, agrupando cartões ou outros elementos.
    *   [`DashboardHeader`](app/components/ui/DashboardHeader.tsx:8): Cabeçalho da página do dashboard, exibindo título, nome do usuário, descrição e ações (como o botão de preferências).
    *   [`DashboardSummary`](app/components/ui/DashboardSummary.tsx:9): Exibe um resumo de estatísticas chave (prioridades pendentes/concluídas, próximos compromissos).
    *   [`SuspenseWrapper`](app/components/ui/SuspenseWrapper.tsx:10): Envolve componentes que podem ter carregamento assíncrono, exibindo um placeholder enquanto o conteúdo não está pronto.
    *   [`PreferencesButton`](app/components/ui/PreferencesButton.tsx:11): Botão que provavelmente abre um modal ou menu para o usuário configurar suas preferências visuais.
    *   [`Button`](app/components/ui/Button.tsx:12): Componente de botão genérico.
    *   [`cn`](app/lib/utils.ts:19): Utilitário para concatenar classes CSS condicionalmente (usado com `buttonVariants`).

*   **Componentes da Página Inicial (de [`app/components/inicio/`](app/components/inicio/)):**
    *   [`PainelDia`](app/components/inicio/PainelDia.tsx:13): Exibe uma visualização dos blocos de tempo e atividades agendadas para o dia corrente.
    *   [`ListaPrioridades`](app/components/inicio/ListaPrioridades.tsx:14): Mostra a lista de tarefas definidas como prioritárias para o dia.
    *   [`LembretePausas`](app/components/inicio/LembretePausas.tsx:15): Apresenta um lembrete visual para o usuário fazer pausas, provavelmente baseado nas configurações de metas de pausas.
    *   [`ChecklistMedicamentos`](app/components/inicio/ChecklistMedicamentos.tsx:16): Permite ao usuário marcar os medicamentos que já foram administrados no dia.
    *   [`ProximaProvaCard`](app/components/inicio/ProximaProvaCard.tsx:17): Exibe informações sobre a próxima prova ou avaliação importante agendada.

## Conteúdo Textual Estático Proeminente

*   **Título Principal (via [`DashboardHeader`](app/components/ui/DashboardHeader.tsx:89)):** "Início"
*   **Descrição (via [`DashboardHeader`](app/components/ui/DashboardHeader.tsx:92)):** "Aqui está seu progresso e tarefas para hoje."
*   **Títulos de Seção (via [`DashboardCard`](app/components/ui/DashboardCard.tsx:6) e [`DashboardSection`](app/components/ui/DashboardSection.tsx:7)):**
    *   "Painel do Dia"
    *   "Prioridades do Dia"
    *   "Acesso Rápido"
*   **Links de Acesso Rápido:**
    *   "Estudos" (com subtítulo "Materiais e Técnicas")
    *   "Saúde" (com subtítulo "Medicamentos e Bem-estar")
    *   "Hiperfocos" (com subtítulo "Projetos e Interesses")
    *   "Lazer" (com subtítulo "Atividades e Descanso")

## Interações com Stores de Estado (Zustand)

A página [`app/page.tsx`](app/page.tsx:1) obtém a maior parte de seus dados dinâmicos através do hook personalizado [`useDashboard`](app/hooks/useDashboard.ts:18). Este hook, por sua vez, interage com as seguintes stores Zustand localizadas em [`app/stores/`](app/stores/):

*   **[`usePainelDiaStore`](app/stores/painelDiaStore.ts:4) (via [`app/hooks/useDashboard.ts:50`](app/hooks/useDashboard.ts:50)):**
    *   Utilizada para buscar os `blocos` de tempo agendados para o dia, que são exibidos no componente [`PainelDia`](app/components/inicio/PainelDia.tsx:13).
*   **[`usePrioridadesStore`](app/stores/prioridadesStore.ts:5) (via [`app/hooks/useDashboard.ts:51`](app/hooks/useDashboard.ts:51)):**
    *   Utilizada para buscar as `prioridades` do dia através da função `getHistoricoPorData`. Essas prioridades são exibidas no componente [`ListaPrioridades`](app/components/inicio/ListaPrioridades.tsx:14) e usadas para calcular as estatísticas de prioridades pendentes e concluídas no [`DashboardSummary`](app/components/ui/DashboardSummary.tsx:9).
*   **[`usePerfilStore`](app/stores/perfilStore.ts:6) (via [`app/hooks/useDashboard.ts:52`](app/hooks/useDashboard.ts:52)):**
    *   Utilizada para obter:
        *   `nome`: Nome do usuário, exibido no [`DashboardHeader`](app/components/ui/DashboardHeader.tsx:91).
        *   `metasDiarias`: Contém informações sobre `pausasProgramadas` e `tarefasPrioritarias`, usadas para configurar o comportamento do [`LembretePausas`](app/components/inicio/LembretePausas.tsx:15) e potencialmente para a lógica de exibição de prioridades.
        *   `pausasAtivas`: Um booleano que determina se os lembretes de pausa devem ser mostrados ([`LembretePausas`](app/components/inicio/LembretePausas.tsx:144)).
        *   `preferenciasVisuais`: Objeto contendo as configurações de acessibilidade (`altoContraste`, `reducaoEstimulos`, `textoGrande`) que são aplicadas dinamicamente ao `document.documentElement` no [`useEffect`](app/page.tsx:62) da página para alterar a aparência global da interface.

Os componentes [`ChecklistMedicamentos`](app/components/inicio/ChecklistMedicamentos.tsx:16) e [`ProximaProvaCard`](app/components/inicio/ProximaProvaCard.tsx:17) provavelmente interagem com suas próprias stores ou com stores mais específicas (ex: `useSaudeStore`, `useConcursosStore`), embora a interação direta não seja visível no código de [`app/page.tsx`](app/page.tsx:1) ou [`app/hooks/useDashboard.ts`](app/hooks/useDashboard.ts:1) e sim encapsulada dentro desses próprios componentes.
</file>

<file path="docs/technical/03-pages/lazer.md">
# Documentação da Página: Lazer ([`app/lazer/page.tsx`](app/lazer/page.tsx:1))

Este documento detalha a página de lazer da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.12: Documentação da página [`app/lazer/page.tsx`](app/lazer/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/perfil-ajuda.md">
# Documentação da Página: Ajuda do Perfil ([`app/perfil/ajuda/page.tsx`](app/perfil/ajuda/page.tsx:1))

Este documento detalha a página de ajuda dentro da seção de perfil do usuário da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.14: Documentação da página [`app/perfil/ajuda/page.tsx`](app/perfil/ajuda/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/perfil.md">
# Documentação da Página: Perfil ([`app/perfil/page.tsx`](app/perfil/page.tsx:1))

Este documento detalha a página de perfil do usuário da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.13: Documentação da página [`app/perfil/page.tsx`](app/perfil/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/README.md">
# Documentação das Páginas da Aplicação

Esta seção contém a documentação detalhada para cada página principal (`page.tsx`) da aplicação StayFocus. Cada arquivo markdown abaixo descreve o propósito, funcionalidades, componentes visuais chave, conteúdo textual estático e interações com o estado global (Zustand) da respectiva página.

## Índice de Páginas

*   [Página Inicial (`/`)](./inicio.md)
*   [Alimentação (`/alimentacao`)](./alimentacao.md)
*   [Autoconhecimento (`/autoconhecimento`)](./autoconhecimento.md)
*   [Concursos (`/concursos`)](./concursos.md)
*   [Detalhes do Concurso (`/concursos/[id]`)](./concursos-id.md)
*   [Estudos (`/estudos`)](./estudos.md)
*   [Materiais de Estudo (`/estudos/materiais`)](./estudos-materiais.md)
*   [Simulado (`/estudos/simulado`)](./estudos-simulado.md)
*   [Simulado Personalizado (`/estudos/simulado-personalizado`)](./estudos-simulado-personalizado.md)
*   [Finanças (`/financas`)](./financas.md)
*   [Hiperfocos (`/hiperfocos`)](./hiperfocos.md)
*   [Lazer (`/lazer`)](./lazer.md)
*   [Perfil (`/perfil`)](./perfil.md)
*   [Ajuda do Perfil (`/perfil/ajuda`)](./perfil-ajuda.md)
*   [Receitas (`/receitas`)](./receitas.md)
*   [Detalhes da Receita (`/receitas/[id]`)](./receitas-id.md)
*   [Adicionar Receita (`/receitas/adicionar`)](./receitas-adicionar.md)
*   [Editar Receita (`/receitas/editar/[id]`)](./receitas-editar-id.md)
*   [Lista de Compras (`/receitas/lista-compras`)](./receitas-lista-compras.md)
*   [Roadmap (`/roadmap`)](./roadmap.md)
*   [Saúde (`/saude`)](./saude.md)
*   [Sono (`/sono`)](./sono.md)
</file>

<file path="docs/technical/03-pages/receitas-adicionar.md">
# Documentação da Página: Adicionar Receita ([`app/receitas/adicionar/page.tsx`](app/receitas/adicionar/page.tsx:1))

Este documento detalha a página utilizada para adicionar novas receitas à aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.17: Documentação da página [`app/receitas/adicionar/page.tsx`](app/receitas/adicionar/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/receitas-editar-id.md">
# Documentação da Página: Editar Receita ([`app/receitas/editar/[id]/page.tsx`](app/receitas/editar/[id]/page.tsx:1))

Este documento detalha a página utilizada para editar receitas existentes na aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.18: Documentação da página [`app/receitas/editar/[id]/page.tsx`](app/receitas/editar/[id]/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/receitas-id.md">
# Documentação da Página: Detalhes da Receita ([`app/receitas/[id]/page.tsx`](app/receitas/[id]/page.tsx:1))

Este documento detalha a página que exibe os detalhes de uma receita específica na aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.16: Documentação da página [`app/receitas/[id]/page.tsx`](app/receitas/[id]/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/receitas-lista-compras.md">
# Documentação da Página: Lista de Compras ([`app/receitas/lista-compras/page.tsx`](app/receitas/lista-compras/page.tsx:1))

Este documento detalha a página de lista de compras da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.19: Documentação da página [`app/receitas/lista-compras/page.tsx`](app/receitas/lista-compras/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/receitas.md">
# Documentação da Página: Receitas ([`app/receitas/page.tsx`](app/receitas/page.tsx:1))

Este documento detalha a página de listagem de receitas da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.15: Documentação da página [`app/receitas/page.tsx`](app/receitas/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/roadmap.md">
# Documentação da Página: Roadmap ([`app/roadmap/page.tsx`](app/roadmap/page.tsx:1))

Este documento detalha a página de roadmap da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.20: Documentação da página [`app/roadmap/page.tsx`](app/roadmap/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/saude.md">
# Documentação da Página: Saúde ([`app/saude/page.tsx`](app/saude/page.tsx:1))

Este documento detalha a página de saúde da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.21: Documentação da página [`app/saude/page.tsx`](app/saude/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/03-pages/sono.md">
# Documentação da Página: Sono ([`app/sono/page.tsx`](app/sono/page.tsx:1))

Este documento detalha a página de sono da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 3.22: Documentação da página [`app/sono/page.tsx`](app/sono/page.tsx:1) será inserido aqui.)*
</file>

<file path="docs/technical/01-project-overview.md">
# Resumo da Análise do Projeto Anatel2

## Estrutura Geral de Diretórios

O projeto utiliza a estrutura do App Router do Next.js. As principais pastas identificadas são:

*   **`app/`**: Contém a lógica central da aplicação, incluindo:
    *   Páginas (rotas) da aplicação (ex: [`app/page.tsx`](app/page.tsx:1), [`app/alimentacao/page.tsx`](app/alimentacao/page.tsx:1)).
    *   Layouts globais e específicos (ex: [`app/layout.tsx`](app/layout.tsx:1)).
    *   **`app/components/`**: Abriga os componentes React reutilizáveis, frequentemente organizados por funcionalidade (ex: [`app/components/alimentacao/`](app/components/alimentacao), [`app/components/ui/`](app/components/ui)).
    *   **`app/lib/`**: Módulos contendo lógica de negócios, serviços, utilitários e clientes de API (ex: [`app/lib/dataService.ts`](app/lib/dataService.ts:1), [`app/lib/googleDriveClient.ts`](app/lib/googleDriveClient.ts:1)).
    *   **`app/stores/`**: Contém as lojas (stores) do Zustand para gerenciamento de estado global, segmentadas por domínio da aplicação (ex: [`app/stores/alimentacaoStore.ts`](app/stores/alimentacaoStore.ts:1), [`app/stores/concursosStore.ts`](app/stores/concursosStore.ts:1)).
*   **`pages/`**: Principalmente utilizado para as API Routes do Next.js (ex: [`pages/api/gerar-questao.ts`](pages/api/gerar-questao.ts:1), [`pages/api/drive/`](pages/api/drive)).
*   **`public/`**: Armazena arquivos estáticos que são servidos diretamente, como imagens (ex: [`public/images/logo.svg`](public/images/logo.svg)), fontes, arquivos JSON de exemplo (ex: [`public/simulado-exemplo.json`](public/simulado-exemplo.json)) e sons.
*   **`docs/`**: Contém arquivos de documentação do projeto, como guias e exemplos em Markdown e JSON.
*   **`perplexity-mcp-server/`**: Um diretório separado que parece conter um servidor MCP (Model Context Protocol), possivelmente para interagir com a API da Perplexity.

## Principais Tecnologias, Frameworks e Bibliotecas

*   **Next.js ([`package.json#L23`](package.json:23))**: Framework React para desenvolvimento de aplicações web full-stack, utilizado para renderização no servidor (SSR), geração de sites estáticos (SSG), roteamento (App Router) e API routes.
*   **React ([`package.json#L26`](package.json:26))**: Biblioteca JavaScript para construção de interfaces de usuário interativas e componentizadas.
*   **TypeScript ([`package.json#L45`](package.json:45))**: Superset do JavaScript que adiciona tipagem estática, melhorando a robustez e a manutenibilidade do código. Configurado através do [`tsconfig.json`](tsconfig.json:1).
*   **Tailwind CSS ([`package.json#L44`](package.json:44))**: Framework CSS utility-first para estilização rápida e customizável. Configurado em [`tailwind.config.js`](tailwind.config.js:1) com um tema customizado e cores específicas para diferentes seções da aplicação.
*   **Zustand ([`package.json#L32`](package.json:32))**: Biblioteca para gerenciamento de estado global de forma simples e flexível, utilizada nas stores dentro de [`app/stores/`](app/stores).
*   **Lucide React ([`package.json#L22`](package.json:22))**: Biblioteca de ícones SVG leves e customizáveis.
*   **date-fns ([`package.json#L19`](package.json:19))**: Biblioteca para manipulação de datas e horários.
*   **Google APIs (googleapis [`package.json#L20`](package.json:20))**: Biblioteca cliente para interagir com APIs do Google, provavelmente utilizada para integração com o Google Drive, como sugerido pela presença de [`app/lib/googleDriveClient.ts`](app/lib/googleDriveClient.ts:1) e rotas em [`pages/api/drive/`](pages/api/drive).
*   **Iron Session ([`package.json#L21`](package.json:21))**: Biblioteca para gerenciamento de sessões stateless, útil para autenticação.
*   **Recharts ([`package.json#L29`](package.json:29))**: Biblioteca para criação de gráficos e visualizações de dados.
*   **React Markdown ([`package.json#L28`](package.json:28))**: Componente React para renderizar conteúdo Markdown.
*   **Next Themes ([`package.json#L24`](package.json:24))**: Facilita a implementação de temas (ex: dark/light mode) em aplicações Next.js.
*   **ESLint ([`package.json#L40`](package.json:40)) / Prettier ([`package.json#L43`](package.json:43))**: Ferramentas para linting e formatação de código, garantindo consistência e qualidade.
*   **@next/bundle-analyzer ([`package.json#L35`](package.json:35))**: Ferramenta para analisar o tamanho dos bundles gerados pela aplicação Next.js, configurada em [`next.config.js`](next.config.js:1).
</file>

<file path="docs/technical/02-routing.md">
# Mapeamento de Páginas e Rotas

Esta seção detalha as principais rotas da aplicação e os arquivos `page.tsx` correspondentes que as definem, com base na estrutura do App Router do Next.js.

*   `/`: [`app/page.tsx`](app/page.tsx:1)
*   `/alimentacao`: [`app/alimentacao/page.tsx`](app/alimentacao/page.tsx:1)
*   `/autoconhecimento`: [`app/autoconhecimento/page.tsx`](app/autoconhecimento/page.tsx:1)
*   `/concursos`: [`app/concursos/page.tsx`](app/concursos/page.tsx:1)
*   `/concursos/[id]`: [`app/concursos/[id]/page.tsx`](app/concursos/[id]/page.tsx:1)
*   `/estudos`: [`app/estudos/page.tsx`](app/estudos/page.tsx:1)
*   `/estudos/materiais`: [`app/estudos/materiais/page.tsx`](app/estudos/materiais/page.tsx:1)
*   `/estudos/simulado`: [`app/estudos/simulado/page.tsx`](app/estudos/simulado/page.tsx:1)
*   `/estudos/simulado-personalizado`: [`app/estudos/simulado-personalizado/page.tsx`](app/estudos/simulado-personalizado/page.tsx:1)
*   `/financas`: [`app/financas/page.tsx`](app/financas/page.tsx:1)
*   `/hiperfocos`: [`app/hiperfocos/page.tsx`](app/hiperfocos/page.tsx:1)
*   `/lazer`: [`app/lazer/page.tsx`](app/lazer/page.tsx:1)
*   `/perfil`: [`app/perfil/page.tsx`](app/perfil/page.tsx:1)
*   `/perfil/ajuda`: [`app/perfil/ajuda/page.tsx`](app/perfil/ajuda/page.tsx:1)
*   `/receitas`: [`app/receitas/page.tsx`](app/receitas/page.tsx:1)
*   `/receitas/[id]`: [`app/receitas/[id]/page.tsx`](app/receitas/[id]/page.tsx:1)
*   `/receitas/adicionar`: [`app/receitas/adicionar/page.tsx`](app/receitas/adicionar/page.tsx:1)
*   `/receitas/editar/[id]`: [`app/receitas/editar/[id]/page.tsx`](app/receitas/editar/[id]/page.tsx:1)
*   `/receitas/lista-compras`: [`app/receitas/lista-compras/page.tsx`](app/receitas/lista-compras/page.tsx:1)
*   `/roadmap`: [`app/roadmap/page.tsx`](app/roadmap/page.tsx:1)
*   `/saude`: [`app/saude/page.tsx`](app/saude/page.tsx:1)
*   `/sono`: [`app/sono/page.tsx`](app/sono/page.tsx:1)
</file>

<file path="docs/technical/04-ui-components.md">
# 4. Componentes de UI Reutilizáveis ([`app/components/ui/`](app/components/ui/))

Este documento descreve os componentes de UI reutilizáveis encontrados no diretório [`app/components/ui/`](app/components/ui/). Estes componentes são a base para a construção da interface do usuário da aplicação Anatel2 (StayFocus), garantindo consistência visual e funcional.

*(Conteúdo da Subtarefa 4: Análise dos Componentes de UI Reutilizáveis ([`app/components/ui/`](app/components/ui/)) será inserido aqui.)*
</file>

<file path="docs/technical/05-state-management.md">
# 5. Gerenciamento de Estado ([`app/stores/`](app/stores/))

Este documento detalha a estratégia e as implementações de gerenciamento de estado utilizadas na aplicação Anatel2 (StayFocus), localizadas principalmente no diretório [`app/stores/`](app/stores/).

*(Conteúdo da Subtarefa 5: Análise do Gerenciamento de Estado ([`app/stores/`](app/stores/)) será inserido aqui.)*
</file>

<file path="docs/technical/06-libraries-services.md">
# 6. Bibliotecas e Serviços ([`app/lib/`](app/lib/))

Este documento aborda as bibliotecas externas, utilitários e serviços implementados no diretório [`app/lib/`](app/lib/) que suportam as funcionalidades da aplicação Anatel2 (StayFocus).

*(Conteúdo da Subtarefa 6: Análise dos Utilitários e Serviços ([`app/lib/`](app/lib/)) será inserido aqui.)*
</file>

<file path="docs/technical/README.md">
# Documentação Técnica do Projeto StayFocus (Anatel2)

Esta documentação técnica detalha a arquitetura, componentes e funcionalidades do projeto StayFocus (Anatel2). O objetivo é fornecer um guia compreensível para desenvolvedores e partes interessadas sobre os aspectos técnicos da aplicação.

## Índice

*   [Visão Geral do Projeto](./01-project-overview.md)
*   [Roteamento](./02-routing.md)
*   [Páginas da Aplicação](./03-pages/README.md)
*   [Componentes de UI Reutilizáveis](./04-ui-components.md)
*   [Gerenciamento de Estado](./05-state-management.md)
*   [Bibliotecas e Serviços Auxiliares](./06-libraries-services.md)
</file>

<file path="docs/exemplo-receita-unica.json">
{
  "nome": "Bolo de Cenoura Simples (Exemplo)",
  "descricao": "Um bolo de cenoura clássico, fofinho e fácil de fazer.",
  "categorias": ["sobremesa", "lanche"],
  "tags": ["Fácil", "Clássico", "Doce"],
  "tempoPreparo": 45,
  "porcoes": 8,
  "calorias": "350 kcal por porção (aprox.)",
  "imagem": "",
  "ingredientes": [
    { "nome": "Cenoura média ralada", "quantidade": 3, "unidade": "unidade" },
    { "nome": "Ovos", "quantidade": 3, "unidade": "unidade" },
    { "nome": "Óleo vegetal", "quantidade": 200, "unidade": "ml" },
    { "nome": "Açúcar", "quantidade": 250, "unidade": "g" },
    { "nome": "Farinha de trigo", "quantidade": 300, "unidade": "g" },
    { "nome": "Fermento em pó", "quantidade": 1, "unidade": "colher_sopa" }
  ],
  "passos": [
    "Pré-aqueça o forno a 180°C e unte uma forma.",
    "No liquidificador, bata as cenouras, os ovos e o óleo até ficar homogêneo.",
    "Despeje a mistura em uma tigela e adicione o açúcar e a farinha peneirada, misturando bem.",
    "Por último, incorpore delicadamente o fermento em pó.",
    "Despeje a massa na forma preparada e leve ao forno por cerca de 35-40 minutos, ou até que um palito inserido no centro saia limpo.",
    "Deixe esfriar antes de desenformar. Sirva com cobertura de chocolate, se desejar."
  ]
}
</file>

<file path="docs/exemplo-receitas-multiplas.json">
[
  {
    "nome": "Panqueca Americana (Exemplo)",
    "descricao": "Panquecas fofinhas clássicas para o café da manhã.",
    "categorias": ["cafe_manha"],
    "tags": ["Rápido", "Fácil"],
    "tempoPreparo": 20,
    "porcoes": 4,
    "calorias": "250 kcal por porção",
    "imagem": "",
    "ingredientes": [
      { "nome": "Farinha de trigo", "quantidade": 150, "unidade": "g" },
      { "nome": "Açúcar", "quantidade": 1, "unidade": "colher_sopa" },
      { "nome": "Fermento em pó", "quantidade": 2, "unidade": "colher_cha" },
      { "nome": "Sal", "quantidade": 0.5, "unidade": "colher_cha" },
      { "nome": "Leite", "quantidade": 240, "unidade": "ml" },
      { "nome": "Ovo", "quantidade": 1, "unidade": "unidade" },
      { "nome": "Manteiga derretida", "quantidade": 2, "unidade": "colher_sopa" }
    ],
    "passos": [
      "Em uma tigela grande, misture a farinha, o açúcar, o fermento e o sal.",
      "Em outra tigela, misture o leite, o ovo e a manteiga derretida.",
      "Despeje os ingredientes líquidos sobre os secos e misture apenas até incorporar (não misture demais).",
      "Aqueça uma frigideira levemente untada em fogo médio.",
      "Despeje cerca de 1/4 de xícara de massa por panqueca na frigideira quente.",
      "Cozinhe por cerca de 2 minutos de cada lado, ou até dourar.",
      "Sirva quente com mel, frutas ou sua cobertura preferida."
    ]
  },
  {
    "nome": "Salada Caesar Simples (Exemplo)",
    "descricao": "Uma versão rápida e fácil da clássica Salada Caesar.",
    "categorias": ["almoco", "jantar", "salada"],
    "tags": ["Rápido", "Leve", "Clássico"],
    "tempoPreparo": 15,
    "porcoes": 2,
    "calorias": "400 kcal por porção (com frango)",
    "imagem": "",
    "ingredientes": [
      { "nome": "Alface romana picada", "quantidade": 1, "unidade": "unidade" },
      { "nome": "Peito de frango grelhado em tiras", "quantidade": 200, "unidade": "g" },
      { "nome": "Croutons", "quantidade": 50, "unidade": "g" },
      { "nome": "Queijo parmesão ralado", "quantidade": 30, "unidade": "g" },
      { "nome": "Molho Caesar pronto", "quantidade": 4, "unidade": "colher_sopa" }
    ],
    "passos": [
      "Em uma saladeira grande, coloque a alface romana picada.",
      "Adicione o frango grelhado em tiras.",
      "Regue com o molho Caesar e misture bem para cobrir todas as folhas.",
      "Adicione os croutons e o queijo parmesão ralado.",
      "Misture levemente mais uma vez e sirva imediatamente."
    ]
  }
]
</file>

<file path="docs/guia-receitas.md">
# Guia de Implementação: Seção de Receitas na Página /alimentacao

## 1. Estrutura de Pastas e Arquivos

Crie a seguinte estrutura sugerida:

```
/components
  - ListaReceitas.tsx
  - FiltroCategorias.tsx
  - Pesquisa.tsx
  - Button.tsx
  - Tag.tsx
  - Input.tsx
  - Textarea.tsx
  - Select.tsx
  - TagInput.tsx
  - Checkbox.tsx
/pages ou /app
  /receitas
    - index.tsx (ou page.tsx)
    - [id].tsx (ou [id]/page.tsx)
    - adicionar.tsx (ou adicionar/page.tsx)
    - lista-compras.tsx (ou lista-compras/page.tsx)
/stores
  - receitasStore.ts
  - alimentacaoStore.ts
```

## 2. Store de Receitas

Implemente o arquivo `stores/receitasStore.ts` conforme o exemplo do documento de proposta. Isso garante o gerenciamento de receitas, favoritos e integração com o localStorage.

## 3. Componentes de UI

Implemente os componentes principais:
- `ReceitasPage` (listagem e filtro)
- `DetalhesReceita` (visualização detalhada)
- `AdicionarReceita` (formulário de criação/edição)
- `ListaCompras` (lista de compras baseada nas receitas)

Você pode copiar e colar os exemplos do documento de proposta, adaptando para o seu padrão de projeto (Next.js App Router ou Pages Router).

## 4. Integração com Alimentação

No arquivo da página `/alimentacao`, adicione um link ou botão para acessar a seção de receitas. Exemplo:

```tsx
// Em /pages/alimentacao/index.tsx ou /app/alimentacao/page.tsx
import Link from 'next/link';

export default function AlimentacaoPage() {
  return (
    <div>
      <h1>Alimentação</h1>
      {/* ...outros conteúdos... */}
      <Link href="/receitas">
        <button className="bg-primary-500 text-white px-4 py-2 rounded">
          Ir para Receitas
        </button>
      </Link>
    </div>
  );
}
```

## 5. Rotas

Garanta que as rotas estejam configuradas conforme o seu Next.js (App Router ou Pages Router). Isso permite acessar `/receitas`, `/receitas/adicionar`, `/receitas/[id]` e `/receitas/lista-compras`.

## 6. Sidebar/Navegação

Adicione o link para receitas no seu Sidebar, conforme sugerido:

```tsx
<Link href="/receitas">
  <Book /> Receitas
</Link>
```

## 7. Testes e Ajustes

- Teste a adição, edição, remoção e visualização de receitas.
- Teste a integração com o planejador de refeições.
- Teste a lista de compras.
- Ajuste responsividade e UX conforme necessário.

---

## Dúvidas Frequentes

- **Precisa de backend?** Não obrigatoriamente, pois o Zustand com persistência já salva no localStorage. Mas para multiusuários ou backup, um backend seria ideal.
- **Como tratar imagens?** O exemplo usa `URL.createObjectURL`, mas para produção, use um serviço de upload (Cloudinary, S3, etc).
- **Como integrar com outras áreas?** Use os IDs das receitas para relacionar com refeições planejadas, finanças, etc.

---
</file>

<file path="docs/receita-plan.md">
## Proposta para uma Seção de Receitas dentro da Pagina Alimentação (`/receitas`)

### Funcionalidades Principais:

1. **Catálogo de Receitas**
   - Visualização em grid/lista de receitas salvas
   - Filtragem por categorias (café da manhã, almoço, jantar, lanches, etc.)
   - Pesquisa por ingredientes ou nome

2. **Detalhes da Receita**
   - Ingredientes com quantidades
   - Instruções passo a passo
   - Tempo de preparo e porções
   - Informações nutricionais
   - Tags para categorização (sem glúten, vegano, etc.)

3. **Adição/Edição de Receitas**
   - Formulário para adicionar novas receitas
   - Upload de imagens
   - Editor para formatação do texto

4. **Integração com Alimentação**
   - Adicionar receita ao planejador de refeições
   - Registrar refeição baseada em receita

5. **Funcionalidades Extra**
   - Lista de compras baseada em receitas selecionadas
   - Ajuste automático de quantidades baseado no número de porções
   - Favoritar receitas

Possivel estrutura de código e componentes para essa seção:

### Componentes Chave:

#### `ReceitasPage.tsx` (Página principal)
```tsx
import { useState } from 'react';
import { ListaReceitas } from './ListaReceitas';
import { FiltroCategorias } from './FiltroCategorias';
import { Pesquisa } from '../components/Pesquisa';
import { useReceitasStore } from '../stores/receitasStore';

export default function ReceitasPage() {
  const { receitas } = useReceitasStore();
  const [filtroCategoria, setFiltroCategoria] = useState('todas');
  const [termoPesquisa, setTermoPesquisa] = useState('');
  
  const receitasFiltradas = receitas
    .filter(receita => filtroCategoria === 'todas' || receita.categorias.includes(filtroCategoria))
    .filter(receita => 
      receita.nome.toLowerCase().includes(termoPesquisa.toLowerCase()) ||
      receita.ingredientes.some(ing => ing.nome.toLowerCase().includes(termoPesquisa.toLowerCase()))
    );

  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-6">Minhas Receitas</h1>
      
      <div className="flex flex-col sm:flex-row gap-4 mb-6">
        <Pesquisa 
          placeholder="Buscar por nome ou ingrediente" 
          valor={termoPesquisa} 
          aoMudar={setTermoPesquisa} 
        />
        <FiltroCategorias 
          categoriaAtual={filtroCategoria} 
          aoSelecionar={setFiltroCategoria} 
        />
      </div>
      
      <ListaReceitas receitas={receitasFiltradas} />
    </div>
  );
}
```

#### `DetalhesReceita.tsx` (Visualização detalhada)
```tsx
import { useState } from 'react';
import { useReceitasStore } from '../stores/receitasStore';
import { useAlimentacaoStore } from '../stores/alimentacaoStore';
import { Button } from '../components/Button';
import { Tag } from '../components/Tag';

export function DetalhesReceita({ id }) {
  const { obterReceitaPorId } = useReceitasStore();
  const { adicionarAoPlanejador } = useAlimentacaoStore();
  const [porcoes, setPorcoes] = useState(1);
  
  const receita = obterReceitaPorId(id);
  
  if (!receita) return <p>Receita não encontrada</p>;
  
  const ajustarQuantidade = (quantidade) => {
    return (quantidade * porcoes / receita.porcoes).toFixed(1);
  };
  
  const adicionarAoPlanejamento = () => {
    adicionarAoPlanejador({
      descricao: receita.nome,
      horario: "",
      receitaId: receita.id
    });
  };
  
  return (
    <div className="p-4 max-w-4xl mx-auto">
      <div className="relative h-64 rounded-lg overflow-hidden mb-6">
        {receita.imagem ? (
          <img 
            src={receita.imagem} 
            alt={receita.nome} 
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="w-full h-full bg-gray-200 flex items-center justify-center">
            <span>Sem imagem</span>
          </div>
        )}
      </div>
      
      <h1 className="text-3xl font-bold mb-2">{receita.nome}</h1>
      
      <div className="flex flex-wrap gap-2 mb-6">
        {receita.tags.map(tag => (
          <Tag key={tag}>{tag}</Tag>
        ))}
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <div className="bg-primary-50 p-3 rounded-lg text-center">
          <p className="text-sm">Tempo de Preparo</p>
          <p className="font-bold">{receita.tempoPreparo} min</p>
        </div>
        <div className="bg-primary-50 p-3 rounded-lg text-center">
          <p className="text-sm">Porções</p>
          <div className="flex items-center justify-center gap-2">
            <button onClick={() => setPorcoes(Math.max(1, porcoes - 1))}>-</button>
            <p className="font-bold">{porcoes}</p>
            <button onClick={() => setPorcoes(porcoes + 1)}>+</button>
          </div>
        </div>
        <div className="bg-primary-50 p-3 rounded-lg text-center">
          <p className="text-sm">Calorias (por porção)</p>
          <p className="font-bold">{receita.calorias || "Não informado"}</p>
        </div>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        <div className="md:col-span-1">
          <h2 className="text-xl font-bold mb-4">Ingredientes</h2>
          <ul className="space-y-2">
            {receita.ingredientes.map((ing, index) => (
              <li key={index} className="flex items-start gap-2">
                <span className="font-medium">{ajustarQuantidade(ing.quantidade)} {ing.unidade}</span>
                <span>{ing.nome}</span>
              </li>
            ))}
          </ul>
          
          <div className="mt-6">
            <Button onClick={adicionarAoPlanejamento} color="primary">
              Adicionar ao Planejador
            </Button>
          </div>
        </div>
        
        <div className="md:col-span-2">
          <h2 className="text-xl font-bold mb-4">Modo de Preparo</h2>
          <ol className="space-y-4 list-decimal pl-4">
            {receita.passos.map((passo, index) => (
              <li key={index} className="pl-2">
                {passo}
              </li>
            ))}
          </ol>
        </div>
      </div>
    </div>
  );
}
```

#### `AdicionarReceita.tsx` (Formulário de adição/edição)
```tsx
import { useState } from 'react';
import { useReceitasStore } from '../stores/receitasStore';
import { Button } from '../components/Button';
import { Input } from '../components/Input';
import { Textarea } from '../components/Textarea';
import { Select } from '../components/Select';
import { TagInput } from '../components/TagInput';

export function AdicionarReceita({ receitaParaEditar, aoFinalizar }) {
  const { adicionarReceita, atualizarReceita } = useReceitasStore();
  const editando = !!receitaParaEditar;
  
  const [receita, setReceita] = useState({
    id: receitaParaEditar?.id || Date.now().toString(),
    nome: receitaParaEditar?.nome || '',
    descricao: receitaParaEditar?.descricao || '',
    categorias: receitaParaEditar?.categorias || [],
    tags: receitaParaEditar?.tags || [],
    tempoPreparo: receitaParaEditar?.tempoPreparo || 30,
    porcoes: receitaParaEditar?.porcoes || 2,
    calorias: receitaParaEditar?.calorias || '',
    imagem: receitaParaEditar?.imagem || '',
    ingredientes: receitaParaEditar?.ingredientes || [{ nome: '', quantidade: 1, unidade: 'g' }],
    passos: receitaParaEditar?.passos || ['']
  });
  
  const opcoesUnidades = [
    { value: 'g', label: 'gramas (g)' },
    { value: 'ml', label: 'mililitros (ml)' },
    { value: 'unidade', label: 'unidade(s)' },
    { value: 'colher_sopa', label: 'colher(es) de sopa' },
    { value: 'colher_cha', label: 'colher(es) de chá' },
    { value: 'xicara', label: 'xícara(s)' },
    { value: 'a_gosto', label: 'a gosto' },
  ];
  
  const categorias = [
    { value: 'cafe_manha', label: 'Café da Manhã' },
    { value: 'almoco', label: 'Almoço' },
    { value: 'jantar', label: 'Jantar' },
    { value: 'lanche', label: 'Lanche' },
    { value: 'sobremesa', label: 'Sobremesa' },
    { value: 'bebida', label: 'Bebida' }
  ];
  
  const atualizarCampo = (campo, valor) => {
    setReceita({ ...receita, [campo]: valor });
  };
  
  const atualizarIngrediente = (index, campo, valor) => {
    const novosIngredientes = [...receita.ingredientes];
    novosIngredientes[index] = { ...novosIngredientes[index], [campo]: valor };
    setReceita({ ...receita, ingredientes: novosIngredientes });
  };
  
  const adicionarIngrediente = () => {
    setReceita({
      ...receita,
      ingredientes: [...receita.ingredientes, { nome: '', quantidade: 1, unidade: 'g' }]
    });
  };
  
  const removerIngrediente = (index) => {
    const novosIngredientes = [...receita.ingredientes];
    novosIngredientes.splice(index, 1);
    setReceita({ ...receita, ingredientes: novosIngredientes });
  };
  
  const atualizarPasso = (index, valor) => {
    const novosPassos = [...receita.passos];
    novosPassos[index] = valor;
    setReceita({ ...receita, passos: novosPassos });
  };
  
  const adicionarPasso = () => {
    setReceita({
      ...receita,
      passos: [...receita.passos, '']
    });
  };
  
  const removerPasso = (index) => {
    const novosPassos = [...receita.passos];
    novosPassos.splice(index, 1);
    setReceita({ ...receita, passos: novosPassos });
  };
  
  const salvarReceita = () => {
    // Validação básica
    if (!receita.nome || receita.ingredientes.some(ing => !ing.nome) || receita.passos.some(p => !p)) {
      alert('Por favor, preencha todos os campos obrigatórios.');
      return;
    }
    
    if (editando) {
      atualizarReceita(receita);
    } else {
      adicionarReceita(receita);
    }
    
    aoFinalizar && aoFinalizar(receita);
  };
  
  return (
    <div className="p-4 max-w-4xl mx-auto">
      <h1 className="text-2xl font-bold mb-6">
        {editando ? 'Editar Receita' : 'Nova Receita'}
      </h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div>
          <label className="block mb-2 font-medium">Nome da Receita*</label>
          <Input
            value={receita.nome}
            onChange={(e) => atualizarCampo('nome', e.target.value)}
            placeholder="Ex: Panquecas de Banana"
            required
          />
        </div>
        
        <div>
          <label className="block mb-2 font-medium">Categorias</label>
          <Select
            options={categorias}
            value={receita.categorias}
            onChange={(value) => atualizarCampo('categorias', value)}
            multiple
          />
        </div>
      </div>
      
      <div className="mb-6">
        <label className="block mb-2 font-medium">Descrição Breve</label>
        <Textarea
          value={receita.descricao}
          onChange={(e) => atualizarCampo('descricao', e.target.value)}
          placeholder="Uma breve descrição sobre a receita..."
          rows={2}
        />
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
        <div>
          <label className="block mb-2 font-medium">Tempo de Preparo (min)*</label>
          <Input
            type="number"
            value={receita.tempoPreparo}
            onChange={(e) => atualizarCampo('tempoPreparo', parseInt(e.target.value))}
            min={1}
          />
        </div>
        
        <div>
          <label className="block mb-2 font-medium">Porções*</label>
          <Input
            type="number"
            value={receita.porcoes}
            onChange={(e) => atualizarCampo('porcoes', parseInt(e.target.value))}
            min={1}
          />
        </div>
        
        <div>
          <label className="block mb-2 font-medium">Calorias (por porção)</label>
          <Input
            type="number"
            value={receita.calorias}
            onChange={(e) => atualizarCampo('calorias', e.target.value)}
            min={0}
            placeholder="Opcional"
          />
        </div>
      </div>
      
      <div className="mb-6">
        <label className="block mb-2 font-medium">Tags</label>
        <TagInput
          tags={receita.tags}
          onChange={(tags) => atualizarCampo('tags', tags)}
          suggestions={['Sem Glúten', 'Vegano', 'Vegetariano', 'Low Carb', 'Rápido', 'Saudável']}
        />
      </div>
      
      <div className="mb-6">
        <label className="block mb-2 font-medium">Imagem</label>
        <Input
          type="file"
          accept="image/*"
          onChange={(e) => {
            // Aqui você implementaria o upload da imagem
            // Por simplicidade, simulamos um URL da imagem
            if (e.target.files?.[0]) {
              const fileURL = URL.createObjectURL(e.target.files[0]);
              atualizarCampo('imagem', fileURL);
            }
          }}
        />
        {receita.imagem && (
          <div className="mt-2 relative h-40 w-40">
            <img 
              src={receita.imagem} 
              alt="Preview" 
              className="w-full h-full object-cover rounded"
            />
          </div>
        )}
      </div>
      
      <div className="mb-6">
        <div className="flex justify-between items-center mb-2">
          <h2 className="text-xl font-bold">Ingredientes*</h2>
          <Button onClick={adicionarIngrediente} size="sm">+ Adicionar</Button>
        </div>
        
        {receita.ingredientes.map((ingrediente, index) => (
          <div key={index} className="flex items-center gap-3 mb-2">
            <Input
              type="number"
              value={ingrediente.quantidade}
              onChange={(e) => atualizarIngrediente(index, 'quantidade', parseFloat(e.target.value))}
              min={0}
              step={0.1}
              className="w-24"
            />
            
            <Select
              options={opcoesUnidades}
              value={ingrediente.unidade}
              onChange={(value) => atualizarIngrediente(index, 'unidade', value)}
              className="w-40"
            />
            
            <Input
              value={ingrediente.nome}
              onChange={(e) => atualizarIngrediente(index, 'nome', e.target.value)}
              placeholder="Ingrediente"
              className="flex-1"
            />
            
            <Button 
              onClick={() => removerIngrediente(index)} 
              variant="ghost" 
              size="sm"
              disabled={receita.ingredientes.length <= 1}
            >
              X
            </Button>
          </div>
        ))}
      </div>
      
      <div className="mb-6">
        <div className="flex justify-between items-center mb-2">
          <h2 className="text-xl font-bold">Modo de Preparo*</h2>
          <Button onClick={adicionarPasso} size="sm">+ Adicionar</Button>
        </div>
        
        {receita.passos.map((passo, index) => (
          <div key={index} className="flex items-start gap-3 mb-4">
            <div className="mt-2 font-medium">{index + 1}.</div>
            <Textarea
              value={passo}
              onChange={(e) => atualizarPasso(index, e.target.value)}
              placeholder={`Passo ${index + 1}`}
              className="flex-1"
              rows={2}
            />
            
            <Button 
              onClick={() => removerPasso(index)} 
              variant="ghost" 
              size="sm"
              disabled={receita.passos.length <= 1}
            >
              X
            </Button>
          </div>
        ))}
      </div>
      
      <div className="flex justify-end gap-4">
        <Button onClick={() => aoFinalizar?.()} variant="outline">Cancelar</Button>
        <Button onClick={salvarReceita} color="primary">Salvar Receita</Button>
      </div>
    </div>
  );
}
```

### Store para Gerenciamento de Estado

Vamos criar uma store Zustand para armazenar e gerenciar as receitas:

```tsx
// stores/receitasStore.ts
import create from 'zustand';
import { persist } from 'zustand/middleware';

interface Ingrediente {
  nome: string;
  quantidade: number;
  unidade: string;
}

interface Receita {
  id: string;
  nome: string;
  descricao: string;
  categorias: string[];
  tags: string[];
  tempoPreparo: number;
  porcoes: number;
  calorias: string;
  imagem: string;
  ingredientes: Ingrediente[];
  passos: string[];
}

interface ReceitasStore {
  receitas: Receita[];
  adicionarReceita: (receita: Receita) => void;
  atualizarReceita: (receita: Receita) => void;
  removerReceita: (id: string) => void;
  obterReceitaPorId: (id: string) => Receita | undefined;
  favoritos: string[];
  alternarFavorito: (id: string) => void;
}

export const useReceitasStore = create<ReceitasStore>()(
  persist(
    (set, get) => ({
      receitas: [],
      adicionarReceita: (receita) => 
        set((state) => ({ receitas: [...state.receitas, receita] })),
      atualizarReceita: (receita) =>
        set((state) => ({
          receitas: state.receitas.map((r) => 
            r.id === receita.id ? receita : r
          ),
        })),
      removerReceita: (id) =>
        set((state) => ({
          receitas: state.receitas.filter((r) => r.id !== id),
        })),
      obterReceitaPorId: (id) => {
        return get().receitas.find((r) => r.id === id);
      },
      favoritos: [],
      alternarFavorito: (id) => 
        set((state) => {
          if (state.favoritos.includes(id)) {
            return { favoritos: state.favoritos.filter((fav) => fav !== id) };
          } else {
            return { favoritos: [...state.favoritos, id] };
          }
        }),
    }),
    {
      name: 'receitas-storage',
    }
  )
);
```

### Integração com a Alimentação

Para integrar a funcionalidade de receitas com a seção de alimentação existente, podemos modificar o `PlanejadorRefeicoes.tsx` para suportar a adição de receitas:

```tsx
// Modificação para o PlanejadorRefeicoes.tsx
import { useState, useEffect } from 'react';
import { useAlimentacaoStore } from '../stores/alimentacaoStore';
import { useReceitasStore } from '../stores/receitasStore';

export function PlanejadorRefeicoes() {
  const { refeicoesPlanejadas, adicionarRefeicao } = useAlimentacaoStore();
  const { receitas } = useReceitasStore();
  const [novaRefeicao, setNovaRefeicao] = useState({
    horario: "",
    descricao: "",
    receitaId: ""
  });
  
  const handleAdicionarRefeicao = () => {
    adicionarRefeicao(
      novaRefeicao.horario, 
      novaRefeicao.descricao, 
      novaRefeicao.receitaId
    );
    
    // Resetar o formulário
    setNovaRefeicao({
      horario: "",
      descricao: "",
      receitaId: ""
    });
  };
  
  return (
    <div>
      <h2 className="text-xl font-bold mb-4">Planejador de Refeições</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div>
          <label className="block mb-1">Horário</label>
          <input
            type="time"
            value={novaRefeicao.horario}
            onChange={(e) => setNovaRefeicao({...novaRefeicao, horario: e.target.value})}
            className="w-full p-2 border rounded"
          />
        </div>
        
        <div>
          <label className="block mb-1">Descrição</label>
          <input
            type="text"
            value={novaRefeicao.descricao}
            onChange={(e) => setNovaRefeicao({...novaRefeicao, descricao: e.target.value})}
            placeholder="Ex: Café da manhã"
            className="w-full p-2 border rounded"
          />
        </div>
        
        <div>
          <label className="block mb-1">Receita (opcional)</label>
          <select
            value={novaRefeicao.receitaId}
            onChange={(e) => setNovaRefeicao({...novaRefeicao, receitaId: e.target.value})}
            className="w-full p-2 border rounded"
          >
            <option value="">Selecione uma receita</option>
            {receitas.map((receita) => (
              <option key={receita.id} value={receita.id}>
                {receita.nome}
              </option>
            ))}
          </select>
        </div>
      </div>
      
      <button
        onClick={handleAdicionarRefeicao}
        disabled={!novaRefeicao.horario || !novaRefeicao.descricao}
        className="bg-primary-500 text-white px-4 py-2 rounded disabled:opacity-50"
      >
        Adicionar Refeição
      </button>
      
      <div className="mt-6">
        <h3 className="font-medium mb-2">Refeições Planejadas</h3>
        {refeicoesPlanejadas.length === 0 ? (
          <p className="text-gray-500">Nenhuma refeição planejada</p>
        ) : (
          <ul className="space-y-2">
            {refeicoesPlanejadas.map((refeicao, index) => {
              const receitaAssociada = refeicao.receitaId 
                ? receitas.find(r => r.id === refeicao.receitaId) 
                : null;
                
              return (
                <li key={index} className="p-3 bg-gray-50 rounded">
                  <div className="font-medium">{refeicao.horario} - {refeicao.descricao}</div>
                  {receitaAssociada && (
                    <div className="text-sm text-primary-600 mt-1">
                      Receita: {receitaAssociada.nome}
                    </div>
                  )}
                </li>
              );
            })}
          </ul>
        )}
      </div>
    </div>
  );
}
```

### Componente de Lista de Compras (Funcionalidade Extra)

```tsx
import { useState } from 'react';
import { useReceitasStore } from '../stores/receitasStore';
import { Checkbox } from '../components/Checkbox';
import { Button } from '../components/Button';

export function ListaCompras() {
  const { receitas } = useReceitasStore();
  const [receitasSelecionadas, setReceitasSelecionadas] = useState<string[]>([]);
  const [porcoes, setPorcoes] = useState<Record<string, number>>({});
  const [itensComprados, setItensComprados] = useState<string[]>([]);
  
  // Inicializar porcões ao selecionar uma receita
  const toggleReceitaSelecionada = (id: string) => {
    if (receitasSelecionadas.includes(id)) {
      setReceitasSelecionadas(receitasSelecionadas.filter(rid => rid !== id));
      
      // Remover do objeto de porções
      const novasPorcoes = { ...porcoes };
      delete novasPorcoes[id];
      setPorcoes(novasPorcoes);
    } else {
      setReceitasSelecionadas([...receitasSelecionadas, id]);
      
      // Inicializar com o número de porções da receita
      const receita = receitas.find(r => r.id === id);
      if (receita) {
        setPorcoes({
          ...porcoes,
          [id]: receita.porcoes
        });
      }
    }
  };
  
  const atualizarPorcoes = (id: string, valor: number) => {
    setPorcoes({
      ...porcoes,
      [id]: Math.max(1, valor)
    });
  };
  
  // Agrupar ingredientes similares e calcular quantidades
  const gerarListaCompras = () => {
    const ingredientesAgrupados: Record<string, { 
      nome: string, 
      quantidadeTotal: number, 
      unidade: string 
    }> = {};
    
    // Para cada receita selecionada
    receitasSelecionadas.forEach(id => {
      const receita = receitas.find(r => r.id === id);
      if (!receita) return;
      
      const fatorMultiplicacao = porcoes[id] / receita.porcoes;
      
      // Para cada ingrediente na receita
      receita.ingredientes.forEach(ing => {
        // Criar uma chave única para o ingrediente (nome + unidade)
        const chave = `${ing.nome}_${ing.unidade}`;
        
        if (ingredientesAgrupados[chave]) {
          // Se já existe, adicionar à quantidade
          ingredientesAgrupados[chave].quantidadeTotal += ing.quantidade * fatorMultiplicacao;
        } else {
          // Se não existe, criar nova entrada
          ingredientesAgrupados[chave] = {
            nome: ing.nome,
            quantidadeTotal: ing.quantidade * fatorMultiplicacao,
            unidade: ing.unidade
          };
        }
      });
    });
    
    // Converter para array e ordenar
    return Object.values(ingredientesAgrupados)
      .sort((a, b) => a.nome.localeCompare(b.nome));
  };
  
  const listaCompras = gerarListaCompras();
  
  const toggleItemComprado = (item: string) => {
    if (itensComprados.includes(item)) {
      setItensComprados(itensComprados.filter(i => i !== item));
    } else {
      setItensComprados([...itensComprados, item]);
    }
  };
  
  return (
    <div className="p-4">
      <h1 className="text-2xl font-bold mb-6">Lista de Compras</h1>
      
      <div className="mb-8">
        <h2 className="text-xl font-bold mb-4">Selecione as Receitas</h2>
        
        {receitas.length === 0 ? (
          <p
Vou continuar com o desenvolvimento do componente de Lista de Compras e finalizar a proposta para a seção de receitas.

```tsx
// Continuação do ListaCompras.tsx
        {receitas.length === 0 ? (
          <p className="text-gray-500">
            Nenhuma receita cadastrada. Adicione receitas para criar uma lista de compras.
          </p>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
            {receitas.map(receita => (
              <div 
                key={receita.id} 
                className={`p-3 border rounded cursor-pointer transition-colors ${
                  receitasSelecionadas.includes(receita.id) 
                    ? 'border-primary-500 bg-primary-50' 
                    : 'border-gray-200'
                }`}
                onClick={() => toggleReceitaSelecionada(receita.id)}
              >
                <div className="flex items-start gap-3">
                  <Checkbox 
                    checked={receitasSelecionadas.includes(receita.id)}
                    onChange={() => {}} // Gerenciado pelo click no container
                  />
                  <div>
                    <p className="font-medium">{receita.nome}</p>
                    {receitasSelecionadas.includes(receita.id) && (
                      <div className="mt-2 flex items-center gap-2">
                        <span className="text-sm">Porções:</span>
                        <button 
                          className="w-6 h-6 bg-gray-200 rounded"
                          onClick={(e) => {
                            e.stopPropagation();
                            atualizarPorcoes(receita.id, (porcoes[receita.id] || 1) - 1);
                          }}
                        >
                          -
                        </button>
                        <span>{porcoes[receita.id] || receita.porcoes}</span>
                        <button 
                          className="w-6 h-6 bg-gray-200 rounded"
                          onClick={(e) => {
                            e.stopPropagation();
                            atualizarPorcoes(receita.id, (porcoes[receita.id] || 1) + 1);
                          }}
                        >
                          +
                        </button>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
      
      {receitasSelecionadas.length > 0 && (
        <div>
          <h2 className="text-xl font-bold mb-4">Lista de Compras</h2>
          
          {listaCompras.length === 0 ? (
            <p className="text-gray-500">
              Nenhum ingrediente encontrado nas receitas selecionadas.
            </p>
          ) : (
            <>
              <div className="mb-4 flex gap-2">
                <Button 
                  onClick={() => setItensComprados([])} 
                  variant="outline"
                >
                  Desmarcar Todos
                </Button>
                <Button 
                  onClick={() => setItensComprados(listaCompras.map(i => `${i.nome}_${i.unidade}`))} 
                  variant="outline"
                >
                  Marcar Todos
                </Button>
              </div>
              
              <ul className="space-y-2 mb-6">
                {listaCompras.map((item, index) => {
                  const itemKey = `${item.nome}_${item.unidade}`;
                  const isComprado = itensComprados.includes(itemKey);
                  
                  return (
                    <li 
                      key={index} 
                      className={`p-3 border rounded flex items-center gap-3 ${
                        isComprado ? 'bg-gray-100' : 'bg-white'
                      }`}
                    >
                      <Checkbox 
                        checked={isComprado}
                        onChange={() => toggleItemComprado(itemKey)}
                      />
                      <span className={isComprado ? 'line-through text-gray-500' : ''}>
                        <span className="font-medium">
                          {item.quantidadeTotal.toFixed(1)} {item.unidade}
                        </span>
                        {' '}{item.nome}
                      </span>
                    </li>
                  );
                })}
              </ul>
              
              <Button color="primary">
                Compartilhar Lista
              </Button>
            </>
          )}
        </div>
      )}
    </div>
  );
}
```

### Navegação e Rotas

Para completar a implementação, precisamos adicionar as rotas e links de navegação:

#### Rotas no Next.js (pasta `app` ou `pages` dependendo da versão do Next.js)

Se estiver usando o App Router (Next.js >= 13):

```tsx
// app/receitas/page.tsx
export default function ReceitasPage() {
  return <ReceitasPage />;
}

// app/receitas/[id]/page.tsx
export default function ReceitaDetalhesPage({ params }) {
  return <DetalhesReceita id={params.id} />;
}

// app/receitas/adicionar/page.tsx
export default function AdicionarReceitaPage() {
  return <AdicionarReceita />;
}

// app/receitas/lista-compras/page.tsx
export default function ListaComprasPage() {
  return <ListaCompras />;
}
```

Ou, se estiver usando o Pages Router (versões anteriores do Next.js):

```tsx
// pages/receitas/index.tsx
export default function ReceitasPage() {
  return <ReceitasPage />;
}

// pages/receitas/[id].tsx
export default function ReceitaDetalhesPage({ id }) {
  return <DetalhesReceita id={id} />;
}

// pages/receitas/adicionar.tsx
export default function AdicionarReceitaPage() {
  return <AdicionarReceita />;
}

// pages/receitas/lista-compras.tsx
export default function ListaComprasPage() {
  return <ListaCompras />;
}
```

#### Atualização do Sidebar para incluir a seção de Receitas

```tsx
// Modificação no Sidebar.tsx
import { Utensils, Book, ShoppingCart } from 'lucide-react'; // Adicione os imports necessários

// No componente Sidebar, adicione:
<Link href="/alimentacao">
  <Utensils /> Alimentação
</Link>
<Link href="/receitas">
  <Book /> Receitas
</Link>
```

## Considerações de Implementação

### 1. Armazenamento de Dados
- Estou utilizando o Zustand com middleware `persist` para armazenar as receitas no localStorage.
- Para uma aplicação mais robusta, considere implementar um backend com banco de dados.

### 2. Manipulação de Imagens
- O upload de imagens no formulário foi implementado de forma simplificada com URL.createObjectURL.
- Para uma implementação completa, considere:
  - Compressão de imagens no cliente
  - Upload para um serviço de armazenamento (S3, Cloudinary, etc.)
  - Implementar cache e otimização de imagens

### 3. Responsividade
- Os componentes foram projetados com classes responsivas (grid-cols-1 md:grid-cols-3, etc.)
- Teste o layout em diferentes tamanhos de telas para garantir boa experiência móvel

### 4. Recursos Adicionais que Podem Ser Implementados
- **Sistema de avaliação** - Permitir classificar receitas com estrelas
- **Comentários** - Adicionar notas pessoais a cada receita
- **Calendário de refeições** - Visualização em formato de calendário para o planejamento
- **Importação/exportação** - Permitir importar receitas de outros sites ou exportar para formatos como PDF
- **Versões de receitas** - Salvar variações de uma mesma receita
</file>

<file path="pages/api/auth/google/callback.ts">
import { google } from 'googleapis';
import { NextApiRequest, NextApiResponse } from 'next';
import { IronSession, IronSessionData } from 'iron-session'; // Keep IronSessionData for casting
import { withSessionRoute } from '@/app/lib/session';

const CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
const CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
const REDIRECT_URI = process.env.NODE_ENV === 'production' 
  ? 'https://stayfocus-main.vercel.app/api/auth/google/callback' 
  : 'http://localhost:3000/api/auth/google/callback';

if (!CLIENT_ID || !CLIENT_SECRET) {
  throw new Error('Missing Google OAuth credentials in environment variables');
}

const oauth2Client = new google.auth.OAuth2(
  CLIENT_ID,
  CLIENT_SECRET,
  REDIRECT_URI
);

// Define the handler function with standard types expected by withSessionRoute
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Cast req to include the session property for use within the handler
  const sessionReq = req as NextApiRequest & { session: IronSession<IronSessionData> };

  if (sessionReq.method !== 'GET') {
    res.setHeader('Allow', ['GET']);
    return res.status(405).end(`Method ${sessionReq.method} Not Allowed`);
  }

  const { code, error, state } = sessionReq.query;

  // Handle potential errors from Google
  if (error) {
    console.error('Google OAuth Error:', error);
    // Redirect to an error page or show an error message
    return res.status(400).redirect('/perfil?error=google_auth_failed'); // Redirect to profile page with error query param
  }

  // Ensure we received a code
  if (typeof code !== 'string') {
    console.error('Invalid code received from Google');
    return res.status(400).redirect('/perfil?error=invalid_code'); 
  }

  // Optional: Validate state parameter here if you implemented CSRF protection

  try {
    // Exchange the code for tokens
    const { tokens } = await oauth2Client.getToken(code);

    if (!tokens || !tokens.access_token || !tokens.expiry_date) {
      throw new Error('Failed to retrieve valid tokens from Google');
    }
    
    // Store tokens in the session using the casted request object
    sessionReq.session.tokens = {
      access_token: tokens.access_token,
      // Handle potential null refresh_token explicitly
      refresh_token: tokens.refresh_token ?? undefined, 
      expiry_date: tokens.expiry_date,
      token_type: tokens.token_type, 
      scope: tokens.scope || undefined,
    };

    // Save the session using the casted request object
    await sessionReq.session.save();

    console.log('Google OAuth successful, tokens saved to session.'); 

    // Redirect user back to the application (e.g., profile page)
    // You might want to redirect to the specific page where the user initiated the auth
    res.redirect('/perfil?google_auth=success'); 

  } catch (err: any) {
    console.error('Error exchanging Google OAuth code for tokens:', err.message);
    // Redirect to an error page or show an error message
    res.status(500).redirect('/perfil?error=token_exchange_failed');
  }
}; // End of handler function definition

// Wrap the explicitly typed handler function
export default withSessionRoute(handler);
</file>

<file path="pages/api/auth/google/connect.ts">
import { google } from 'googleapis';
import { NextApiRequest, NextApiResponse } from 'next';

const CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
const CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
// Ensure this matches the one configured in Google Cloud Console
const REDIRECT_URI = process.env.NODE_ENV === 'production' 
  ? 'https://stayfocus-main.vercel.app/api/auth/google/callback' 
  : 'http://localhost:3000/api/auth/google/callback';

if (!CLIENT_ID || !CLIENT_SECRET) {
  throw new Error('Missing Google OAuth credentials in environment variables');
}

const oauth2Client = new google.auth.OAuth2(
  CLIENT_ID,
  CLIENT_SECRET,
  REDIRECT_URI
);

// Define the scopes needed. 'drive.file' allows access only to files created or opened by the app.
const scopes = [
  'https://www.googleapis.com/auth/userinfo.profile', // Get basic profile info (optional)
  'https://www.googleapis.com/auth/userinfo.email',   // Get email address (optional)
  'https://www.googleapis.com/auth/drive.file'        // Per-file access to files created or opened by the app
];

export default function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    res.setHeader('Allow', ['GET']);
    return res.status(405).end(`Method ${req.method} Not Allowed`);
  }

  const authorizationUrl = oauth2Client.generateAuthUrl({
    access_type: 'offline', // Request refresh token
    scope: scopes,
    include_granted_scopes: true,
    // Consider adding state parameter for CSRF protection if needed
    // state: 'some_random_string' 
  });

  res.redirect(authorizationUrl);
}
</file>

<file path="pages/api/auth/google/disconnect.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { IronSession, IronSessionData } from 'iron-session';
import { withSessionRoute } from '@/app/lib/session';

// Define the handler function with standard types expected by withSessionRoute
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Cast req to include the session property
  const sessionReq = req as NextApiRequest & { session: IronSession<IronSessionData> };

  if (sessionReq.method !== 'POST') { // Use POST for actions that change state
    res.setHeader('Allow', ['POST']);
    return res.status(405).end(`Method ${sessionReq.method} Not Allowed`);
  }

  try {
    // Destroy the session (clears tokens)
    sessionReq.session.destroy();
    console.log('Session destroyed (Google Disconnected).');
    res.status(200).json({ success: true, message: 'Disconnected successfully.' });
  } catch (error: any) {
    console.error('Error destroying session:', error.message);
    res.status(500).json({ error: 'Failed to disconnect.' });
  }
};

export default withSessionRoute(handler);
</file>

<file path="pages/api/drive/carregar-material.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { google } from 'googleapis';
import { IronSession, IronSessionData } from 'iron-session';
import { withSessionRoute } from '@/app/lib/session';
import { getAuthenticatedClient } from '@/app/lib/googleDriveClient';
import { WritableStreamBuffer } from 'stream-buffers'; // Need to install stream-buffers

// Define the handler function with standard types expected by withSessionRoute
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Cast req to include the session property
  const sessionReq = req as NextApiRequest & { session: IronSession<IronSessionData> };

  if (sessionReq.method !== 'GET') {
    res.setHeader('Allow', ['GET']);
    return res.status(405).end(`Method ${sessionReq.method} Not Allowed`);
  }

  const { fileId } = sessionReq.query;

  if (!fileId || typeof fileId !== 'string') {
    return res.status(400).json({ error: 'Missing or invalid fileId query parameter.' });
  }

  try {
    const oauth2Client = await getAuthenticatedClient(sessionReq.session);
    if (!oauth2Client) {
      return res.status(401).json({ error: 'Unauthorized or token refresh failed.' });
    }

    const drive = google.drive({ version: 'v3', auth: oauth2Client });

    console.log(`Attempting to download file with ID: ${fileId}`);

    // Get the file content
    const fileResponse = await drive.files.get(
      { fileId: fileId, alt: 'media' },
      { responseType: 'stream' } // Request response as a stream
    );

    // Pipe the stream to a buffer to get the full content
    const dest = new WritableStreamBuffer();
    // Correctly handle the promise for stream completion/error
    await new Promise<void>((resolve, reject) => { // Add void type parameter for clarity
      const stream = fileResponse.data as NodeJS.ReadableStream; // Cast to NodeJS stream type
      stream.on('end', () => resolve());
      stream.on('error', (err) => reject(err)); // Pass error to reject
      stream.pipe(dest);
    }); // Correct closing parenthesis and semicolon placement

    const fileContent = dest.getContentsAsString('utf8');

    if (!fileContent) {
       throw new Error('Downloaded file content is empty.');
    }

    console.log(`File ${fileId} downloaded successfully.`);

    // Send the file content back
    res.status(200).json({ success: true, content: fileContent });

  } catch (error: any) {
    console.error(`Error loading material ${fileId} from Google Drive:`, error.message);
    if (error.response?.data?.error?.message) {
       console.error('Google API Error Details:', error.response.data.error.message);
       res.status(500).json({ error: `Google Drive API error loading material: ${error.response.data.error.message}` });
    } else if (error.response?.status === 404) {
       res.status(404).json({ error: 'Material not found on Google Drive.' });
    } else {
       res.status(500).json({ error: 'Failed to load material from Google Drive.' });
    }
  }
};

export default withSessionRoute(handler);
</file>

<file path="pages/api/drive/checkAuth.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { IronSession, IronSessionData } from 'iron-session';
import { withSessionRoute } from '@/app/lib/session';

// Define the handler function with standard types expected by withSessionRoute
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Cast req to include the session property
  const sessionReq = req as NextApiRequest & { session: IronSession<IronSessionData> };

  if (sessionReq.method !== 'GET') {
    res.setHeader('Allow', ['GET']);
    return res.status(405).end(`Method ${sessionReq.method} Not Allowed`);
  }

  const tokens = sessionReq.session.tokens;

  // Check if tokens exist and if the access token hasn't expired (or is close to expiring)
  // Add a buffer (e.g., 5 minutes) to the expiry check
  const isAuthenticated = !!tokens?.access_token && tokens.expiry_date > Date.now() + 5 * 60 * 1000;

  res.status(200).json({ isAuthenticated });
};

export default withSessionRoute(handler);
</file>

<file path="pages/api/drive/list.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { google } from 'googleapis';
import { IronSession, IronSessionData } from 'iron-session';
import { withSessionRoute } from '@/app/lib/session';
import { getAuthenticatedClient } from '@/app/lib/googleDriveClient';

// Define the handler function with standard types expected by withSessionRoute
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Cast req to include the session property
  const sessionReq = req as NextApiRequest & { session: IronSession<IronSessionData> };

  if (sessionReq.method !== 'GET') {
    res.setHeader('Allow', ['GET']);
    return res.status(405).end(`Method ${sessionReq.method} Not Allowed`);
  }

  try {
    const oauth2Client = await getAuthenticatedClient(sessionReq.session);
    if (!oauth2Client) {
      return res.status(401).json({ error: 'Unauthorized or token refresh failed.' });
    }

    const drive = google.drive({ version: 'v3', auth: oauth2Client });

    console.log('Attempting to list files from Google Drive...');

    // List files created by this application with the specific name pattern
    // The 'drive.file' scope limits visibility to files created or opened by the app.
    // We filter by name pattern and mime type.
    const listResponse = await drive.files.list({
      // Query to find JSON files matching the backup name pattern
      // Note: Searching by name prefix might be slow on large drives.
      // Consider using appProperties if storing files in a specific folder isn't feasible with drive.file scope.
      q: "mimeType='application/json' and name contains 'app_backup_' and trashed = false", 
      fields: 'files(id, name, createdTime, modifiedTime)', // Get relevant file details
      orderBy: 'modifiedTime desc', // Show most recent backups first
      pageSize: 50, // Limit the number of results if necessary
      // Use 'spaces: drive' if you only want files in the main Drive space (not appDataFolder)
      spaces: 'drive', 
    });

    const files = listResponse.data.files || [];
    console.log(`Found ${files.length} backup files.`);

    res.status(200).json({ success: true, files });

  } catch (error: any) {
    console.error('Error listing files from Google Drive:', error.message);
    if (error.response?.data?.error?.message) {
       console.error('Google API Error Details:', error.response.data.error.message);
       res.status(500).json({ error: `Google Drive API error: ${error.response.data.error.message}` });
    } else {
       res.status(500).json({ error: 'Failed to list files from Google Drive.' });
    }
  }
};

export default withSessionRoute(handler);
</file>

<file path="pages/api/drive/listar-materiais.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { google } from 'googleapis';
import { IronSession, IronSessionData } from 'iron-session';
import { withSessionRoute } from '@/app/lib/session';
import { getAuthenticatedClient } from '@/app/lib/googleDriveClient';

// Define the handler function with standard types expected by withSessionRoute
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Cast req to include the session property
  const sessionReq = req as NextApiRequest & { session: IronSession<IronSessionData> };

  if (sessionReq.method !== 'GET') {
    res.setHeader('Allow', ['GET']);
    return res.status(405).end(`Method ${sessionReq.method} Not Allowed`);
  }

  try {
    const oauth2Client = await getAuthenticatedClient(sessionReq.session);
    if (!oauth2Client) {
      return res.status(401).json({ error: 'Unauthorized or token refresh failed.' });
    }

    const { folderId } = sessionReq.query;

    if (!folderId || typeof folderId !== 'string') {
      return res.status(400).json({ error: 'Missing or invalid folderId parameter.' });
    }

    const drive = google.drive({ version: 'v3', auth: oauth2Client });

    console.log(`Attempting to list files from Google Drive in folder: ${folderId}`);

    // List files created by this application with the specific name pattern
    // The 'drive.file' scope limits visibility to files created or opened by the app.
    // We filter by name pattern and mime type.
    const listResponse = await drive.files.list({
      // Query to find JSON files matching the backup name pattern
      // Note: Searching by name prefix might be slow on large drives.
      // Consider using appProperties if storing files in a specific folder isn't feasible with drive.file scope.
      q: `mimeType='text/markdown' and '${folderId}' in parents and trashed = false`,
      fields: 'files(id, name, createdTime, modifiedTime)', // Get relevant file details
      orderBy: 'modifiedTime desc', // Show most recent backups first
      pageSize: 50, // Limit the number of results if necessary
      // Use 'spaces: drive' if you only want files in the main Drive space (not appDataFolder)
      spaces: 'drive',
    });

    const files = listResponse.data.files || [];
    console.log(`Found ${files.length} backup files.`);

    res.status(200).json({ success: true, files });

  } catch (error: any) {
    console.error('Error listing files from Google Drive:', error.message);
    if (error.response?.data?.error?.message) {
       console.error('Google API Error Details:', error.response.data.error.message);
       res.status(500).json({ error: `Google Drive API error: ${error.response.data.error.message}` });
    } else {
       res.status(500).json({ error: 'Failed to list files from Google Drive.' });
    }
  }
};

export default withSessionRoute(handler);
</file>

<file path="pages/api/drive/load.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { google } from 'googleapis';
import { IronSession, IronSessionData } from 'iron-session';
import { withSessionRoute } from '@/app/lib/session';
import { getAuthenticatedClient } from '@/app/lib/googleDriveClient';
import { WritableStreamBuffer } from 'stream-buffers'; // Need to install stream-buffers

// Define the handler function with standard types expected by withSessionRoute
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Cast req to include the session property
  const sessionReq = req as NextApiRequest & { session: IronSession<IronSessionData> };

  if (sessionReq.method !== 'GET') {
    res.setHeader('Allow', ['GET']);
    return res.status(405).end(`Method ${sessionReq.method} Not Allowed`);
  }

  const { fileId } = sessionReq.query;

  if (!fileId || typeof fileId !== 'string') {
    return res.status(400).json({ error: 'Missing or invalid fileId query parameter.' });
  }

  try {
    const oauth2Client = await getAuthenticatedClient(sessionReq.session);
    if (!oauth2Client) {
      return res.status(401).json({ error: 'Unauthorized or token refresh failed.' });
    }

    const drive = google.drive({ version: 'v3', auth: oauth2Client });

    console.log(`Attempting to download file with ID: ${fileId}`);

    // Get the file content
    const fileResponse = await drive.files.get(
      { fileId: fileId, alt: 'media' },
      { responseType: 'stream' } // Request response as a stream
    );

    // Pipe the stream to a buffer to get the full content
    const dest = new WritableStreamBuffer();
    // Correctly handle the promise for stream completion/error
    await new Promise<void>((resolve, reject) => { // Add void type parameter for clarity
      const stream = fileResponse.data as NodeJS.ReadableStream; // Cast to NodeJS stream type
      stream.on('end', () => resolve());
      stream.on('error', (err) => reject(err)); // Pass error to reject
      stream.pipe(dest);
    }); // Correct closing parenthesis and semicolon placement

    const fileContent = dest.getContentsAsString('utf8');
    
    if (!fileContent) {
       throw new Error('Downloaded file content is empty.');
    }

    console.log(`File ${fileId} downloaded successfully.`);

    // Attempt to parse JSON to ensure it's valid before sending
    let jsonData;
    try {
      jsonData = JSON.parse(fileContent);
    } catch (parseError: any) {
      console.error(`Error parsing JSON content for file ${fileId}:`, parseError.message);
      return res.status(500).json({ error: 'Downloaded file is not valid JSON.' });
    }

    // Send the parsed JSON data back
    res.status(200).json({ success: true, data: jsonData });

  } catch (error: any) {
    console.error(`Error loading file ${fileId} from Google Drive:`, error.message);
    if (error.response?.data?.error?.message) {
       console.error('Google API Error Details:', error.response.data.error.message);
       res.status(500).json({ error: `Google Drive API error: ${error.response.data.error.message}` });
    } else if (error.response?.status === 404) {
       res.status(404).json({ error: 'File not found on Google Drive.' });
    } else {
       res.status(500).json({ error: 'Failed to load file from Google Drive.' });
    }
  }
};

export default withSessionRoute(handler);
</file>

<file path="pages/api/drive/save.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { google } from 'googleapis';
import { IronSession, IronSessionData } from 'iron-session';
import { withSessionRoute } from '@/app/lib/session';
import { getAuthenticatedClient } from '@/app/lib/googleDriveClient';
import { Readable } from 'stream';

// Define the handler function with standard types expected by withSessionRoute
const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Cast req to include the session property
  const sessionReq = req as NextApiRequest & { session: IronSession<IronSessionData> };

  if (sessionReq.method !== 'POST') {
    res.setHeader('Allow', ['POST']);
    return res.status(405).end(`Method ${sessionReq.method} Not Allowed`);
  }

  try {
    const oauth2Client = await getAuthenticatedClient(sessionReq.session);
    if (!oauth2Client) {
      return res.status(401).json({ error: 'Unauthorized or token refresh failed.' });
    }

    // Get data from request body - assume it's already a JSON string or object
    const dataToSave = sessionReq.body; 
    if (!dataToSave) {
      return res.status(400).json({ error: 'No data provided in request body.' });
    }

    // Ensure data is a string for upload
    const jsonDataString = typeof dataToSave === 'string' ? dataToSave : JSON.stringify(dataToSave, null, 2);
    
    // Convert string to a readable stream for upload
    const stream = new Readable();
    stream.push(jsonDataString);
    stream.push(null); // Signal end of stream

    const drive = google.drive({ version: 'v3', auth: oauth2Client });

    // Define file metadata
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const fileName = `app_backup_${timestamp}.json`;
    const fileMetadata = {
      name: fileName,
      // If using drive.file scope, files are typically created in root or user selects location.
      // To store in a specific app folder requires drive.appdata scope or more complex folder management.
      // parents: ['appDataFolder'] // Use this if you have 'drive.appdata' scope instead of 'drive.file'
    };

    // Define media body
    const media = {
      mimeType: 'application/json',
      body: stream, // Use the readable stream
    };

    console.log(`Attempting to upload file: ${fileName}`);

    // Upload the file
    const file = await drive.files.create({
      requestBody: fileMetadata,
      media: media,
      fields: 'id, name', // Request the ID and name of the created file
    });

    console.log(`File uploaded successfully: ID: ${file.data.id}, Name: ${file.data.name}`);

    res.status(200).json({ success: true, fileId: file.data.id, fileName: file.data.name });

  } catch (error: any) {
    console.error('Error saving data to Google Drive:', error.message);
    // Provide more specific error messages if possible
    if (error.response?.data?.error?.message) {
       console.error('Google API Error Details:', error.response.data.error.message);
       res.status(500).json({ error: `Google Drive API error: ${error.response.data.error.message}` });
    } else {
       res.status(500).json({ error: 'Failed to save data to Google Drive.' });
    }
  }
};

export default withSessionRoute(handler);
</file>

<file path="pages/api/materiais/ler.ts">
import type { NextApiRequest, NextApiResponse } from 'next';
import fs from 'fs/promises';
import path from 'path';

type Data = {
    content: string;
} | {
    error: string;
}

export default async function handler(
    req: NextApiRequest,
    res: NextApiResponse<Data>
) {
    if (req.method !== 'GET') {
        res.setHeader('Allow', ['GET']);
        return res.status(405).json({ error: `Method ${req.method} Not Allowed` });
    }

    const filePathQuery = req.query.path;

    if (typeof filePathQuery !== 'string' || !filePathQuery) {
        return res.status(400).json({ error: 'Missing or invalid "path" query parameter.' });
    }

    // Validação de segurança: garantir que o caminho começa com .ruru/
    if (!filePathQuery.startsWith('.ruru/')) {
        // Log de segurança pode ser adicionado aqui
        console.warn(`Tentativa de acesso fora do diretório .ruru/: ${filePathQuery}`);
        return res.status(403).json({ error: 'Access forbidden. Path must start with .ruru/' });
    }

    try {
        // Determina a raiz real do projeto (um nível acima de process.cwd() que está em /stayf)
        const actualProjectRoot = path.resolve(process.cwd(), '..');

        // Resolve o caminho absoluto do arquivo usando a raiz real do projeto
        const absolutePath = path.resolve(actualProjectRoot, filePathQuery);

        // Ajusta a definição do diretório .ruru para a verificação de segurança, usando a raiz real do projeto
        const correctRuruDir = path.resolve(actualProjectRoot, '.ruru');

        // Normaliza ambos os caminhos para comparação consistente entre OS
        const normalizedAbsolutePath = path.normalize(absolutePath);
        // Adiciona separador para garantir que a pasta raiz não seja permitida e usa o diretório correto
        const normalizedCorrectRuruDir = path.normalize(correctRuruDir + path.sep);

        if (!normalizedAbsolutePath.startsWith(normalizedCorrectRuruDir)) {
             console.warn(`Tentativa de acesso fora do diretório .ruru/ (após resolução): ${filePathQuery} resolvido para ${absolutePath}`);
             return res.status(403).json({ error: 'Access forbidden. Invalid path after resolution.' });
        }

        const fileContent = await fs.readFile(absolutePath, 'utf-8');
        return res.status(200).json({ content: fileContent });

    } catch (error: any) {
        console.error(`Error reading file ${filePathQuery}:`, error);
        if (error.code === 'ENOENT') {
            return res.status(404).json({ error: `File not found: ${filePathQuery}` });
        }
        return res.status(500).json({ error: 'Internal Server Error reading file.' });
    }
}
</file>

<file path="pages/api/materiais/listar.ts">
import { promises as fs } from 'fs';
import path from 'path';
import { NextApiRequest, NextApiResponse } from 'next';

const allowedMaterialTypes = [
  'summaries',
  'flashcards',
  'practice_exams',
  'tasks',
  'mind_maps',
  'infographics',
  'study_guide',
  'checklists',
];

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    return res.status(405).json({ message: 'Method Not Allowed' });
  }

  const { tipo } = req.query;

  if (typeof tipo !== 'string' || !tipo) {
    return res.status(400).json({ message: 'Missing or invalid "tipo" query parameter' });
  }

  if (!allowedMaterialTypes.includes(tipo)) {
    return res.status(403).json({ message: `Forbidden: Material type "${tipo}" is not allowed.` });
  }

  // Resolve the path from the project root, similar to ler.ts
  const projectRoot = path.resolve(process.cwd(), '..'); // Assuming stayf is one level down from project root
  const materialDirPath = path.resolve(projectRoot, '.ruru', tipo);

  try {
    const files = await fs.readdir(materialDirPath);

    const mdFiles = files.filter(file => file.endsWith('.md'));

    return res.status(200).json({ files: mdFiles });
  } catch (error: any) {
    if (error.code === 'ENOENT') {
      // Directory not found
      return res.status(404).json({ message: `Material directory not found for type "${tipo}".` });
    }
    // Other errors
    console.error(`Error reading material directory for type "${tipo}":`, error);
    return res.status(500).json({ message: 'Internal Server Error' });
  }
}
</file>

<file path="pages/api/gerar-questao.ts">
import type { NextApiRequest, NextApiResponse } from 'next';

// Estrutura do JSON de questão esperado
interface QuestaoLLM {
  questao: string;
  alternativas: string[];
  correta: string; // Letra: "A", "B", "C", "D"
  disciplina: string;
  topico: string;
}

interface GerarQuestaoRequest {
  disciplina: string;
  topico?: string;
  resumo?: string;
  quantidade: number;
  dificuldade?: 'facil' | 'medio' | 'dificil';
  max_tokens?: number;
}

import fetch from 'node-fetch';

// Chave e modelo Perplexity
const PPLX_API_KEY = process.env.PPLX_API_KEY;
if (!PPLX_API_KEY) {
  throw new Error('A variável de ambiente PPLX_API_KEY não está definida.');
}
const PPLX_MODEL = 'sonar-pro';

// Chamada real à Perplexity API
async function gerarQuestoesPerplexity({ disciplina, topico, resumo, quantidade, dificuldade, max_tokens }: GerarQuestaoRequest): Promise<QuestaoLLM[]> {
  // Instrução extra para a LLM conforme dificuldade
  let instrucaoDificuldade = '';
  if (dificuldade === 'facil') {
    instrucaoDificuldade = 'As questões devem ser diretas, sem exigir raciocínio complexo. Use até 2000 tokens.';
  } else if (dificuldade === 'medio') {
    instrucaoDificuldade = 'As questões devem exigir reflexão moderada, com enunciados mais elaborados. Use até 5000 tokens e invista mais recursos computacionais para garantir qualidade e profundidade.';
  } else if (dificuldade === 'dificil') {
    instrucaoDificuldade = 'As questões devem ser desafiadoras, exigindo análise crítica e interpretação profunda. Use até 8000 tokens e utilize o máximo de recursos computacionais para garantir questões complexas e bem fundamentadas.';
  }
  const prompt = `
Gere ${quantidade} questões objetivas de múltipla escolha, cada uma com 4 alternativas e apenas uma correta, no formato JSON abaixo. Use apenas o contexto fornecido.
Nível de dificuldade: ${dificuldade ? dificuldade.toUpperCase() : 'FÁCIL'}. ${instrucaoDificuldade}

{
  "questao": "Enunciado da questão",
  "alternativas": [
    "Alternativa A",
    "Alternativa B",
    "Alternativa C",
    "Alternativa D"
  ],
  "correta": "Letra da alternativa correta (A, B, C ou D)",
  "disciplina": "${disciplina}",
  "topico": "${topico || ''}"
}

Contexto:
${resumo || '[Resumo não fornecido]'}
  `;

  const response = await fetch('https://api.perplexity.ai/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${PPLX_API_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: PPLX_MODEL,
      messages: [
        { role: 'system', content: 'Você é um gerador de questões para concursos públicos. Responda sempre no formato JSON especificado.' },
        { role: 'user', content: prompt }
      ],
      max_tokens: max_tokens || 2000,
      temperature: 0.0
    })
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Erro Perplexity: ${errorText}`);
  }

  const data = await response.json();
  // A resposta vem em data.choices[0].message.content (string JSON)
  let questoes: QuestaoLLM[] = [];
  try {
    const content = data.choices?.[0]?.message?.content;
    // Remove blocos markdown ```json ... ``` ou ```
    let jsonString = content;
    if (typeof jsonString === 'string') {
      const match = jsonString.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
      if (match && match[1]) {
        jsonString = match[1];
      }
    }
    questoes = JSON.parse(jsonString);
    if (!Array.isArray(questoes)) {
      throw new Error('Formato inesperado: não é um array de questões.');
    }
  } catch (err) {
    throw new Error('Erro ao parsear resposta da LLM: ' + (err instanceof Error ? err.message : String(err)));
  }
  return questoes;
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).end();

  const { disciplina, topico, resumo, quantidade, dificuldade, max_tokens } = req.body as GerarQuestaoRequest;

  if (!disciplina || !quantidade) {
    return res.status(400).json({ error: "Disciplina e quantidade são obrigatórios." });
  }

  // Monta o prompt enxuto (apenas para log/debug)
  const prompt = `
Gere ${quantidade} questões objetivas de múltipla escolha, cada uma com 4 alternativas e apenas uma correta, no formato JSON abaixo. Use apenas o contexto fornecido.
Nível de dificuldade: ${dificuldade ? dificuldade.toUpperCase() : 'FÁCIL'}.

{
  "questao": "Enunciado da questão",
  "alternativas": [
    "Alternativa A",
    "Alternativa B",
    "Alternativa C",
    "Alternativa D"
  ],
  "correta": "Letra da alternativa correta (A, B, C ou D)",
  "disciplina": "${disciplina}",
  "topico": "${topico || ''}"
}

Contexto:
${resumo || '[Resumo não fornecido]'}
  `;

  console.log("Prompt enviado à LLM/MCP:", prompt);

  try {
    const questoes = await gerarQuestoesPerplexity({ disciplina, topico, resumo, quantidade, dificuldade, max_tokens });
    res.status(200).json({ questoes });
  } catch (err) {
    console.error('Erro ao gerar questões via Perplexity:', err);
    res.status(500).json({ error: err instanceof Error ? err.message : 'Erro desconhecido ao gerar questões.' });
  }
}
</file>

<file path="public/images/cat-icon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M12 22C10.4983 22 9.13373 21.5551 8 20.8061V21C8 21.5523 7.55228 22 7 22C6.44772 22 6 21.5523 6 21V18.8504C6 18.4234 6.27816 18.0459 6.6822 17.9228C8.02757 17.5844 9 16.3863 9 15C9 14.4477 9.44772 14 10 14C10.5523 14 11 14.4477 11 15V19C11 19.5523 11.4477 20 12 20C12.5523 20 13 19.5523 13 19V13C13 12.4477 13.4477 12 14 12C14.5523 12 15 12.4477 15 13V16C15 16.5523 15.4477 17 16 17C16.5523 17 17 16.5523 17 16V9.82929C17 9.41745 16.8468 9.02133 16.5713 8.73242L15.1603 7.26383C14.4003 6.46991 14 5.41999 14 4.33313V3.71753C14 2.44046 13.2549 1.27708 12.0732 0.770274C11.5359 0.55102 11.2313 0.00752863 11.45 -0.529708C11.6687 -1.06694 12.2126 -1.37112 12.7499 -1.15186C14.8069 -0.299813 16 1.5933 16 3.71753V4.33313C16 4.86656 16.2001 5.37998 16.5603 5.76383L17.9713 7.23242C18.6318 7.9206 19 8.85755 19 9.82929V16C19 17.6569 17.6569 19 16 19C15.8252 19 15.6551 18.9835 15.4915 18.9521C15.2186 20.1691 14.1785 21.0766 12.9218 21.0988C12.6153 21.1069 12.3126 21.0677 12.0226 20.9883C12.0151 20.9925 12.0075 20.9966 12 22Z" fill="currentColor"/>
</svg>
</file>

<file path="public/images/logo.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="800" height="800" viewBox="0 0 800 800" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="infinityGradient" x1="10%" y1="10%" x2="90%" y2="90%">
      <stop offset="0%" stop-color="#5DE0C9" />
      <stop offset="50%" stop-color="#64B6DC" />
      <stop offset="100%" stop-color="#6A8CEE" />
    </linearGradient>
    <radialGradient id="circleGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#FFDA80" />
      <stop offset="100%" stop-color="#F5B942" />
    </radialGradient>
    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur in="SourceAlpha" stdDeviation="10" />
      <feOffset dx="0" dy="3" result="offsetblur" />
      <feComponentTransfer>
        <feFuncA type="linear" slope="0.2" />
      </feComponentTransfer>
      <feMerge>
        <feMergeNode />
        <feMergeNode in="SourceGraphic" />
      </feMerge>
    </filter>
    <filter id="glow" x="-20%" y="-20%" width="140%" height="140%">
      <feGaussianBlur in="SourceGraphic" stdDeviation="8" result="blur" />
      <feComposite in="blur" in2="SourceGraphic" operator="over" />
    </filter>
  </defs>
  <g transform="translate(0, 50)">
    <path d="M400,230 
           C340,160 220,210 210,350 
           C200,490 340,540 400,460 
           C460,540 580,490 590,350 
           C600,210 460,160 400,230 Z" 
          fill="url(#infinityGradient)" 
          stroke="#ffffff"
          stroke-opacity="0.15"
          stroke-width="8"
          filter="url(#shadow)"
          style="stroke-linecap: round; stroke-linejoin: round;" />
    <circle cx="400" cy="190" r="35" fill="url(#circleGradient)" filter="url(#glow)" />
  </g>
</svg>
</file>

<file path="public/sounds/alarm.mp3">

</file>

<file path="public/sounds/alarm.ogg">

</file>

<file path="public/favicon.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg width="800" height="800" viewBox="0 0 800 800" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="infinityGradient" x1="10%" y1="10%" x2="90%" y2="90%">
      <stop offset="0%" stop-color="#000000" />
      <stop offset="100%" stop-color="#000000" />
    </linearGradient>
  </defs>
  <g transform="translate(0, 50)">
    <path d="M400,300 
           C340,230 220,280 220,350 
           C220,420 340,470 400,400 
           C460,470 580,420 580,350 
           C580,280 460,230 400,300 Z" 
          fill="url(#infinityGradient)" 
          stroke-width="20"
          style="stroke-linecap: round; stroke-linejoin: round;" />
  </g>
</svg>
</file>

<file path="public/simulado-exemplo.json">
{
  "metadata": {
    "titulo": "Simulado de Conhecimentos Gerais para Neurodivergentes",
    "concurso": "Concurso Inclusivo 2025",
    "ano": 2025,
    "area": "Conhecimentos Gerais",
    "nivel": "Médio",
    "totalQuestoes": 10,
    "tempoPrevisto": 30,
    "autor": "Instituto de Apoio Neurodivergente",
    "dataGeracao": "2025-03-30"
  },
  "questoes": [
    {
      "id": 1,
      "enunciado": "Qual das seguintes é considerada uma condição neurodivergente?",
      "alternativas": {
        "a": "Hipertensão",
        "b": "TDAH (Transtorno do Déficit de Atenção e Hiperatividade)",
        "c": "Diabetes",
        "d": "Astigmatismo",
        "e": "Artrite"
      },
      "gabarito": "b",
      "assunto": "Neurodiversidade",
      "dificuldade": 1,
      "explicacao": "O TDAH é um transtorno neurobiológico, caracterizado por padrões persistentes de desatenção, hiperatividade e impulsividade, sendo considerado parte da neurodiversidade."
    },
    {
      "id": 2,
      "enunciado": "Qual estratégia abaixo NÃO é recomendada para auxiliar pessoas com dislexia?",
      "alternativas": {
        "a": "Uso de fontes específicas como OpenDyslexic",
        "b": "Leitores de tela e audiobooks",
        "c": "Mapas mentais e organizadores visuais",
        "d": "Exigir leitura em voz alta em público sem preparação prévia",
        "e": "Permitir tempo adicional para leitura e escrita"
      },
      "gabarito": "d",
      "assunto": "Dislexia",
      "dificuldade": 2,
      "explicacao": "Exigir leitura em voz alta sem preparação pode causar ansiedade e desconforto desnecessários para pessoas com dislexia, reduzindo sua confiança e aumentando a dificuldade de processamento textual."
    },
    {
      "id": 3,
      "enunciado": "A técnica Pomodoro, útil para pessoas com TDAH, consiste em:",
      "alternativas": {
        "a": "Dividir o trabalho em blocos de tempo focado com pausas curtas",
        "b": "Fazer todas as tarefas difíceis no final do dia",
        "c": "Estudar apenas com música clássica de fundo",
        "d": "Tomar medicação a cada 25 minutos",
        "e": "Evitar qualquer pausa durante períodos de estudo"
      },
      "gabarito": "a",
      "assunto": "Técnicas de Produtividade",
      "dificuldade": 1,
      "dicas": ["Pense em como gerenciar o tempo de forma estruturada", "O nome vem de um temporizador de cozinha"]
    },
    {
      "id": 4,
      "enunciado": "Qual dessas afirmações sobre estimulação sensorial é INCORRETA?",
      "alternativas": {
        "a": "Pessoas autistas podem ser hipersensíveis a certos estímulos sensoriais",
        "b": "A hipersensibilidade auditiva pode dificultar a concentração em ambientes barulhentos",
        "c": "Estímulos sensoriais afetam igualmente todas as pessoas neurodivergentes da mesma forma",
        "d": "Algumas pessoas podem se beneficiar de objetos de estimulação tátil como fidgets",
        "e": "A iluminação fluorescente pode causar sobrecarga sensorial em algumas pessoas"
      },
      "gabarito": "c",
      "assunto": "Processamento Sensorial",
      "dificuldade": 2,
      "explicacao": "A experiência sensorial varia amplamente entre indivíduos neurodivergentes. Cada pessoa tem um perfil sensorial único, algumas podem ser hipersensíveis a sons mas não a luzes, enquanto outras podem ter o padrão inverso."
    },
    {
      "id": 5,
      "enunciado": "Quais destes aplicativos foram especificamente desenvolvidos para auxiliar pessoas com autismo?",
      "alternativas": {
        "a": "Instagram e Twitter",
        "b": "WhatsApp e Telegram",
        "c": "Habitica e Forest",
        "d": "Proloquo2Go e AutismXpress",
        "e": "Excel e PowerPoint"
      },
      "gabarito": "d",
      "assunto": "Tecnologia Assistiva",
      "dificuldade": 3
    },
    {
      "id": 6,
      "enunciado": "O que é 'masking' no contexto da neurodiversidade?",
      "alternativas": {
        "a": "Uma técnica de meditação para acalmar a mente",
        "b": "O processo de esconder traços neurodivergentes para se adequar socialmente",
        "c": "Usar máscaras de proteção em ambientes com muitos estímulos",
        "d": "Um método terapêutico para reduzir ansiedade",
        "e": "Uma forma de terapia ocupacional específica para autistas"
      },
      "gabarito": "b",
      "assunto": "Identidade Neurodivergente",
      "dificuldade": 2,
      "explicacao": "Masking (ou mascaramento) refere-se ao processo pelo qual pessoas neurodivergentes, especialmente autistas, escondem conscientemente ou suprimem comportamentos naturais para parecerem 'típicos' em situações sociais. Esse processo pode ser extremamente exaustivo mentalmente."
    },
    {
      "id": 7,
      "enunciado": "Qual legislação brasileira garante direitos educacionais para estudantes neurodivergentes?",
      "alternativas": {
        "a": "Lei da Ficha Limpa",
        "b": "Lei Maria da Penha",
        "c": "Lei Brasileira de Inclusão (LBI)",
        "d": "Código de Defesa do Consumidor",
        "e": "Lei da Anistia"
      },
      "gabarito": "c",
      "assunto": "Legislação Inclusiva",
      "dificuldade": 2,
      "dicas": ["Foi promulgada em 2015", "Também é conhecida como Estatuto da Pessoa com Deficiência"]
    },
    {
      "id": 8,
      "enunciado": "Qual das seguintes alterações em ambientes de trabalho é um exemplo de acomodação razoável para uma pessoa com sensibilidade sensorial?",
      "alternativas": {
        "a": "Determinar que todos os funcionários trabalhem em silêncio absoluto",
        "b": "Permitir o uso de fones de ouvido com cancelamento de ruído quando necessário",
        "c": "Exigir que a pessoa trabalhe apenas em horários noturnos",
        "d": "Instalar mais luzes fluorescentes piscantes no ambiente",
        "e": "Remover todas as divisórias do ambiente de trabalho"
      },
      "gabarito": "b",
      "assunto": "Acomodações no Trabalho",
      "dificuldade": 1
    },
    {
      "id": 9,
      "enunciado": "O que significa a sigla 'CID' no contexto de diagnósticos?",
      "alternativas": {
        "a": "Comprometimento Intelectual e Desenvolvimental",
        "b": "Centro de Informações sobre Deficiências",
        "c": "Classificação Internacional de Doenças",
        "d": "Coordenação de Inclusão e Diversidade",
        "e": "Comitê Interno de Diagnósticos"
      },
      "gabarito": "c",
      "assunto": "Terminologia Médica",
      "dificuldade": 1,
      "explicacao": "A Classificação Internacional de Doenças (CID) é publicada pela Organização Mundial da Saúde (OMS) e fornece códigos para classificação de doenças e condições de saúde, incluindo condições neurodivergentes."
    },
    {
      "id": 10,
      "enunciado": "Qual dos seguintes NÃO é um sistema de Comunicação Alternativa e Aumentativa (CAA) que pode auxiliar pessoas não-verbais?",
      "alternativas": {
        "a": "PECS (Sistema de Comunicação por Troca de Figuras)",
        "b": "Makaton (combinação de sinais e símbolos)",
        "c": "Boardmaker",
        "d": "TEACCH (programa estruturado de ensino)",
        "e": "Livox (aplicativo de CAA)"
      },
      "gabarito": "d",
      "assunto": "Comunicação Alternativa",
      "dificuldade": 3,
      "explicacao": "TEACCH (Treatment and Education of Autistic and Communication related handicapped CHildren) é uma abordagem estruturada de ensino para pessoas autistas, mas não é um sistema de Comunicação Alternativa e Aumentativa. Os outros são sistemas ou ferramentas de CAA."
    }
  ]
}
</file>

<file path=".cursorrules">
You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS and modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.

- Follow the user’s requirements carefully & to the letter.
- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail.
- Confirm, then write code!
- Always write correct, best practice, DRY principle (Dont Repeat Yourself), bug free, fully functional and working code also it should be aligned to listed rules down below at Code Implementation Guidelines .
- Focus on easy and readability code, over being performant.
- Fully implement all requested functionality.
- Leave NO todo’s, placeholders or missing pieces.
- Ensure code is complete! Verify thoroughly finalised.
- Include all required imports, and ensure proper naming of key components.
- Be concise Minimize any other prose.
- If you think there might not be a correct answer, you say so.
- If you do not know the answer, say so, instead of guessing.

### Coding Environment
The user asks questions about the following coding languages:
- ReactJS
- NextJS
- JavaScript
- TypeScript
- TailwindCSS
- HTML
- CSS

### Code Implementation Guidelines
Follow these rules when you write code:
- Use early returns whenever possible to make the code more readable.
- Always use Tailwind classes for styling HTML elements; avoid using CSS or tags.
- Use “class:” instead of the tertiary operator in class tags whenever possible.
- Use descriptive variable and function/const names. Also, event functions should be named with a “handle” prefix, like “handleClick” for onClick and “handleKeyDown” for onKeyDown.
- Implement accessibility features on elements. For example, a tag should have a tabindex=“0”, aria-label, on:click, and on:keydown, and similar attributes.
- Use consts instead of functions, for example, “const toggle = () =>”. Also, define a type if possible.
</file>

<file path=".gitignore">
# dependências
/node_modules
/.pnp
.pnp.js

# testes
/coverage

# next.js
/.next/
/out/

# produção
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# variáveis de ambiente
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# credenciais e segredos
client_secret*.json
*googleusercontent*.json
</file>

<file path="app.json">
{
  "expo": {
    "name": "stayfocus",
    "slug": "stayfocus",
    "version": "1.0.0",
    "sdkVersion": "44.0.0",
    "platforms": ["ios", "android"],
    "entryPoint": "node_modules/expo/AppEntry.js",
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#FFFFFF"
      }
    }
  }
}
</file>

<file path="dash.md">
// app/page.tsx

import { FC, Suspense } from 'react';
import { PainelDia } from '@/components/PainelDia';
import { ListaPrioridades } from '@/components/ListaPrioridades';
import { ChecklistMedicamentos } from '@/components/ChecklistMedicamentos';
import { LembretePausas } from '@/components/LembretePausas';
import { CardProximaProva } from '@/components/CardProximaProva';
import { ModeToggle } from '@/components/ModeToggle';

const DashboardPage: FC = () => {
  return (
    <div className="min-h-screen bg-background text-foreground">
      <header className="flex items-center justify-between px-4 py-3 shadow-md">
        <h1 className="text-xl font-bold">StayFocus</h1>
        <ModeToggle />
      </header>

      <div className="flex flex-col lg:flex-row">
        <aside className="lg:w-64 w-full lg:h-screen border-r px-4 py-6 space-y-4">
          <nav className="space-y-2">
            <a href="#" className="block font-medium hover:underline">Painel do Dia</a>
            <a href="#" className="block font-medium hover:underline">Prioridades</a>
            <a href="#" className="block font-medium hover:underline">Medicamentos</a>
            <a href="#" className="block font-medium hover:underline">Pausas</a>
            <a href="#" className="block font-medium hover:underline">Concursos</a>
          </nav>
        </aside>

        <main className="flex-1 px-4 py-6 space-y-6">
          <Suspense fallback={<div>Carregando painel...</div>}>
            <PainelDia />
            <ListaPrioridades />
            <ChecklistMedicamentos />
            <LembretePausas />
            <CardProximaProva />
          </Suspense>
        </main>
      </div>
    </div>
  );
};

export default DashboardPage;
</file>

<file path="deploy.sh">
#!/bin/bash

# Script de deploy para o aplicativo Painel Neurodivergentes

echo "Iniciando deploy do aplicativo..."

# Atualizar o código do repositório
echo "Atualizando código do repositório..."
git pull

# Instalar dependências
echo "Instalando dependências..."
npm install

# Construir o aplicativo
echo "Construindo o aplicativo..."
npm run build

# Iniciar o servidor
echo "Iniciando o servidor em modo de produção..."
npm run start

echo "Deploy concluído! O aplicativo está rodando em modo de produção."
</file>

<file path="next.config.js">
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Suas outras configurações do Next.js aqui...
  reactStrictMode: true,
}

module.exports = withBundleAnalyzer(nextConfig)
</file>

<file path="package.json">
{
  "name": "painel-neurodivergentes",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "analyze": "set ANALYZE=true&& npm run build"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.17",
    "@types/node-fetch": "^2.6.12",
    "@types/stream-buffers": "^3.0.7",
    "@vercel/speed-insights": "^1.2.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "googleapis": "^148.0.0",
    "iron-session": "^8.0.4",
    "lucide-react": "^0.501.0",
    "next": "14.0.4",
    "next-themes": "^0.2.1",
    "node-fetch": "^2.7.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-markdown": "^10.1.0",
    "recharts": "^2.15.1",
    "stream-buffers": "^3.0.3",
    "tailwind-merge": "^3.0.2",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@next/bundle-analyzer": "^15.2.4",
    "@types/node": "^20.10.4",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.17",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-config-next": "14.0.4",
    "postcss": "^8.4.32",
    "prettier": "^3.1.1",
    "tailwindcss": "^3.3.6",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // Cores para cada seção, com contraste reduzido para evitar incômodo visual
        inicio: {
          primary: '#4F46E5', // Indigo
          secondary: '#818CF8',
          light: '#EEF2FF90', // Reduzida opacidade para suavizar
        },
        alimentacao: {
          primary: '#10B981', // Esmeralda
          secondary: '#34D399',
          light: '#ECFDF590', // Reduzida opacidade para suavizar
        },
        estudos: {
          primary: '#FF8C00', // Changed from Amber to a darker orange for better contrast
          secondary: '#FFB74D',
          light: '#FFF3E0', // Removed transparency for better contrast
          dark: '#E65100', // Added a dark version for dark mode
        },
        saude: {
          primary: '#EF4444', // Vermelho
          secondary: '#F87171',
          light: '#FEF2F290', // Reduzida opacidade para suavizar
        },
        lazer: {
          primary: '#8B5CF6', // Violeta
          secondary: '#A78BFA',
          light: '#F5F3FF90', // Reduzida opacidade para suavizar
        },
        financas: {
          primary: '#0EA5E9', // Azul céu
          secondary: '#38BDF8',
          light: '#E0F2FE90', // Reduzida opacidade para suavizar
        },
        hiperfocos: {
          primary: '#F97316', // Laranja intenso
          secondary: '#FB923C',
          light: '#FFF7ED90', // Reduzida opacidade para suavizar
        },
        sono: {
          primary: '#5D4DB2', // Roxo azulado (lembrando noite)
          secondary: '#7B6DC3',
          light: '#EDE9FF90', // Reduzida opacidade para suavizar
        },
        perfil: {
          primary: '#3B82F6', // Azul (representando identidade/personalização)
          secondary: '#60A5FA',
          light: '#EFF6FF90', // Reduzida opacidade para suavizar
        },
        autoconhecimento: {
          primary: '#6B7280', // Cinza azulado (calma, reflexão)
          secondary: '#9CA3AF',
          light: '#F9FAFB90', // Reduzida opacidade para suavizar
          hover: '#4B5563', // Versão mais escura para hover
        },
      },
      fontFamily: {
        sans: ['Inter', 'sans-serif'],
      },
      borderRadius: {
        'xl': '1rem',
        '2xl': '1.5rem',
      },
      animation: {
        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
